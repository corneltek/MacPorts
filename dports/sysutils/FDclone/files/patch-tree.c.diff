--- tree.c.diff	2010-09-25 00:00:00.000000000 +0900
+++ tree.c	2012-03-09 18:23:25.000000000 +0900
@@ -36,6 +36,7 @@
 static int NEAR treeup __P_((VOID_A));
 static int NEAR treedown __P_((VOID_A));
 static int NEAR freetree __P_((treelist *, int));
+static int NEAR bottomtree __P_((VOID_A));
 static VOID NEAR _tree_search __P_((VOID_A));
 static int NEAR _tree_input __P_((VOID_A));
 static char *NEAR _tree __P_((VOID_A));
@@ -556,6 +557,24 @@
 	return(n);
 }
 
+static int NEAR bottomtree(VOID_A)
+{
+	int min, oy, otop;
+
+	min = filetop(win);
+	oy = tr_line;
+	otop = tr_top;
+	while (tr_line < min + FILEPERROW - 2) if (treedown() < 0) break;
+	if (tr_line >= tr_bottom - 1 && tr_top >= min + 1) {
+		tr_line = oy;
+		tr_top = otop;
+		searchtree();
+		return(-1);
+	}
+
+	return(0);
+}
+
 static VOID NEAR _tree_search(VOID_A)
 {
 	int oy, otop;
@@ -595,23 +614,20 @@
 			treedown();
 			break;
 		case K_PPAGE:
+			if (bottomtree() < 0) break;
 			half = (FILEPERROW - 1) / 2;
-			tmp = min + half + 1 - tr_line;
+			tmp = min + half + 1;
 			if (tr_top + half > min + 1) half = min - tr_top + 1;
 			if (half > 0) tr_top += half;
-			for (;tmp > 0; tmp--) if (treedown() < 0) break;
-			tr_line += tmp;
+			tr_line = tmp;
 			searchtree();
 			break;
 		case K_NPAGE:
+			if (bottomtree() < 0) break;
 			half = (FILEPERROW - 1) / 2;
-			tmp = half + (min + half + 1) - tr_line;
-			while (tmp-- > 0) if (treedown() < 0) break;
-			tmp = tr_line - (min + half + 1);
-			tr_line = min + half + 1;
-			if (tr_bottom - tmp < min + FILEPERROW - 1)
-				tmp = tr_bottom - min + FILEPERROW + 1;
-			tr_top -= tmp;
+			tmp = min + half + 1;
+			while (half-- > 0) if (treedown() < 0) break;
+			tr_line = tmp;
 			searchtree();
 			break;
 		case K_BEG:
@@ -676,6 +692,7 @@
 		case K_BS:
 			do {
 				if (treeup() < 0) break;
+				if (!tr_cur || !(tr_cur -> sub)) break;
 			} while (&(tr_cur -> sub[tr_no]) != old);
 			break;
 		case 'l':
