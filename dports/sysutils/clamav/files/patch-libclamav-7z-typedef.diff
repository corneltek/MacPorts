diff -u -d -b -w -r libclamav/7z/7z.h libclamav/7z/7z.h
--- libclamav/7z/7z.h	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/7z.h	2013-09-25 11:40:44.000000000 -0400
@@ -10,7 +10,7 @@
 
 #define k7zStartHeaderSize 0x20
 #define k7zSignatureSize 6
-extern Byte k7zSignature[k7zSignatureSize];
+extern SZByte k7zSignature[k7zSignatureSize];
 #define k7zMajorVersion 0
 
 enum EIdEnum
@@ -83,7 +83,7 @@
 
 SRes SzFolder_Decode(const CSzFolder *folder, const UInt64 *packSizes,
     ILookInStream *stream, UInt64 startPos,
-    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain);
+    SZByte *outBuffer, size_t outSize, ISzAlloc *allocMain);
 
 typedef struct
 {
@@ -97,12 +97,12 @@
   UInt64 Size;
   UInt32 Crc;
   UInt32 Attrib;
-  Byte HasStream;
-  Byte IsDir;
-  Byte IsAnti;
-  Byte CrcDefined;
-  Byte MTimeDefined;
-  Byte AttribDefined;
+  SZByte HasStream;
+  SZByte IsDir;
+  SZByte IsAnti;
+  SZByte CrcDefined;
+  SZByte MTimeDefined;
+  SZByte AttribDefined;
 } CSzFileItem;
 
 void SzFile_Init(CSzFileItem *p);
@@ -110,7 +110,7 @@
 typedef struct
 {
   UInt64 *PackSizes;
-  Byte *PackCRCsDefined;
+  SZByte *PackCRCsDefined;
   UInt32 *PackCRCs;
   CSzFolder *Folders;
   CSzFileItem *Files;
@@ -177,7 +177,7 @@
     ILookInStream *inStream,
     UInt32 fileIndex,         /* index of file */
     UInt32 *blockIndex,       /* index of solid block */
-    Byte **outBuffer,         /* pointer to pointer to output buffer (allocated with allocMain) */
+    SZByte **outBuffer,         /* pointer to pointer to output buffer (allocated with allocMain) */
     size_t *outBufferSize,    /* buffer size for output buffer */
     size_t *offset,           /* offset of stream for required file in *outBuffer */
     size_t *outSizeProcessed, /* size of file in *outBuffer */
diff -u -d -b -w -r libclamav/7z/7zBuf.c libclamav/7z/7zBuf.c
--- libclamav/7z/7zBuf.c	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/7zBuf.c	2013-09-25 11:31:31.000000000 -0400
@@ -1,4 +1,4 @@
-/* 7zBuf.c -- Byte Buffer
+/* 7zBuf.c -- SZByte Buffer
 2008-03-28
 Igor Pavlov
 Public domain */
@@ -19,7 +19,7 @@
     p->data = 0;
     return 1;
   }
-  p->data = (Byte *)alloc->Alloc(alloc, size);
+  p->data = (SZByte *)alloc->Alloc(alloc, size);
   if (p->data != 0)
   {
     p->size = size;
diff -u -d -b -w -r libclamav/7z/7zBuf.h libclamav/7z/7zBuf.h
--- libclamav/7z/7zBuf.h	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/7zBuf.h	2013-09-25 11:40:55.000000000 -0400
@@ -1,4 +1,4 @@
-/* 7zBuf.h -- Byte Buffer
+/* 7zBuf.h -- SZByte Buffer
 2009-02-07 : Igor Pavlov : Public domain */
 
 #ifndef __7Z_BUF_H
@@ -12,7 +12,7 @@
 
 typedef struct
 {
-  Byte *data;
+  SZByte *data;
   size_t size;
 } CBuf;
 
@@ -22,14 +22,14 @@
 
 typedef struct
 {
-  Byte *data;
+  SZByte *data;
   size_t size;
   size_t pos;
 } CDynBuf;
 
 void DynBuf_Construct(CDynBuf *p);
 void DynBuf_SeekToBeg(CDynBuf *p);
-int DynBuf_Write(CDynBuf *p, const Byte *buf, size_t size, ISzAlloc *alloc);
+int DynBuf_Write(CDynBuf *p, const SZByte *buf, size_t size, ISzAlloc *alloc);
 void DynBuf_Free(CDynBuf *p, ISzAlloc *alloc);
 
 #ifdef __cplusplus
diff -u -d -b -w -r libclamav/7z/7zBuf2.c libclamav/7z/7zBuf2.c
--- libclamav/7z/7zBuf2.c	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/7zBuf2.c	2013-09-25 11:31:45.000000000 -0400
@@ -1,4 +1,4 @@
-/* 7zBuf2.c -- Byte Buffer
+/* 7zBuf2.c -- SZByte Buffer
 2008-10-04 : Igor Pavlov : Public domain */
 
 #include <string.h>
@@ -16,14 +16,14 @@
   p->pos = 0;
 }
 
-int DynBuf_Write(CDynBuf *p, const Byte *buf, size_t size, ISzAlloc *alloc)
+int DynBuf_Write(CDynBuf *p, const SZByte *buf, size_t size, ISzAlloc *alloc)
 {
   if (size > p->size - p->pos)
   {
     size_t newSize = p->pos + size;
-    Byte *data;
+    SZByte *data;
     newSize += newSize / 4;
-    data = (Byte *)alloc->Alloc(alloc, newSize);
+    data = (SZByte *)alloc->Alloc(alloc, newSize);
     if (data == 0)
       return 0;
     p->size = newSize;
diff -u -d -b -w -r libclamav/7z/7zCrc.c libclamav/7z/7zCrc.c
--- libclamav/7z/7zCrc.c	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/7zCrc.c	2013-09-25 11:31:54.000000000 -0400
@@ -11,7 +11,7 @@
 
 UInt32 MY_FAST_CALL CrcUpdate(UInt32 v, const void *data, size_t size)
 {
-  const Byte *p = (const Byte *)data;
+  const SZByte *p = (const SZByte *)data;
   for (; size > 0; size--, p++)
     v = CRC_UPDATE_BYTE_2(v, *p);
   return v;
diff -u -d -b -w -r libclamav/7z/7zDec.c libclamav/7z/7zDec.c
--- libclamav/7z/7zDec.c	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/7zDec.c	2013-09-25 11:32:51.000000000 -0400
@@ -33,16 +33,16 @@
 typedef struct
 {
   IByteIn p;
-  const Byte *cur;
-  const Byte *end;
-  const Byte *begin;
+  const SZByte *cur;
+  const SZByte *end;
+  const SZByte *begin;
   UInt64 processed;
   Bool extra;
   SRes res;
   ILookInStream *inStream;
 } CByteInToLook;
 
-static Byte ReadByte(void *pp)
+static SZByte ReadByte(void *pp)
 {
   CByteInToLook *p = (CByteInToLook *)pp;
   if (p->cur != p->end)
@@ -64,7 +64,7 @@
 }
 
 static SRes SzDecodePpmd(CSzCoderInfo *coder, UInt64 inSize, ILookInStream *inStream,
-    Byte *outBuffer, SizeT outSize, ISzAlloc *allocMain)
+    SZByte *outBuffer, SizeT outSize, ISzAlloc *allocMain)
 {
   CPpmd7 ppmd;
   CByteInToLook s;
@@ -109,7 +109,7 @@
         int sym = Ppmd7_DecodeSymbol(&ppmd, &rc.p);
         if (s.extra || sym < 0)
           break;
-        outBuffer[i] = (Byte)sym;
+        outBuffer[i] = (SZByte)sym;
       }
       if (i != outSize)
         res = (s.res != SZ_OK ? s.res : SZ_ERROR_DATA);
@@ -125,7 +125,7 @@
 
 
 static SRes SzDecodeLzma(CSzCoderInfo *coder, UInt64 inSize, ILookInStream *inStream,
-    Byte *outBuffer, SizeT outSize, ISzAlloc *allocMain)
+    SZByte *outBuffer, SizeT outSize, ISzAlloc *allocMain)
 {
   CLzmaDec state;
   SRes res = SZ_OK;
@@ -138,7 +138,7 @@
 
   for (;;)
   {
-    Byte *inBuf = NULL;
+    SZByte *inBuf = NULL;
     size_t lookahead = (1 << 18);
     if (lookahead > inSize)
       lookahead = (size_t)inSize;
@@ -173,7 +173,7 @@
 }
 
 static SRes SzDecodeLzma2(CSzCoderInfo *coder, UInt64 inSize, ILookInStream *inStream,
-    Byte *outBuffer, SizeT outSize, ISzAlloc *allocMain)
+    SZByte *outBuffer, SizeT outSize, ISzAlloc *allocMain)
 {
   CLzma2Dec state;
   SRes res = SZ_OK;
@@ -188,7 +188,7 @@
 
   for (;;)
   {
-    Byte *inBuf = NULL;
+    SZByte *inBuf = NULL;
     size_t lookahead = (1 << 18);
     if (lookahead > inSize)
       lookahead = (size_t)inSize;
@@ -221,7 +221,7 @@
   return res;
 }
 
-static SRes SzDecodeCopy(UInt64 inSize, ILookInStream *inStream, Byte *outBuffer)
+static SRes SzDecodeCopy(UInt64 inSize, ILookInStream *inStream, SZByte *outBuffer)
 {
   while (inSize > 0)
   {
@@ -338,13 +338,13 @@
 
 static SRes SzFolder_Decode2(const CSzFolder *folder, const UInt64 *packSizes,
     ILookInStream *inStream, UInt64 startPos,
-    Byte *outBuffer, SizeT outSize, ISzAlloc *allocMain,
-    Byte *tempBuf[])
+    SZByte *outBuffer, SizeT outSize, ISzAlloc *allocMain,
+    SZByte *tempBuf[])
 {
   UInt32 ci;
   SizeT tempSizes[3] = { 0, 0, 0};
   SizeT tempSize3 = 0;
-  Byte *tempBuf3 = 0;
+  SZByte *tempBuf3 = 0;
 
   RINOK(CheckSupportedFolder(folder));
 
@@ -357,7 +357,7 @@
       UInt32 si = 0;
       UInt64 offset;
       UInt64 inSize;
-      Byte *outBufCur = outBuffer;
+      SZByte *outBufCur = outBuffer;
       SizeT outSizeCur = outSize;
       if (folder->NumCoders == 4)
       {
@@ -366,11 +366,11 @@
         si = indices[ci];
         if (ci < 2)
         {
-          Byte *temp;
+          SZByte *temp;
           outSizeCur = (SizeT)unpackSize;
           if (outSizeCur != unpackSize)
             return SZ_ERROR_MEM;
-          temp = (Byte *)IAlloc_Alloc(allocMain, outSizeCur);
+          temp = (SZByte *)IAlloc_Alloc(allocMain, outSizeCur);
           if (temp == 0 && outSizeCur != 0)
             return SZ_ERROR_MEM;
           outBufCur = tempBuf[1 - ci] = temp;
@@ -424,7 +424,7 @@
       tempSizes[2] = (SizeT)s3Size;
       if (tempSizes[2] != s3Size)
         return SZ_ERROR_MEM;
-      tempBuf[2] = (Byte *)IAlloc_Alloc(allocMain, tempSizes[2]);
+      tempBuf[2] = (SZByte *)IAlloc_Alloc(allocMain, tempSizes[2]);
       if (tempBuf[2] == 0 && tempSizes[2] != 0)
         return SZ_ERROR_MEM;
       res = SzDecodeCopy(s3Size, inStream, tempBuf[2]);
@@ -462,9 +462,9 @@
 
 SRes SzFolder_Decode(const CSzFolder *folder, const UInt64 *packSizes,
     ILookInStream *inStream, UInt64 startPos,
-    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain)
+    SZByte *outBuffer, size_t outSize, ISzAlloc *allocMain)
 {
-  Byte *tempBuf[3] = { 0, 0, 0};
+  SZByte *tempBuf[3] = { 0, 0, 0};
   int i;
   SRes res = SzFolder_Decode2(folder, packSizes, inStream, startPos,
       outBuffer, (SizeT)outSize, allocMain, tempBuf);
diff -u -d -b -w -r libclamav/7z/7zFile.c libclamav/7z/7zFile.c
--- libclamav/7z/7zFile.c	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/7zFile.c	2013-09-25 11:33:00.000000000 -0400
@@ -108,7 +108,7 @@
     DWORD curSize = (originalSize > kChunkSizeMax) ? kChunkSizeMax : (DWORD)originalSize;
     DWORD processed = 0;
     BOOL res = ReadFile(p->handle, data, curSize, &processed, NULL);
-    data = (void *)((Byte *)data + processed);
+    data = (void *)((SZByte *)data + processed);
     originalSize -= processed;
     *size += processed;
     if (!res)
@@ -143,7 +143,7 @@
     DWORD curSize = (originalSize > kChunkSizeMax) ? kChunkSizeMax : (DWORD)originalSize;
     DWORD processed = 0;
     BOOL res = WriteFile(p->handle, data, curSize, &processed, NULL);
-    data = (void *)((Byte *)data + processed);
+    data = (void *)((SZByte *)data + processed);
     originalSize -= processed;
     *size += processed;
     if (!res)
diff -u -d -b -w -r libclamav/7z/7zIn.c libclamav/7z/7zIn.c
--- libclamav/7z/7zIn.c	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/7zIn.c	2013-09-25 11:35:29.000000000 -0400
@@ -7,7 +7,7 @@
 #include "7zCrc.h"
 #include "CpuArch.h"
 
-Byte k7zSignature[k7zSignatureSize] = {'7', 'z', 0xBC, 0xAF, 0x27, 0x1C};
+SZByte k7zSignature[k7zSignatureSize] = {'7', 'z', 0xBC, 0xAF, 0x27, 0x1C};
 
 #define RINOM(x) { if ((x) == 0) return SZ_ERROR_MEM; }
 
@@ -298,7 +298,7 @@
 }
 */
 
-static int TestSignatureCandidate(Byte *testBytes)
+static int TestSignatureCandidate(SZByte *testBytes)
 {
   size_t i;
   for (i = 0; i < k7zSignatureSize; i++)
@@ -309,11 +309,11 @@
 
 typedef struct _CSzState
 {
-  Byte *Data;
+  SZByte *Data;
   size_t Size;
 }CSzData;
 
-static SRes SzReadByte(CSzData *sd, Byte *b)
+static SRes SzReadByte(CSzData *sd, SZByte *b)
 {
   if (sd->Size == 0)
     return SZ_ERROR_ARCHIVE;
@@ -322,7 +322,7 @@
   return SZ_OK;
 }
 
-static SRes SzReadBytes(CSzData *sd, Byte *data, size_t size)
+static SRes SzReadBytes(CSzData *sd, SZByte *data, size_t size)
 {
   size_t i;
   for (i = 0; i < size; i++)
@@ -338,7 +338,7 @@
   *value = 0;
   for (i = 0; i < 4; i++)
   {
-    Byte b;
+    SZByte b;
     RINOK(SzReadByte(sd, &b));
     *value |= ((UInt32)(b) << (8 * i));
   }
@@ -347,14 +347,14 @@
 
 static SRes SzReadNumber(CSzData *sd, UInt64 *value)
 {
-  Byte firstByte;
-  Byte mask = 0x80;
+  SZByte firstByte;
+  SZByte mask = 0x80;
   int i;
   RINOK(SzReadByte(sd, &firstByte));
   *value = 0;
   for (i = 0; i < 8; i++)
   {
-    Byte b;
+    SZByte b;
     if ((firstByte & mask) == 0)
     {
       UInt64 highPart = firstByte & (mask - 1);
@@ -428,12 +428,12 @@
   }
 }
 
-static SRes SzReadBoolVector(CSzData *sd, size_t numItems, Byte **v, ISzAlloc *alloc)
+static SRes SzReadBoolVector(CSzData *sd, size_t numItems, SZByte **v, ISzAlloc *alloc)
 {
-  Byte b = 0;
-  Byte mask = 0;
+  SZByte b = 0;
+  SZByte mask = 0;
   size_t i;
-  MY_ALLOC(Byte, *v, numItems, alloc);
+  MY_ALLOC(SZByte, *v, numItems, alloc);
   for (i = 0; i < numItems; i++)
   {
     if (mask == 0)
@@ -441,20 +441,20 @@
       RINOK(SzReadByte(sd, &b));
       mask = 0x80;
     }
-    (*v)[i] = (Byte)(((b & mask) != 0) ? 1 : 0);
+    (*v)[i] = (SZByte)(((b & mask) != 0) ? 1 : 0);
     mask >>= 1;
   }
   return SZ_OK;
 }
 
-static SRes SzReadBoolVector2(CSzData *sd, size_t numItems, Byte **v, ISzAlloc *alloc)
+static SRes SzReadBoolVector2(CSzData *sd, size_t numItems, SZByte **v, ISzAlloc *alloc)
 {
-  Byte allAreDefined;
+  SZByte allAreDefined;
   size_t i;
   RINOK(SzReadByte(sd, &allAreDefined));
   if (allAreDefined == 0)
     return SzReadBoolVector(sd, numItems, v, alloc);
-  MY_ALLOC(Byte, *v, numItems, alloc);
+  MY_ALLOC(SZByte, *v, numItems, alloc);
   for (i = 0; i < numItems; i++)
     (*v)[i] = 1;
   return SZ_OK;
@@ -463,7 +463,7 @@
 static SRes SzReadHashDigests(
     CSzData *sd,
     size_t numItems,
-    Byte **digestsDefined,
+    SZByte **digestsDefined,
     UInt32 **digests,
     ISzAlloc *alloc)
 {
@@ -483,7 +483,7 @@
     UInt64 *dataOffset,
     UInt32 *numPackStreams,
     UInt64 **packSizes,
-    Byte **packCRCsDefined,
+    SZByte **packCRCsDefined,
     UInt32 **packCRCs,
     ISzAlloc *alloc)
 {
@@ -515,7 +515,7 @@
   }
   if (*packCRCsDefined == 0)
   {
-    MY_ALLOC(Byte, *packCRCsDefined, (size_t)*numPackStreams, alloc);
+    MY_ALLOC(SZByte, *packCRCsDefined, (size_t)*numPackStreams, alloc);
     MY_ALLOC(UInt32, *packCRCs, (size_t)*numPackStreams, alloc);
     for (i = 0; i < *numPackStreams; i++)
     {
@@ -528,7 +528,7 @@
 
 static SRes SzReadSwitch(CSzData *sd)
 {
-  Byte external;
+  SZByte external;
   RINOK(SzReadByte(sd, &external));
   return (external == 0) ? SZ_OK: SZ_ERROR_UNSUPPORTED;
 }
@@ -550,11 +550,11 @@
 
   for (i = 0; i < numCoders; i++)
   {
-    Byte mainByte;
+    SZByte mainByte;
     CSzCoderInfo *coder = folder->Coders + i;
     {
       unsigned idSize, j;
-      Byte longID[15];
+      SZByte longID[15];
       RINOK(SzReadByte(sd, &mainByte));
       idSize = (unsigned)(mainByte & 0xF);
       RINOK(SzReadBytes(sd, longID, idSize));
@@ -692,7 +692,7 @@
     if (type == k7zIdCRC)
     {
       SRes res;
-      Byte *crcsDefined = 0;
+      SZByte *crcsDefined = 0;
       UInt32 *crcs = 0;
       res = SzReadHashDigests(sd, *numFolders, &crcsDefined, &crcs, allocTemp);
       if (res == SZ_OK)
@@ -719,7 +719,7 @@
     CSzFolder *folders,
     UInt32 *numUnpackStreams,
     UInt64 **unpackSizes,
-    Byte **digestsDefined,
+    SZByte **digestsDefined,
     UInt32 **digests,
     ISzAlloc *allocTemp)
 {
@@ -764,7 +764,7 @@
   {
     *unpackSizes = (UInt64 *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(UInt64));
     RINOM(*unpackSizes);
-    *digestsDefined = (Byte *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(Byte));
+    *digestsDefined = (SZByte *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(SZByte));
     RINOM(*digestsDefined);
     *digests = (UInt32 *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(UInt32));
     RINOM(*digests);
@@ -817,7 +817,7 @@
     if (type == k7zIdCRC)
     {
       int digestIndex = 0;
-      Byte *digestsDefined2 = 0;
+      SZByte *digestsDefined2 = 0;
       UInt32 *digests2 = 0;
       SRes res = SzReadHashDigests(sd, numDigests, &digestsDefined2, &digests2, allocTemp);
       if (res == SZ_OK)
@@ -865,7 +865,7 @@
     CSzAr *p,
     UInt32 *numUnpackStreams,
     UInt64 **unpackSizes, /* allocTemp */
-    Byte **digestsDefined,   /* allocTemp */
+    SZByte **digestsDefined,   /* allocTemp */
     UInt32 **digests,        /* allocTemp */
     ISzAlloc *alloc,
     ISzAlloc *allocTemp)
@@ -909,14 +909,14 @@
   if (dest != 0)
   {
     size_t i;
-    const Byte *src = p->FileNames.data + (p->FileNameOffsets[fileIndex] * 2);
+    const SZByte *src = p->FileNames.data + (p->FileNameOffsets[fileIndex] * 2);
     for (i = 0; i < len; i++)
       dest[i] = GetUi16(src + i * 2);
   }
   return len;
 }
 
-static SRes SzReadFileNames(const Byte *p, size_t size, UInt32 numFiles, size_t *sizes)
+static SRes SzReadFileNames(const SZByte *p, size_t size, UInt32 numFiles, size_t *sizes)
 {
   UInt32 i;
   size_t pos = 0;
@@ -941,11 +941,11 @@
     CSzArEx *p,   /* allocMain */
     CSzData *sd,
     UInt64 **unpackSizes,  /* allocTemp */
-    Byte **digestsDefined,    /* allocTemp */
+    SZByte **digestsDefined,    /* allocTemp */
     UInt32 **digests,         /* allocTemp */
-    Byte **emptyStreamVector, /* allocTemp */
-    Byte **emptyFileVector,   /* allocTemp */
-    Byte **lwtVector,         /* allocTemp */
+    SZByte **emptyStreamVector, /* allocTemp */
+    SZByte **emptyFileVector,   /* allocTemp */
+    SZByte **lwtVector,         /* allocTemp */
     ISzAlloc *allocMain,
     ISzAlloc *allocTemp)
 {
@@ -1045,7 +1045,7 @@
         for (i = 0; i < numFiles; i++)
         {
           CSzFileItem *f = &files[i];
-          Byte defined = (*lwtVector)[i];
+          SZByte defined = (*lwtVector)[i];
           f->AttribDefined = defined;
           f->Attrib = 0;
           if (defined)
@@ -1064,7 +1064,7 @@
         for (i = 0; i < numFiles; i++)
         {
           CSzFileItem *f = &files[i];
-          Byte defined = (*lwtVector)[i];
+          SZByte defined = (*lwtVector)[i];
           f->MTimeDefined = defined;
           f->MTime.Low = f->MTime.High = 0;
           if (defined)
@@ -1094,13 +1094,13 @@
       if (*emptyStreamVector == 0)
         file->HasStream = 1;
       else
-        file->HasStream = (Byte)((*emptyStreamVector)[i] ? 0 : 1);
+        file->HasStream = (SZByte)((*emptyStreamVector)[i] ? 0 : 1);
       if (file->HasStream)
       {
         file->IsDir = 0;
         file->Size = (*unpackSizes)[sizeIndex];
         file->Crc = (*digests)[sizeIndex];
-        file->CrcDefined = (Byte)(*digestsDefined)[sizeIndex];
+        file->CrcDefined = (SZByte)(*digestsDefined)[sizeIndex];
         sizeIndex++;
       }
       else
@@ -1108,7 +1108,7 @@
         if (*emptyFileVector == 0)
           file->IsDir = 1;
         else
-          file->IsDir = (Byte)((*emptyFileVector)[emptyFileIndex] ? 0 : 1);
+          file->IsDir = (SZByte)((*emptyFileVector)[emptyFileIndex] ? 0 : 1);
         emptyFileIndex++;
         file->Size = 0;
         file->Crc = 0;
@@ -1126,11 +1126,11 @@
     ISzAlloc *allocTemp)
 {
   UInt64 *unpackSizes = 0;
-  Byte *digestsDefined = 0;
+  SZByte *digestsDefined = 0;
   UInt32 *digests = 0;
-  Byte *emptyStreamVector = 0;
-  Byte *emptyFileVector = 0;
-  Byte *lwtVector = 0;
+  SZByte *emptyStreamVector = 0;
+  SZByte *emptyFileVector = 0;
+  SZByte *lwtVector = 0;
   SRes res = SzReadHeader2(p, sd,
       &unpackSizes, &digestsDefined, &digests,
       &emptyStreamVector, &emptyFileVector, &lwtVector,
@@ -1151,7 +1151,7 @@
     UInt64 baseOffset,
     CSzAr *p,
     UInt64 **unpackSizes,
-    Byte **digestsDefined,
+    SZByte **digestsDefined,
     UInt32 **digests,
     ISzAlloc *allocTemp)
 {
@@ -1197,7 +1197,7 @@
 {
   CSzAr p;
   UInt64 *unpackSizes = 0;
-  Byte *digestsDefined = 0;
+  SZByte *digestsDefined = 0;
   UInt32 *digests = 0;
   SRes res;
   SzAr_Init(&p);
@@ -1217,7 +1217,7 @@
     ISzAlloc *allocMain,
     ISzAlloc *allocTemp)
 {
-  Byte header[k7zStartHeaderSize];
+  SZByte header[k7zStartHeaderSize];
   Int64 startArcPos;
   UInt64 nextHeaderOffset, nextHeaderSize;
   size_t nextHeaderSizeT;
@@ -1246,7 +1246,7 @@
     return SZ_ERROR_CRC; */
   if(!GetUi32(header + 8) && !nextHeaderOffset && !nextHeaderSize && !nextHeaderCRC) {
     int i, checkSize = 500;
-    Byte buf[500];
+    SZByte buf[500];
     Int64 curpos=0, endpos=0, readpos;
     RINOK(inStream->Seek(inStream, &curpos, SZ_SEEK_CUR));
     RINOK(inStream->Seek(inStream, &endpos, SZ_SEEK_END));
@@ -1349,7 +1349,7 @@
     ILookInStream *inStream,
     UInt32 fileIndex,
     UInt32 *blockIndex,
-    Byte **outBuffer,
+    SZByte **outBuffer,
     size_t *outBufferSize,
     size_t *offset,
     size_t *outSizeProcessed,
@@ -1389,7 +1389,7 @@
       *outBufferSize = unpackSize;
       if (unpackSize != 0)
       {
-        *outBuffer = (Byte *)IAlloc_Alloc(allocMain, unpackSize);
+        *outBuffer = (SZByte *)IAlloc_Alloc(allocMain, unpackSize);
         if (*outBuffer == 0)
           res = SZ_ERROR_MEM;
       }
diff -u -d -b -w -r libclamav/7z/7zStream.c libclamav/7z/7zStream.c
--- libclamav/7z/7zStream.c	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/7zStream.c	2013-09-25 11:35:41.000000000 -0400
@@ -13,7 +13,7 @@
     RINOK(stream->Read(stream, buf, &processed));
     if (processed == 0)
       return errorType;
-    buf = (void *)((Byte *)buf + processed);
+    buf = (void *)((SZByte *)buf + processed);
     size -= processed;
   }
   return SZ_OK;
@@ -24,7 +24,7 @@
   return SeqInStream_Read2(stream, buf, size, SZ_ERROR_INPUT_EOF);
 }
 
-SRes SeqInStream_ReadByte(ISeqInStream *stream, Byte *buf)
+SRes SeqInStream_ReadByte(ISeqInStream *stream, SZByte *buf)
 {
   size_t processed = 1;
   RINOK(stream->Read(stream, buf, &processed));
@@ -55,7 +55,7 @@
     RINOK(stream->Read(stream, buf, &processed));
     if (processed == 0)
       return errorType;
-    buf = (void *)((Byte *)buf + processed);
+    buf = (void *)((SZByte *)buf + processed);
     size -= processed;
   }
   return SZ_OK;
diff -u -d -b -w -r libclamav/7z/Bcj2.c libclamav/7z/Bcj2.c
--- libclamav/7z/Bcj2.c	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/Bcj2.c	2013-09-25 11:36:14.000000000 -0400
@@ -31,18 +31,18 @@
 #define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CProb)(ttt - (ttt >> kNumMoveBits)); NORMALIZE;
 
 int Bcj2_Decode(
-    const Byte *buf0, SizeT size0,
-    const Byte *buf1, SizeT size1,
-    const Byte *buf2, SizeT size2,
-    const Byte *buf3, SizeT size3,
-    Byte *outBuf, SizeT outSize)
+    const SZByte *buf0, SizeT size0,
+    const SZByte *buf1, SizeT size1,
+    const SZByte *buf2, SizeT size2,
+    const SZByte *buf3, SizeT size3,
+    SZByte *outBuf, SizeT outSize)
 {
   CProb p[256 + 2];
   SizeT inPos = 0, outPos = 0;
 
-  const Byte *buffer, *bufferLim;
+  const SZByte *buffer, *bufferLim;
   UInt32 range, code;
-  Byte prevByte = 0;
+  SZByte prevByte = 0;
 
   unsigned int i;
   for (i = 0; i < sizeof(p) / sizeof(p[0]); i++)
@@ -57,7 +57,7 @@
 
   for (;;)
   {
-    Byte b;
+    SZByte b;
     CProb *prob;
     UInt32 bound;
     UInt32 ttt;
@@ -67,7 +67,7 @@
       limit = outSize - outPos;
     while (limit != 0)
     {
-      Byte b = buf0[inPos];
+      SZByte b = buf0[inPos];
       outBuf[outPos++] = b;
       if (IsJ(prevByte, b))
         break;
@@ -96,7 +96,7 @@
     else
     {
       UInt32 dest;
-      const Byte *v;
+      const SZByte *v;
       UPDATE_1(prob)
       if (b == 0xE8)
       {
@@ -116,16 +116,16 @@
       }
       dest = (((UInt32)v[0] << 24) | ((UInt32)v[1] << 16) |
           ((UInt32)v[2] << 8) | ((UInt32)v[3])) - ((UInt32)outPos + 4);
-      outBuf[outPos++] = (Byte)dest;
+      outBuf[outPos++] = (SZByte)dest;
       if (outPos == outSize)
         break;
-      outBuf[outPos++] = (Byte)(dest >> 8);
+      outBuf[outPos++] = (SZByte)(dest >> 8);
       if (outPos == outSize)
         break;
-      outBuf[outPos++] = (Byte)(dest >> 16);
+      outBuf[outPos++] = (SZByte)(dest >> 16);
       if (outPos == outSize)
         break;
-      outBuf[outPos++] = prevByte = (Byte)(dest >> 24);
+      outBuf[outPos++] = prevByte = (SZByte)(dest >> 24);
     }
   }
   return (outPos == outSize) ? SZ_OK : SZ_ERROR_DATA;
diff -u -d -b -w -r libclamav/7z/Bcj2.h libclamav/7z/Bcj2.h
--- libclamav/7z/Bcj2.h	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/Bcj2.h	2013-09-25 11:41:10.000000000 -0400
@@ -25,11 +25,11 @@
 */
 
 int Bcj2_Decode(
-    const Byte *buf0, SizeT size0,
-    const Byte *buf1, SizeT size1,
-    const Byte *buf2, SizeT size2,
-    const Byte *buf3, SizeT size3,
-    Byte *outBuf, SizeT outSize);
+    const SZByte *buf0, SizeT size0,
+    const SZByte *buf1, SizeT size1,
+    const SZByte *buf2, SizeT size2,
+    const SZByte *buf3, SizeT size3,
+    SZByte *outBuf, SizeT outSize);
 
 #ifdef __cplusplus
 }
diff -u -d -b -w -r libclamav/7z/Bra.c libclamav/7z/Bra.c
--- libclamav/7z/Bra.c	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/Bra.c	2013-09-25 11:36:49.000000000 -0400
@@ -3,7 +3,7 @@
 
 #include "Bra.h"
 
-SizeT ARM_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+SizeT ARM_Convert(SZByte *data, SizeT size, UInt32 ip, int encoding)
 {
   SizeT i;
   if (size < 4)
@@ -22,15 +22,15 @@
       else
         dest = src - (ip + (UInt32)i);
       dest >>= 2;
-      data[i + 2] = (Byte)(dest >> 16);
-      data[i + 1] = (Byte)(dest >> 8);
-      data[i + 0] = (Byte)dest;
+      data[i + 2] = (SZByte)(dest >> 16);
+      data[i + 1] = (SZByte)(dest >> 8);
+      data[i + 0] = (SZByte)dest;
     }
   }
   return i;
 }
 
-SizeT ARMT_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+SizeT ARMT_Convert(SZByte *data, SizeT size, UInt32 ip, int encoding)
 {
   SizeT i;
   if (size < 4)
@@ -56,17 +56,17 @@
         dest = src - (ip + (UInt32)i);
       dest >>= 1;
       
-      data[i + 1] = (Byte)(0xF0 | ((dest >> 19) & 0x7));
-      data[i + 0] = (Byte)(dest >> 11);
-      data[i + 3] = (Byte)(0xF8 | ((dest >> 8) & 0x7));
-      data[i + 2] = (Byte)dest;
+      data[i + 1] = (SZByte)(0xF0 | ((dest >> 19) & 0x7));
+      data[i + 0] = (SZByte)(dest >> 11);
+      data[i + 3] = (SZByte)(0xF8 | ((dest >> 8) & 0x7));
+      data[i + 2] = (SZByte)dest;
       i += 2;
     }
   }
   return i;
 }
 
-SizeT PPC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+SizeT PPC_Convert(SZByte *data, SizeT size, UInt32 ip, int encoding)
 {
   SizeT i;
   if (size < 4)
@@ -86,9 +86,9 @@
         dest = ip + (UInt32)i + src;
       else
         dest = src - (ip + (UInt32)i);
-      data[i + 0] = (Byte)(0x48 | ((dest >> 24) &  0x3));
-      data[i + 1] = (Byte)(dest >> 16);
-      data[i + 2] = (Byte)(dest >> 8);
+      data[i + 0] = (SZByte)(0x48 | ((dest >> 24) &  0x3));
+      data[i + 1] = (SZByte)(dest >> 16);
+      data[i + 2] = (SZByte)(dest >> 8);
       data[i + 3] &= 0x3;
       data[i + 3] |= dest;
     }
@@ -96,7 +96,7 @@
   return i;
 }
 
-SizeT SPARC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+SizeT SPARC_Convert(SZByte *data, SizeT size, UInt32 ip, int encoding)
 {
   UInt32 i;
   if (size < 4)
@@ -123,10 +123,10 @@
       
       dest = (((0 - ((dest >> 22) & 1)) << 22) & 0x3FFFFFFF) | (dest & 0x3FFFFF) | 0x40000000;
 
-      data[i + 0] = (Byte)(dest >> 24);
-      data[i + 1] = (Byte)(dest >> 16);
-      data[i + 2] = (Byte)(dest >> 8);
-      data[i + 3] = (Byte)dest;
+      data[i + 0] = (SZByte)(dest >> 24);
+      data[i + 1] = (SZByte)(dest >> 16);
+      data[i + 2] = (SZByte)(dest >> 8);
+      data[i + 3] = (SZByte)dest;
     }
   }
   return i;
diff -u -d -b -w -r libclamav/7z/Bra.h libclamav/7z/Bra.h
--- libclamav/7z/Bra.h	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/Bra.h	2013-09-25 11:41:21.000000000 -0400
@@ -54,12 +54,12 @@
 */
 
 #define x86_Convert_Init(state) { state = 0; }
-SizeT x86_Convert(Byte *data, SizeT size, UInt32 ip, UInt32 *state, int encoding);
-SizeT ARM_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
-SizeT ARMT_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
-SizeT PPC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
-SizeT SPARC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
-SizeT IA64_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
+SizeT x86_Convert(SZByte *data, SizeT size, UInt32 ip, UInt32 *state, int encoding);
+SizeT ARM_Convert(SZByte *data, SizeT size, UInt32 ip, int encoding);
+SizeT ARMT_Convert(SZByte *data, SizeT size, UInt32 ip, int encoding);
+SizeT PPC_Convert(SZByte *data, SizeT size, UInt32 ip, int encoding);
+SizeT SPARC_Convert(SZByte *data, SizeT size, UInt32 ip, int encoding);
+SizeT IA64_Convert(SZByte *data, SizeT size, UInt32 ip, int encoding);
 
 #ifdef __cplusplus
 }
diff -u -d -b -w -r libclamav/7z/Bra86.c libclamav/7z/Bra86.c
--- libclamav/7z/Bra86.c	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/Bra86.c	2013-09-25 11:37:14.000000000 -0400
@@ -5,10 +5,10 @@
 
 #define Test86MSByte(b) ((b) == 0 || (b) == 0xFF)
 
-const Byte kMaskToAllowedStatus[8] = {1, 1, 1, 0, 1, 0, 0, 0};
-const Byte kMaskToBitNumber[8] = {0, 1, 2, 2, 3, 3, 3, 3};
+const SZByte kMaskToAllowedStatus[8] = {1, 1, 1, 0, 1, 0, 0, 0};
+const SZByte kMaskToBitNumber[8] = {0, 1, 2, 2, 3, 3, 3, 3};
 
-SizeT x86_Convert(Byte *data, SizeT size, UInt32 ip, UInt32 *state, int encoding)
+SizeT x86_Convert(SZByte *data, SizeT size, UInt32 ip, UInt32 *state, int encoding)
 {
   SizeT bufferPos = 0, prevPosT;
   UInt32 prevMask = *state & 0x7;
@@ -19,8 +19,8 @@
 
   for (;;)
   {
-    Byte *p = data + bufferPos;
-    Byte *limit = data + size - 4;
+    SZByte *p = data + bufferPos;
+    SZByte *limit = data + size - 4;
     for (; p < limit; p++)
       if ((*p & 0xFE) == 0xE8)
         break;
@@ -35,7 +35,7 @@
       prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;
       if (prevMask != 0)
       {
-        Byte b = p[4 - kMaskToBitNumber[prevMask]];
+        SZByte b = p[4 - kMaskToBitNumber[prevMask]];
         if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))
         {
           prevPosT = bufferPos;
@@ -53,7 +53,7 @@
       UInt32 dest;
       for (;;)
       {
-        Byte b;
+        SZByte b;
         int index;
         if (encoding)
           dest = (ip + (UInt32)bufferPos) + src;
@@ -62,15 +62,15 @@
         if (prevMask == 0)
           break;
         index = kMaskToBitNumber[prevMask] * 8;
-        b = (Byte)(dest >> (24 - index));
+        b = (SZByte)(dest >> (24 - index));
         if (!Test86MSByte(b))
           break;
         src = dest ^ ((1 << (32 - index)) - 1);
       }
-      p[4] = (Byte)(~(((dest >> 24) & 1) - 1));
-      p[3] = (Byte)(dest >> 16);
-      p[2] = (Byte)(dest >> 8);
-      p[1] = (Byte)dest;
+      p[4] = (SZByte)(~(((dest >> 24) & 1) - 1));
+      p[3] = (SZByte)(dest >> 16);
+      p[2] = (SZByte)(dest >> 8);
+      p[1] = (SZByte)dest;
       bufferPos += 5;
     }
     else
diff -u -d -b -w -r libclamav/7z/CpuArch.h libclamav/7z/CpuArch.h
--- libclamav/7z/CpuArch.h	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/CpuArch.h	2013-09-25 11:41:32.000000000 -0400
@@ -20,17 +20,17 @@
 #define GetUi16(p) (cli_readint16(p))
 #define GetUi32(p) (cli_readint32(p))
 
-#define GetUi64(p) (GetUi32(p) | ((UInt64)GetUi32(((const Byte *)(p)) + 4) << 32))
+#define GetUi64(p) (GetUi32(p) | ((UInt64)GetUi32(((const SZByte *)(p)) + 4) << 32))
 
 #define SetUi16(p, d) { UInt32 _x_ = (d); \
-    ((Byte *)(p))[0] = (Byte)_x_; \
-    ((Byte *)(p))[1] = (Byte)(_x_ >> 8); }
+    ((SZByte *)(p))[0] = (SZByte)_x_; \
+    ((SZByte *)(p))[1] = (SZByte)(_x_ >> 8); }
 
 #define SetUi32(p, d) (cli_writeint32(p, d))
 
 #define SetUi64(p, d) { UInt64 _x64_ = (d); \
     SetUi32(p, (UInt32)_x64_); \
-    SetUi32(((Byte *)(p)) + 4, (UInt32)(_x64_ >> 32)); }
+    SetUi32(((SZByte *)(p)) + 4, (UInt32)(_x64_ >> 32)); }
 
 EXTERN_C_END
 
diff -u -d -b -w -r libclamav/7z/Lzma2Dec.c libclamav/7z/Lzma2Dec.c
--- libclamav/7z/Lzma2Dec.c	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/Lzma2Dec.c	2013-09-25 11:38:00.000000000 -0400
@@ -58,30 +58,30 @@
   LZMA2_STATE_ERROR
 } ELzma2State;
 
-static SRes Lzma2Dec_GetOldProps(Byte prop, Byte *props)
+static SRes Lzma2Dec_GetOldProps(SZByte prop, SZByte *props)
 {
   UInt32 dicSize;
   if (prop > 40)
     return SZ_ERROR_UNSUPPORTED;
   dicSize = (prop == 40) ? 0xFFFFFFFF : LZMA2_DIC_SIZE_FROM_PROP(prop);
-  props[0] = (Byte)LZMA2_LCLP_MAX;
-  props[1] = (Byte)(dicSize);
-  props[2] = (Byte)(dicSize >> 8);
-  props[3] = (Byte)(dicSize >> 16);
-  props[4] = (Byte)(dicSize >> 24);
+  props[0] = (SZByte)LZMA2_LCLP_MAX;
+  props[1] = (SZByte)(dicSize);
+  props[2] = (SZByte)(dicSize >> 8);
+  props[3] = (SZByte)(dicSize >> 16);
+  props[4] = (SZByte)(dicSize >> 24);
   return SZ_OK;
 }
 
-SRes Lzma2Dec_AllocateProbs(CLzma2Dec *p, Byte prop, ISzAlloc *alloc)
+SRes Lzma2Dec_AllocateProbs(CLzma2Dec *p, SZByte prop, ISzAlloc *alloc)
 {
-  Byte props[LZMA_PROPS_SIZE];
+  SZByte props[LZMA_PROPS_SIZE];
   RINOK(Lzma2Dec_GetOldProps(prop, props));
   return LzmaDec_AllocateProbs(&p->decoder, props, LZMA_PROPS_SIZE, alloc);
 }
 
-SRes Lzma2Dec_Allocate(CLzma2Dec *p, Byte prop, ISzAlloc *alloc)
+SRes Lzma2Dec_Allocate(CLzma2Dec *p, SZByte prop, ISzAlloc *alloc)
 {
-  Byte props[LZMA_PROPS_SIZE];
+  SZByte props[LZMA_PROPS_SIZE];
   RINOK(Lzma2Dec_GetOldProps(prop, props));
   return LzmaDec_Allocate(&p->decoder, props, LZMA_PROPS_SIZE, alloc);
 }
@@ -95,7 +95,7 @@
   LzmaDec_Init(&p->decoder);
 }
 
-static ELzma2State Lzma2Dec_UpdateState(CLzma2Dec *p, Byte b)
+static ELzma2State Lzma2Dec_UpdateState(CLzma2Dec *p, SZByte b)
 {
   switch(p->state)
   {
@@ -156,7 +156,7 @@
   return LZMA2_STATE_ERROR;
 }
 
-static void LzmaDec_UpdateWithUncompressed(CLzmaDec *p, const Byte *src, SizeT size)
+static void LzmaDec_UpdateWithUncompressed(CLzmaDec *p, const SZByte *src, SizeT size)
 {
   memcpy(p->dic + p->dicPos, src, size);
   p->dicPos += size;
@@ -168,7 +168,7 @@
 void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState);
 
 SRes Lzma2Dec_DecodeToDic(CLzma2Dec *p, SizeT dicLimit,
-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
+    const SZByte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
 {
   SizeT inSize = *srcLen;
   *srcLen = 0;
@@ -288,7 +288,7 @@
   return SZ_OK;
 }
 
-SRes Lzma2Dec_DecodeToBuf(CLzma2Dec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
+SRes Lzma2Dec_DecodeToBuf(CLzma2Dec *p, SZByte *dest, SizeT *destLen, const SZByte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
 {
   SizeT outSize = *destLen, inSize = *srcLen;
   *srcLen = *destLen = 0;
@@ -327,13 +327,13 @@
   }
 }
 
-SRes Lzma2Decode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-    Byte prop, ELzmaFinishMode finishMode, ELzmaStatus *status, ISzAlloc *alloc)
+SRes Lzma2Decode(SZByte *dest, SizeT *destLen, const SZByte *src, SizeT *srcLen,
+    SZByte prop, ELzmaFinishMode finishMode, ELzmaStatus *status, ISzAlloc *alloc)
 {
   CLzma2Dec decoder;
   SRes res;
   SizeT outSize = *destLen, inSize = *srcLen;
-  Byte props[LZMA_PROPS_SIZE];
+  SZByte props[LZMA_PROPS_SIZE];
 
   Lzma2Dec_Construct(&decoder);
 
diff -u -d -b -w -r libclamav/7z/Lzma2Dec.h libclamav/7z/Lzma2Dec.h
--- libclamav/7z/Lzma2Dec.h	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/Lzma2Dec.h	2013-09-25 11:41:52.000000000 -0400
@@ -18,7 +18,7 @@
   UInt32 packSize;
   UInt32 unpackSize;
   int state;
-  Byte control;
+  SZByte control;
   Bool needInitDic;
   Bool needInitState;
   Bool needInitProp;
@@ -28,8 +28,8 @@
 #define Lzma2Dec_FreeProbs(p, alloc) LzmaDec_FreeProbs(&(p)->decoder, alloc);
 #define Lzma2Dec_Free(p, alloc) LzmaDec_Free(&(p)->decoder, alloc);
 
-SRes Lzma2Dec_AllocateProbs(CLzma2Dec *p, Byte prop, ISzAlloc *alloc);
-SRes Lzma2Dec_Allocate(CLzma2Dec *p, Byte prop, ISzAlloc *alloc);
+SRes Lzma2Dec_AllocateProbs(CLzma2Dec *p, SZByte prop, ISzAlloc *alloc);
+SRes Lzma2Dec_Allocate(CLzma2Dec *p, SZByte prop, ISzAlloc *alloc);
 void Lzma2Dec_Init(CLzma2Dec *p);
 
 
@@ -49,10 +49,10 @@
 */
 
 SRes Lzma2Dec_DecodeToDic(CLzma2Dec *p, SizeT dicLimit,
-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
+    const SZByte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
 
-SRes Lzma2Dec_DecodeToBuf(CLzma2Dec *p, Byte *dest, SizeT *destLen,
-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
+SRes Lzma2Dec_DecodeToBuf(CLzma2Dec *p, SZByte *dest, SizeT *destLen,
+    const SZByte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
 
 
 /* ---------- One Call Interface ---------- */
@@ -74,8 +74,8 @@
   SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
 */
 
-SRes Lzma2Decode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-    Byte prop, ELzmaFinishMode finishMode, ELzmaStatus *status, ISzAlloc *alloc);
+SRes Lzma2Decode(SZByte *dest, SizeT *destLen, const SZByte *src, SizeT *srcLen,
+    SZByte prop, ELzmaFinishMode finishMode, ELzmaStatus *status, ISzAlloc *alloc);
 
 #ifdef __cplusplus
 }
diff -u -d -b -w -r libclamav/7z/LzmaDec.c libclamav/7z/LzmaDec.c
--- libclamav/7z/LzmaDec.c	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/LzmaDec.c	2013-09-25 11:39:07.000000000 -0400
@@ -128,7 +128,7 @@
     = kMatchSpecLenStart + 2 : State Init Marker
 */
 
-static int MY_FAST_CALL LzmaDec_DecodeReal(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
+static int MY_FAST_CALL LzmaDec_DecodeReal(CLzmaDec *p, SizeT limit, const SZByte *bufLimit)
 {
   CLzmaProb *probs = p->probs;
 
@@ -138,7 +138,7 @@
   unsigned lpMask = ((unsigned)1 << (p->prop.lp)) - 1;
   unsigned lc = p->prop.lc;
 
-  Byte *dic = p->dic;
+  SZByte *dic = p->dic;
   SizeT dicBufSize = p->dicBufSize;
   SizeT dicPos = p->dicPos;
   
@@ -146,7 +146,7 @@
   UInt32 checkDicSize = p->checkDicSize;
   unsigned len = 0;
 
-  const Byte *buf = p->buf;
+  const SZByte *buf = p->buf;
   UInt32 range = p->range;
   UInt32 code = p->code;
 
@@ -190,7 +190,7 @@
         }
         while (symbol < 0x100);
       }
-      dic[dicPos++] = (Byte)symbol;
+      dic[dicPos++] = (SZByte)symbol;
       processedPos++;
       continue;
     }
@@ -387,12 +387,12 @@
         len -= curLen;
         if (pos + curLen <= dicBufSize)
         {
-          Byte *dest = dic + dicPos;
+          SZByte *dest = dic + dicPos;
           ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
-          const Byte *lim = dest + curLen;
+          const SZByte *lim = dest + curLen;
           dicPos += curLen;
           do
-            *(dest) = (Byte)*(dest + src);
+            *(dest) = (SZByte)*(dest + src);
           while (++dest != lim);
         }
         else
@@ -429,7 +429,7 @@
 {
   if (p->remainLen != 0 && p->remainLen < kMatchSpecLenStart)
   {
-    Byte *dic = p->dic;
+    SZByte *dic = p->dic;
     SizeT dicPos = p->dicPos;
     SizeT dicBufSize = p->dicBufSize;
     unsigned len = p->remainLen;
@@ -451,7 +451,7 @@
   }
 }
 
-static int MY_FAST_CALL LzmaDec_DecodeReal2(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
+static int MY_FAST_CALL LzmaDec_DecodeReal2(CLzmaDec *p, SizeT limit, const SZByte *bufLimit)
 {
   do
   {
@@ -484,11 +484,11 @@
   DUMMY_REP
 } ELzmaDummy;
 
-static ELzmaDummy LzmaDec_TryDummy(const CLzmaDec *p, const Byte *buf, SizeT inSize)
+static ELzmaDummy LzmaDec_TryDummy(const CLzmaDec *p, const SZByte *buf, SizeT inSize)
 {
   UInt32 range = p->range;
   UInt32 code = p->code;
-  const Byte *bufLimit = buf + inSize;
+  const SZByte *bufLimit = buf + inSize;
   CLzmaProb *probs = p->probs;
   unsigned state = p->state;
   ELzmaDummy res;
@@ -675,7 +675,7 @@
 }
 
 
-static void LzmaDec_InitRc(CLzmaDec *p, const Byte *data)
+static void LzmaDec_InitRc(CLzmaDec *p, const SZByte *data)
 {
   p->code = ((UInt32)data[1] << 24) | ((UInt32)data[2] << 16) | ((UInt32)data[3] << 8) | ((UInt32)data[4]);
   p->range = 0xFFFFFFFF;
@@ -716,7 +716,7 @@
   p->needInitState = 0;
 }
 
-SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
+SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const SZByte *src, SizeT *srcLen,
     ELzmaFinishMode finishMode, ELzmaStatus *status)
 {
   SizeT inSize = *srcLen;
@@ -772,7 +772,7 @@
       if (p->tempBufSize == 0)
       {
         SizeT processed;
-        const Byte *bufLimit;
+        const SZByte *bufLimit;
         if (inSize < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
         {
           int dummyRes = LzmaDec_TryDummy(p, src, inSize);
@@ -837,7 +837,7 @@
   return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
 }
 
-SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
+SRes LzmaDec_DecodeToBuf(CLzmaDec *p, SZByte *dest, SizeT *destLen, const SZByte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
 {
   SizeT outSize = *destLen;
   SizeT inSize = *srcLen;
@@ -895,10 +895,10 @@
   LzmaDec_FreeDict(p, alloc);
 }
 
-SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
+SRes LzmaProps_Decode(CLzmaProps *p, const SZByte *data, unsigned size)
 {
   UInt32 dicSize;
-  Byte d;
+  SZByte d;
   
   if (size < LZMA_PROPS_SIZE)
     return SZ_ERROR_UNSUPPORTED;
@@ -935,7 +935,7 @@
   return SZ_OK;
 }
 
-SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
+SRes LzmaDec_AllocateProbs(CLzmaDec *p, const SZByte *props, unsigned propsSize, ISzAlloc *alloc)
 {
   CLzmaProps propNew;
   RINOK(LzmaProps_Decode(&propNew, props, propsSize));
@@ -944,7 +944,7 @@
   return SZ_OK;
 }
 
-SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
+SRes LzmaDec_Allocate(CLzmaDec *p, const SZByte *props, unsigned propsSize, ISzAlloc *alloc)
 {
   CLzmaProps propNew;
   SizeT dicBufSize;
@@ -954,7 +954,7 @@
   if (p->dic == 0 || dicBufSize != p->dicBufSize)
   {
     LzmaDec_FreeDict(p, alloc);
-    p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
+    p->dic = (SZByte *)alloc->Alloc(alloc, dicBufSize);
     if (p->dic == 0)
     {
       LzmaDec_FreeProbs(p, alloc);
@@ -966,8 +966,8 @@
   return SZ_OK;
 }
 
-SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
+SRes LzmaDecode(SZByte *dest, SizeT *destLen, const SZByte *src, SizeT *srcLen,
+    const SZByte *propData, unsigned propSize, ELzmaFinishMode finishMode,
     ELzmaStatus *status, ISzAlloc *alloc)
 {
   CLzmaDec p;
diff -u -d -b -w -r libclamav/7z/LzmaDec.h libclamav/7z/LzmaDec.h
--- libclamav/7z/LzmaDec.h	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/LzmaDec.h	2013-09-25 11:42:18.000000000 -0400
@@ -37,7 +37,7 @@
   SZ_ERROR_UNSUPPORTED - Unsupported properties
 */
 
-SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
+SRes LzmaProps_Decode(CLzmaProps *p, const SZByte *data, unsigned size);
 
 
 /* ---------- LZMA Decoder state ---------- */
@@ -51,8 +51,8 @@
 {
   CLzmaProps prop;
   CLzmaProb *probs;
-  Byte *dic;
-  const Byte *buf;
+  SZByte *dic;
+  const SZByte *buf;
   UInt32 range, code;
   SizeT dicPos;
   SizeT dicBufSize;
@@ -65,7 +65,7 @@
   int needInitState;
   UInt32 numProbs;
   unsigned tempBufSize;
-  Byte tempBuf[LZMA_REQUIRED_INPUT_MAX];
+  SZByte tempBuf[LZMA_REQUIRED_INPUT_MAX];
 } CLzmaDec;
 
 #define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }
@@ -131,10 +131,10 @@
   SZ_ERROR_UNSUPPORTED - Unsupported properties
 */
    
-SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
+SRes LzmaDec_AllocateProbs(CLzmaDec *p, const SZByte *props, unsigned propsSize, ISzAlloc *alloc);
 void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
 
-SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
+SRes LzmaDec_Allocate(CLzmaDec *state, const SZByte *prop, unsigned propsSize, ISzAlloc *alloc);
 void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
 
 /* ---------- Dictionary Interface ---------- */
@@ -179,7 +179,7 @@
 */
 
 SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
+    const SZByte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
 
 
 /* ---------- Buffer Interface ---------- */
@@ -195,8 +195,8 @@
   LZMA_FINISH_END - Stream must be finished after (*destLen).
 */
 
-SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
+SRes LzmaDec_DecodeToBuf(CLzmaDec *p, SZByte *dest, SizeT *destLen,
+    const SZByte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
 
 
 /* ---------- One Call Interface ---------- */
@@ -220,8 +220,8 @@
   SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
 */
 
-SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
+SRes LzmaDecode(SZByte *dest, SizeT *destLen, const SZByte *src, SizeT *srcLen,
+    const SZByte *propData, unsigned propSize, ELzmaFinishMode finishMode,
     ELzmaStatus *status, ISzAlloc *alloc);
 
 #ifdef __cplusplus
diff -u -d -b -w -r libclamav/7z/Ppmd.h libclamav/7z/Ppmd.h
--- libclamav/7z/Ppmd.h	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/Ppmd.h	2013-09-25 11:42:34.000000000 -0400
@@ -33,17 +33,17 @@
 typedef struct
 {
   UInt16 Summ; /* Freq */
-  Byte Shift;  /* Speed of Freq change; low Shift is for fast change */
-  Byte Count;  /* Count to next change of Shift */
+  SZByte Shift;  /* Speed of Freq change; low Shift is for fast change */
+  SZByte Count;  /* Count to next change of Shift */
 } CPpmd_See;
 
 #define Ppmd_See_Update(p)  if ((p)->Shift < PPMD_PERIOD_BITS && --(p)->Count == 0) \
-    { (p)->Summ <<= 1; (p)->Count = (Byte)(3 << (p)->Shift++); }
+    { (p)->Summ <<= 1; (p)->Count = (SZByte)(3 << (p)->Shift++); }
 
 typedef struct
 {
-  Byte Symbol;
-  Byte Freq;
+  SZByte Symbol;
+  SZByte Freq;
   UInt16 SuccessorLow;
   UInt16 SuccessorHigh;
 } CPpmd_State;
@@ -66,7 +66,7 @@
 
 typedef
   #ifdef PPMD_32BIT
-    Byte *
+    SZByte *
   #else
     UInt32
   #endif
diff -u -d -b -w -r libclamav/7z/Ppmd7.c libclamav/7z/Ppmd7.c
--- libclamav/7z/Ppmd7.c	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/Ppmd7.c	2013-09-25 11:40:06.000000000 -0400
@@ -6,7 +6,7 @@
 
 #include "Ppmd7.h"
 
-const Byte PPMD7_kExpEscape[16] = { 25, 14, 9, 7, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 2 };
+const SZByte PPMD7_kExpEscape[16] = { 25, 14, 9, 7, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 2 };
 static const UInt16 kInitBinEsc[] = { 0x3CDD, 0x1F3F, 0x59BF, 0x48F3, 0x64A1, 0x5ABC, 0x6632, 0x6051};
 
 #define MAX_FREQ 124
@@ -19,7 +19,7 @@
 #ifdef PPMD_32BIT
   #define REF(ptr) (ptr)
 #else
-  #define REF(ptr) ((UInt32)((Byte *)(ptr) - (p)->Base))
+  #define REF(ptr) ((UInt32)((SZByte *)(ptr) - (p)->Base))
 #endif
 
 #define STATS_REF(ptr) ((CPpmd_State_Ref)REF(ptr))
@@ -69,8 +69,8 @@
   for (i = 0, k = 0; i < PPMD_NUM_INDEXES; i++)
   {
     unsigned step = (i >= 12 ? 4 : (i >> 2) + 1);
-    do { p->Units2Indx[k++] = (Byte)i; } while(--step);
-    p->Indx2Units[i] = (Byte)k;
+    do { p->Units2Indx[k++] = (SZByte)i; } while(--step);
+    p->Indx2Units[i] = (SZByte)k;
   }
 
   p->NS2BSIndx[0] = (0 << 1);
@@ -79,10 +79,10 @@
   memset(p->NS2BSIndx + 11, (3 << 1), 256 - 11);
 
   for (i = 0; i < 3; i++)
-    p->NS2Indx[i] = (Byte)i;
+    p->NS2Indx[i] = (SZByte)i;
   for (m = i, k = 1; i < 256; i++)
   {
-    p->NS2Indx[i] = (Byte)m;
+    p->NS2Indx[i] = (SZByte)m;
     if (--k == 0)
       k = (++m) - 2;
   }
@@ -109,7 +109,7 @@
       #else
         4 - (size & 3);
       #endif
-    if ((p->Base = (Byte *)alloc->Alloc(alloc, p->AlignOffset + size
+    if ((p->Base = (SZByte *)alloc->Alloc(alloc, p->AlignOffset + size
         #ifndef PPMD_32BIT
         + UNIT_SIZE
         #endif
@@ -136,11 +136,11 @@
 static void SplitBlock(CPpmd7 *p, void *ptr, unsigned oldIndx, unsigned newIndx)
 {
   unsigned i, nu = I2U(oldIndx) - I2U(newIndx);
-  ptr = (Byte *)ptr + U2B(I2U(newIndx));
+  ptr = (SZByte *)ptr + U2B(I2U(newIndx));
   if (I2U(i = U2I(nu)) != nu)
   {
     unsigned k = I2U(--i);
-    InsertNode(p, ((Byte *)ptr) + U2B(k), nu - k - 1);
+    InsertNode(p, ((SZByte *)ptr) + U2B(k), nu - k - 1);
   }
   InsertNode(p, ptr, i);
 }
@@ -311,7 +311,7 @@
   for (i = 0; i < 256; i++)
   {
     CPpmd_State *s = &p->FoundState[i];
-    s->Symbol = (Byte)i;
+    s->Symbol = (SZByte)i;
     s->Freq = 1;
     SetSuccessor(s, 0);
   }
@@ -376,7 +376,7 @@
     ps[numPs++] = s;
   }
   
-  upState.Symbol = *(const Byte *)Ppmd7_GetPtr(p, upBranch);
+  upState.Symbol = *(const SZByte *)Ppmd7_GetPtr(p, upBranch);
   SetSuccessor(&upState, upBranch + 1);
   
   if (c->NumStats == 1)
@@ -388,7 +388,7 @@
     for (s = STATS(c); s->Symbol != upState.Symbol; s++);
     cf = s->Freq - 1;
     s0 = c->SummFreq - c->NumStats - cf;
-    upState.Freq = (Byte)(1 + ((2 * cf <= s0) ? (5 * cf > s0) : ((2 * cf + 3 * s0 - 1) / (2 * s0))));
+    upState.Freq = (SZByte)(1 + ((2 * cf <= s0) ? (5 * cf > s0) : ((2 * cf + 3 * s0 - 1) / (2 * s0))));
   }
 
   do
@@ -565,7 +565,7 @@
       CPpmd_State *s = STATS(c) + ns1;
       SetSuccessor(s, successor);
       s->Symbol = p->FoundState->Symbol;
-      s->Freq = (Byte)cf;
+      s->Freq = (SZByte)cf;
       c->NumStats = (UInt16)(ns1 + 1);
     }
   }
@@ -586,14 +586,14 @@
   escFreq = p->MinContext->SummFreq - s->Freq;
   s->Freq += 4;
   adder = (p->OrderFall != 0);
-  s->Freq = (Byte)((s->Freq + adder) >> 1);
+  s->Freq = (SZByte)((s->Freq + adder) >> 1);
   sumFreq = s->Freq;
   
   i = p->MinContext->NumStats - 1;
   do
   {
     escFreq -= (++s)->Freq;
-    s->Freq = (Byte)((s->Freq + adder) >> 1);
+    s->Freq = (SZByte)((s->Freq + adder) >> 1);
     sumFreq += s->Freq;
     if (s[0].Freq > s[-1].Freq)
     {
@@ -619,7 +619,7 @@
       CPpmd_State tmp = *stats;
       do
       {
-        tmp.Freq = (Byte)(tmp.Freq - (tmp.Freq >> 1));
+        tmp.Freq = (SZByte)(tmp.Freq - (tmp.Freq >> 1));
         escFreq >>= 1;
       }
       while (escFreq > 1);
@@ -664,7 +664,7 @@
 static void NextContext(CPpmd7 *p)
 {
   CTX_PTR c = CTX(SUCCESSOR(p->FoundState));
-  if (p->OrderFall == 0 && (Byte *)c > p->Text)
+  if (p->OrderFall == 0 && (SZByte *)c > p->Text)
     p->MinContext = p->MaxContext = c;
   else
     UpdateModel(p);
@@ -697,7 +697,7 @@
 
 void Ppmd7_UpdateBin(CPpmd7 *p)
 {
-  p->FoundState->Freq = (Byte)(p->FoundState->Freq + (p->FoundState->Freq < 128 ? 1: 0));
+  p->FoundState->Freq = (SZByte)(p->FoundState->Freq + (p->FoundState->Freq < 128 ? 1: 0));
   p->PrevSuccess = 1;
   p->RunLength++;
   NextContext(p);
diff -u -d -b -w -r libclamav/7z/Ppmd7.h libclamav/7z/Ppmd7.h
--- libclamav/7z/Ppmd7.h	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/Ppmd7.h	2013-09-25 11:43:00.000000000 -0400
@@ -48,13 +48,13 @@
 
   UInt32 Size;
   UInt32 GlueCount;
-  Byte *Base, *LoUnit, *HiUnit, *Text, *UnitsStart;
+  SZByte *Base, *LoUnit, *HiUnit, *Text, *UnitsStart;
   UInt32 AlignOffset;
 
-  Byte Indx2Units[PPMD_NUM_INDEXES];
-  Byte Units2Indx[128];
+  SZByte Indx2Units[PPMD_NUM_INDEXES];
+  SZByte Units2Indx[128];
   CPpmd_Void_Ref FreeList[PPMD_NUM_INDEXES];
-  Byte NS2Indx[256], NS2BSIndx[256], HB2Flag[256];
+  SZByte NS2Indx[256], NS2BSIndx[256], HB2Flag[256];
   CPpmd_See DummySee, See[25][16];
   UInt16 BinSumm[128][64];
 } CPpmd7;
@@ -68,7 +68,7 @@
 
 /* ---------- Internal Functions ---------- */
 
-extern const Byte PPMD7_kExpEscape[16];
+extern const SZByte PPMD7_kExpEscape[16];
 
 #ifdef PPMD_32BIT
   #define Ppmd7_GetPtr(p, ptr) (ptr)
@@ -125,7 +125,7 @@
 {
   UInt64 Low;
   UInt32 Range;
-  Byte Cache;
+  SZByte Cache;
   UInt64 CacheSize;
   IByteOut *Stream;
 } CPpmd7z_RangeEnc;
diff -u -d -b -w -r libclamav/7z/Ppmd7Dec.c libclamav/7z/Ppmd7Dec.c
--- libclamav/7z/Ppmd7Dec.c	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/Ppmd7Dec.c	2013-09-25 11:40:20.000000000 -0400
@@ -86,7 +86,7 @@
     UInt32 count, hiCnt;
     if ((count = rc->GetThreshold(rc, p->MinContext->SummFreq)) < (hiCnt = s->Freq))
     {
-      Byte symbol;
+      SZByte symbol;
       rc->Decode(rc, 0, s->Freq);
       p->FoundState = s;
       symbol = s->Symbol;
@@ -99,7 +99,7 @@
     {
       if ((hiCnt += (++s)->Freq) > count)
       {
-        Byte symbol;
+        SZByte symbol;
         rc->Decode(rc, hiCnt - s->Freq, s->Freq);
         p->FoundState = s;
         symbol = s->Symbol;
@@ -122,7 +122,7 @@
     UInt16 *prob = Ppmd7_GetBinSumm(p);
     if (rc->DecodeBit(rc, *prob) == 0)
     {
-      Byte symbol;
+      SZByte symbol;
       *prob = (UInt16)PPMD_UPDATE_PROB_0(*prob);
       symbol = (p->FoundState = Ppmd7Context_OneState(p->MinContext))->Symbol;
       Ppmd7_UpdateBin(p);
@@ -167,7 +167,7 @@
     
     if (count < hiCnt)
     {
-      Byte symbol;
+      SZByte symbol;
       CPpmd_State **pps = ps;
       for (hiCnt = 0; (hiCnt += (*pps)->Freq) <= count; pps++);
       s = *pps;
diff -u -d -b -w -r libclamav/7z/Types.h libclamav/7z/Types.h
--- libclamav/7z/Types.h	2013-09-25 11:30:13.000000000 -0400
+++ libclamav/7z/Types.h	2013-09-25 11:43:09.000000000 -0400
@@ -55,7 +55,7 @@
 #define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
 #endif
 
-typedef unsigned char Byte;
+typedef unsigned char SZByte;
 typedef short Int16;
 typedef unsigned short UInt16;
 
@@ -129,12 +129,12 @@
 
 typedef struct
 {
-  Byte (*Read)(void *p); /* reads one byte, returns 0 in case of EOF or error */
+  SZByte (*Read)(void *p); /* reads one byte, returns 0 in case of EOF or error */
 } IByteIn;
 
 typedef struct
 {
-  void (*Write)(void *p, Byte b);
+  void (*Write)(void *p, SZByte b);
 } IByteOut;
 
 typedef struct
@@ -147,7 +147,7 @@
 /* it can return SZ_ERROR_INPUT_EOF */
 SRes SeqInStream_Read(ISeqInStream *stream, void *buf, size_t size);
 SRes SeqInStream_Read2(ISeqInStream *stream, void *buf, size_t size, SRes errorType);
-SRes SeqInStream_ReadByte(ISeqInStream *stream, Byte *buf);
+SRes SeqInStream_ReadByte(ISeqInStream *stream, SZByte *buf);
 
 typedef struct
 {
@@ -199,7 +199,7 @@
   ISeekInStream *realStream;
   size_t pos;
   size_t size;
-  Byte buf[LookToRead_BUF_SIZE];
+  SZByte buf[LookToRead_BUF_SIZE];
 } CLookToRead;
 
 void LookToRead_CreateVTable(CLookToRead *p, int lookahead);
