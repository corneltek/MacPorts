From f27355c10ce84f000530fbc5a22449047a095efc Mon Sep 17 00:00:00 2001
From: Richard Smith <richard-llvm@metafoo.co.uk>
Date: Wed, 12 Nov 2014 01:43:45 +0000
Subject: [PATCH 1/2] PR21536: Fix a corner case where we'd get confused by a
 pack expanding into the penultimate parameter of a template parameter list,
 where the last parameter is itself a pack, and build a bogus empty final pack
 argument.

git-svn-id: https://llvm.org/svn/llvm-project/cfe/trunk@221748 91177308-0d34-0410-b5e6-96231b3b80d8
(cherry picked from commit b6ff5628bec83cb58cdb9724584eeaf0a51fe81b)
---
 lib/Sema/SemaTemplate.cpp       |  2 +-
 test/SemaTemplate/deduction.cpp | 18 +++++++++++++++++-
 2 files changed, 18 insertions(+), 2 deletions(-)

diff --git a/lib/Sema/SemaTemplate.cpp b/lib/Sema/SemaTemplate.cpp
index 63581a4..5596a01 100644
--- a/tools/clang/lib/Sema/SemaTemplate.cpp
+++ b/tools/clang/lib/Sema/SemaTemplate.cpp
@@ -3746,7 +3746,7 @@ bool Sema::CheckTemplateArgumentList(TemplateDecl *Template,
         }
 
         // Push the argument pack onto the list of converted arguments.
-        if (InFinalParameterPack) {
+        if (InFinalParameterPack && !ArgumentPack.empty()) {
           Converted.push_back(
             TemplateArgument::CreatePackCopy(Context,
                                              ArgumentPack.data(),
diff --git a/test/SemaTemplate/deduction.cpp b/test/SemaTemplate/deduction.cpp
index aecb5ee..c089573 100644
--- a/tools/clang/test/SemaTemplate/deduction.cpp
+++ b/tools/clang/test/SemaTemplate/deduction.cpp
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -fsyntax-only -verify %s
+// RUN: %clang_cc1 -fsyntax-only -verify %s -std=c++11
 
 // Template argument deduction with template template parameters.
 template<typename T, template<T> class A> 
@@ -162,3 +162,19 @@ namespace test14 {
     foo(a);
   }
 }
+
+namespace PR21536 {
+  template<typename ...T> struct X;
+  template<typename A, typename ...B> struct S {
+    static_assert(sizeof...(B) == 1, "");
+    void f() {
+      using T = A;
+      using T = int;
+
+      using U = X<B...>;
+      using U = X<int>;
+    }
+  };
+  template<typename ...T> void f(S<T...>);
+  void g() { f(S<int, int>()); }
+}
-- 
2.1.3

