diff --git a/src/graph/graph_adaptor.hh b/src/graph/graph_adaptor.hh
index aa9f379..be9d675 100644
--- src/graph/graph_adaptor.hh
+++ src/graph/graph_adaptor.hh
@@ -139,8 +139,8 @@ struct make_undirected_edge
 template <class Graph, class Iter>
 struct transformed_iterator
 {
-    typedef typename mpl::if_<std::tr1::is_convertible<typename std::iterator_traits<Iter>::iterator_category,
-                                                       std::random_access_iterator_tag>,
+    typedef typename mpl::if_<is_convertible<typename std::iterator_traits<Iter>::iterator_category,
+                                             std::random_access_iterator_tag>,
                               transform_random_access_iterator<make_undirected_edge<Graph>, Iter>,
                               transform_iterator<make_undirected_edge<Graph>, Iter> >::type type;
     typedef is_convertible<typename std::iterator_traits<Iter>::iterator_category,
diff --git a/src/graph/topology/graph_subgraph_isomorphism.cc b/src/graph/topology/graph_subgraph_isomorphism.cc
index 8d4633a..112472e 100644
--- src/graph/topology/graph_subgraph_isomorphism.cc
+++ src/graph/topology/graph_subgraph_isomorphism.cc
@@ -15,13 +15,14 @@
 // You should have received a copy of the GNU General Public License
 // along with this program. If not, see <http://www.gnu.org/licenses/>.
 
+#include <graph_python_interface.hh>
+
 #include "graph.hh"
 #include "graph_filtering.hh"
 
 #include "random.hh"
 
 #include <graph_subgraph_isomorphism.hh>
-#include <graph_python_interface.hh>
 
 #include "tr1_include.hh"
 #include TR1_HEADER(unordered_map)
diff --git a/src/graph/topology/graph_subgraph_isomorphism.hh b/src/graph/topology/graph_subgraph_isomorphism.hh
index 0728147..f349ace 100644
--- src/graph/topology/graph_subgraph_isomorphism.hh
+++ src/graph/topology/graph_subgraph_isomorphism.hh
@@ -213,7 +213,7 @@ void find_mappings(const Graph1& sub, const Graph2& g, matrix_t& M0,
     // [current M] [current sub vertex] [current mapping vertex]
     typedef tuple<matrix_t, size_t,
                   typename matrix_t::value_type::const_iterator> state_t;
-    list<state_t> Mstack;
+    std::list<state_t> Mstack;
     Mstack.push_back(make_tuple(M0, i, M0[i].begin()));
     get<2>(Mstack.back()) = get<0>(Mstack.back())[i].begin();
     tr1::unordered_set<size_t> already_mapped;
