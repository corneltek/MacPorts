--- host/examples/test_clock_synch.cpp.orig
+++ host/examples/test_clock_synch.cpp
@@ -35,14 +35,14 @@ using namespace uhd::usrp_clock;
 using namespace uhd::usrp;
 
 void wait_for_pps(multi_usrp::sptr usrp, size_t chan, double timeout){
-    boost::uint32_t last_pps_time = usrp->get_time_last_pps(chan).get_full_secs();
-    boost::uint32_t system_time = uhd::time_spec_t::get_system_time().get_full_secs();
-    boost::uint32_t exit_time = system_time + timeout;
+    time_t last_pps_time = usrp->get_time_last_pps(chan).get_full_secs();
+    time_t system_time = uhd::time_spec_t::get_system_time().get_full_secs();
+    time_t exit_time = system_time + timeout;
     bool detected_pps = false;
 
     //Otherwise, this would hang if the USRP doesn't detect any PPS
     while(uhd::time_spec_t::get_system_time().get_full_secs() < exit_time){
-        boost::uint32_t time_now = usrp->get_time_last_pps(chan).get_full_secs();
+        time_t time_now = usrp->get_time_last_pps(chan).get_full_secs();
         if(last_pps_time < time_now){
             detected_pps = true;
             break;
--- host/include/uhd/transport/nirio/nirio_fifo.h.orig
+++ host/include/uhd/transport/nirio/nirio_fifo.h
@@ -59,8 +59,8 @@ public:
 
     inline const std::string& get_name() const { return _name; }
     inline uint32_t get_channel() const { return _fifo_channel; }
-    inline uint32_t get_direction() const { return _fifo_direction; }
-    inline uint32_t get_scalar_type() const { return _datatype_info.scalar_type; }
+    inline fifo_direction_t get_direction() const { return _fifo_direction; }
+    inline nirio_scalar_type_t get_scalar_type() const { return _datatype_info.scalar_type; }
 
     nirio_status start();
 
--- host/include/uhd/transport/nirio/nirio_fifo.ipp.orig
+++ host/include/uhd/transport/nirio/nirio_fifo.ipp
@@ -15,9 +15,11 @@
 // along with this program.  If not, see <http://www.gnu.org/licenses/>.
 //
 
-#ifdef __clang__
-    #pragma GCC diagnostic push ignored "-Wmissing-field-initializers"
-#elif defined(__GNUC__)
+// "push" and "pop" introduced in GCC 4.6; works with all clang
+#if defined(__clang__) || defined(__GNUC__) && (__GNUC__ > 3) && (__GNUC_MINOR__ > 5)
+    #pragma GCC diagnostic push
+#endif
+#if defined(__clang__) || defined(__GNUC__)
     #pragma GCC diagnostic ignored "-Wmissing-field-initializers"
 #endif
 
@@ -375,6 +377,6 @@ inline datatype_info_t nirio_fifo<uint64_t>::_get_datatype_info()
     return datatype_info_t(RIO_SCALAR_TYPE_UQ, 8);
 }
 
-#ifdef __GNUC__
+#if defined(__clang__) || defined(__GNUC__) && (__GNUC__ > 3) && (__GNUC_MINOR__ > 5)
     #pragma GCC diagnostic pop
 #endif
--- host/lib/transport/nirio/nirio_driver_iface_unsupported.cpp.orig
+++ host/lib/transport/nirio/nirio_driver_iface_unsupported.cpp
@@ -19,43 +19,43 @@
 namespace nirio_driver_iface {
 
 nirio_status rio_open(
-    const std::string& device_path,
-    rio_dev_handle_t& device_handle)
+    const std::string& /* device_path */,
+    rio_dev_handle_t& /* device_handle */)
 {
     return NiRio_Status_FeatureNotSupported;
 }
 
-void rio_close(rio_dev_handle_t& device_handle)
+void rio_close(rio_dev_handle_t& /* device_handle */)
 {
 }
 
-bool rio_isopen(rio_dev_handle_t device_handle)
+bool rio_isopen(rio_dev_handle_t /* device_handle */)
 {
     return false;
 }
 
 nirio_status rio_ioctl(
-    rio_dev_handle_t device_handle,
-    uint32_t ioctl_code,
-    const void *write_buf,
-    size_t write_buf_len,
-    void *read_buf,
-    size_t read_buf_len)
+    rio_dev_handle_t /* device_handle */,
+    uint32_t /* ioctl_code */,
+    const void* /* write_buf */,
+    size_t /* write_buf_len */,
+    void* /* read_buf */,
+    size_t /* read_buf_len */)
 {
     return NiRio_Status_FeatureNotSupported;
 }
 
 nirio_status rio_mmap(
-    rio_dev_handle_t device_handle,
-    uint16_t memory_type,
-    size_t size,
-    bool writable,
-    rio_mmap_t &map)
+    rio_dev_handle_t /* device_handle */,
+    uint16_t /* memory_type */,
+    size_t /* size */,
+    bool /* writable */,
+    rio_mmap_t& /* map */)
 {
     return NiRio_Status_FeatureNotSupported;
 }
 
-nirio_status rio_munmap(rio_mmap_t &map)
+nirio_status rio_munmap(rio_mmap_t& /* map */)
 {
     return NiRio_Status_FeatureNotSupported;
 }
--- host/lib/transport/nirio/nirio_resource_manager.cpp.orig
+++ host/lib/transport/nirio/nirio_resource_manager.cpp
@@ -15,12 +15,13 @@
 // along with this program.  If not, see <http://www.gnu.org/licenses/>.
 //
 
-
 #include <uhd/transport/nirio/nirio_resource_manager.h>
 
-#ifdef __clang__
-    #pragma GCC diagnostic push ignored "-Wmissing-field-initializers"
-#elif defined(__GNUC__)
+// "push" and "pop" introduced in GCC 4.6; works with all clang
+#if defined(__clang__) || defined(__GNUC__) && (__GNUC__ > 3) && (__GNUC_MINOR__ > 5)
+    #pragma GCC diagnostic push
+#endif
+#if defined(__clang__) || defined(__GNUC__)
     #pragma GCC diagnostic ignored "-Wmissing-field-initializers"
 #endif
 
@@ -100,6 +101,6 @@ nirio_fifo_info_t* nirio_resource_manager::_lookup_fifo_info(const char* fifo_na
 
 }}
 
-#ifdef __GNUC__
+#if defined(__clang__) || defined(__GNUC__) && (__GNUC__ > 3) && (__GNUC_MINOR__ > 5)
     #pragma GCC diagnostic pop
 #endif
--- host/lib/transport/nirio/niriok_proxy.cpp.orig
+++ host/lib/transport/nirio/niriok_proxy.cpp
@@ -20,9 +20,11 @@
 #include <uhd/transport/nirio/niriok_proxy_impl_v2.h>
 #include <cstring>
 
-#ifdef __clang__
-    #pragma GCC diagnostic push ignored "-Wmissing-field-initializers"
-#elif defined(__GNUC__)
+// "push" and "pop" introduced in GCC 4.6; works with all clang
+#if defined(__clang__) || defined(__GNUC__) && (__GNUC__ > 3) && (__GNUC_MINOR__ > 5)
+    #pragma GCC diagnostic push
+#endif
+#if defined(__clang__) || defined(__GNUC__)
     #pragma GCC diagnostic ignored "-Wmissing-field-initializers"
 #endif
 
@@ -73,6 +75,6 @@ namespace uhd { namespace niusrprio
    }
 }}
 
-#ifdef __GNUC__
+#if defined(__clang__) || defined(__GNUC__) && (__GNUC__ > 3) && (__GNUC_MINOR__ > 5)
     #pragma GCC diagnostic pop
 #endif
--- host/lib/transport/nirio/niriok_proxy_impl_v1.cpp.orig
+++ host/lib/transport/nirio/niriok_proxy_impl_v1.cpp
@@ -15,13 +15,14 @@
 // along with this program.  If not, see <http://www.gnu.org/licenses/>.
 //
 
-
 #include <uhd/transport/nirio/niriok_proxy_impl_v1.h>
 #include <cstring>
 
-#ifdef __clang__
-    #pragma GCC diagnostic push ignored "-Wmissing-field-initializers"
-#elif defined(__GNUC__)
+// "push" and "pop" introduced in GCC 4.6; works with all clang
+#if defined(__clang__) || defined(__GNUC__) && (__GNUC__ > 3) && (__GNUC_MINOR__ > 5)
+    #pragma GCC diagnostic push
+#endif
+#if defined(__clang__) || defined(__GNUC__)
     #pragma GCC diagnostic ignored "-Wmissing-field-initializers"
 #endif
 
@@ -490,6 +491,6 @@ namespace uhd { namespace niusrprio
 
 }}
 
-#ifdef __GNUC__
+#if defined(__clang__) || defined(__GNUC__) && (__GNUC__ > 3) && (__GNUC_MINOR__ > 5)
     #pragma GCC diagnostic pop
 #endif
--- host/lib/transport/nirio/niriok_proxy_impl_v2.cpp.orig
+++ host/lib/transport/nirio/niriok_proxy_impl_v2.cpp
@@ -19,9 +19,11 @@
 #include <uhd/transport/nirio/niriok_proxy_impl_v2.h>
 #include <cstring>
 
-#ifdef __clang__
-    #pragma GCC diagnostic push ignored "-Wmissing-field-initializers"
-#elif defined(__GNUC__)
+// "push" and "pop" introduced in GCC 4.6; works with all clang
+#if defined(__clang__) || defined(__GNUC__) && (__GNUC__ > 3) && (__GNUC_MINOR__ > 5)
+    #pragma GCC diagnostic push
+#endif
+#if defined(__clang__) || defined(__GNUC__)
     #pragma GCC diagnostic ignored "-Wmissing-field-initializers"
 #endif
 
@@ -642,6 +644,6 @@ namespace uhd { namespace niusrprio
 
 }}
 
-#ifdef __GNUC__
+#if defined(__clang__) || defined(__GNUC__) && (__GNUC__ > 3) && (__GNUC_MINOR__ > 5)
     #pragma GCC diagnostic pop
 #endif
--- host/lib/transport/super_recv_packet_handler.hpp.orig
+++ host/lib/transport/super_recv_packet_handler.hpp
@@ -147,7 +147,7 @@ public:
      */
     void set_xport_chan_get_buff(const size_t xport_chan, const get_buff_type &get_buff, const bool flush = false){
         if (flush){
-            while (get_buff(0.0));
+            while (get_buff(0.0)) {};
         }
         _props.at(xport_chan).get_buff = get_buff;
     }
--- host/lib/usrp/common/ad9361_driver/ad9361_synth_lut.h.orig
+++ host/lib/usrp/common/ad9361_driver/ad9361_synth_lut.h
@@ -6,20 +6,20 @@
 #define INCLUDED_AD9361_SYNTH_LUT_HPP
 
 
-double vco_index[53] = {12605000000, 12245000000, 11906000000, 11588000000,
-                        11288000000, 11007000000, 10742000000, 10492000000,
-                        10258000000, 10036000000, 9827800000, 9631100000,
-                        9445300000, 9269800000, 9103600000, 8946300000,
-                        8797000000, 8655300000, 8520600000, 8392300000,
-                        8269900000, 8153100000, 8041400000, 7934400000,
-                        7831800000, 7733200000, 7638400000, 7547100000,
-                        7459000000, 7374000000, 7291900000, 7212400000,
-                        7135500000, 7061000000, 6988700000, 6918600000,
-                        6850600000, 6784600000, 6720500000, 6658200000,
-                        6597800000, 6539200000, 6482300000, 6427000000,
-                        6373400000, 6321400000, 6270900000, 6222000000,
-                        6174500000, 6128400000, 6083600000, 6040100000,
-                        5997700000};
+double vco_index[53] = {12605000000.0, 12245000000.0, 11906000000.0, 11588000000.0,
+                        11288000000.0, 11007000000.0, 10742000000.0, 10492000000.0,
+                        10258000000.0, 10036000000.0, 9827800000.0, 9631100000.0,
+                        9445300000.0, 9269800000.0, 9103600000.0, 8946300000.0,
+                        8797000000.0, 8655300000.0, 8520600000.0, 8392300000.0,
+                        8269900000.0, 8153100000.0, 8041400000.0, 7934400000.0,
+                        7831800000.0, 7733200000.0, 7638400000.0, 7547100000.0,
+                        7459000000.0, 7374000000.0, 7291900000.0, 7212400000.0,
+                        7135500000.0, 7061000000.0, 6988700000.0, 6918600000.0,
+                        6850600000.0, 6784600000.0, 6720500000.0, 6658200000.0,
+                        6597800000.0, 6539200000.0, 6482300000.0, 6427000000.0,
+                        6373400000.0, 6321400000.0, 6270900000.0, 6222000000.0,
+                        6174500000.0, 6128400000.0, 6083600000.0, 6040100000.0,
+                        5997700000.0};
 
 int synth_cal_lut[53][12] = {   {10, 0, 4, 0, 15, 8, 8, 13, 4, 13, 15, 9},
                                 {10, 0, 4, 0, 15, 8, 9, 13, 4, 13, 15, 9},
--- host/tests/chdr_test.cpp.orig
+++ host/tests/chdr_test.cpp
@@ -81,7 +81,7 @@ BOOST_AUTO_TEST_CASE(test_with_chdr){
     if_packet_info.eob = false;
     if_packet_info.packet_count = 7;
     if_packet_info.has_tsf = true;
-    if_packet_info.tsf = 0x1234567890ABCDEF;
+    if_packet_info.tsf = 0x1234567890ABCDEFull;
     if_packet_info.sid = 0xAABBCCDD;
     if_packet_info.num_payload_words32 = 24;
     if_packet_info.num_payload_bytes = 95;
@@ -94,7 +94,7 @@ BOOST_AUTO_TEST_CASE(test_with_chdr_fc){
     if_packet_info.eob = false;
     if_packet_info.packet_count = 19;
     if_packet_info.has_tsf = false;
-    if_packet_info.tsf = 0x1234567890ABCDEF;
+    if_packet_info.tsf = 0x1234567890ABCDEFull;
     if_packet_info.sid = 0xAABBCCDD;
     if_packet_info.num_payload_words32 = 4;
     if_packet_info.num_payload_bytes = 16;
@@ -106,7 +106,7 @@ BOOST_AUTO_TEST_CASE(test_with_chdr_cmd){
     if_packet_info.packet_type = if_packet_info_t::PACKET_TYPE_CMD;
     if_packet_info.packet_count = 19;
     if_packet_info.has_tsf = true;
-    if_packet_info.tsf = 0x1234567890ABCDEF;
+    if_packet_info.tsf = 0x1234567890ABCDEFull;
     if_packet_info.sid = 0xAABBCCDD;
     if_packet_info.num_payload_words32 = 4;
     if_packet_info.num_payload_bytes = 16;
@@ -118,7 +118,7 @@ BOOST_AUTO_TEST_CASE(test_with_chdr_resp){
     if_packet_info.packet_type = if_packet_info_t::PACKET_TYPE_RESP;
     if_packet_info.packet_count = 123;
     if_packet_info.has_tsf = false;
-    if_packet_info.tsf = 0x1234567890ABCDEF;
+    if_packet_info.tsf = 0x1234567890ABCDEFull;
     if_packet_info.sid = 0xAABBCCDD;
     if_packet_info.num_payload_words32 = 4;
     if_packet_info.num_payload_bytes = 16;
@@ -132,7 +132,7 @@ BOOST_AUTO_TEST_CASE(test_with_chdr_err){
     if_packet_info.eob = false;
     if_packet_info.error = false; // Needs to be set explicitly
     if_packet_info.has_tsf = false;
-    if_packet_info.tsf = 0x1234567890ABCDEF;
+    if_packet_info.tsf = 0x1234567890ABCDEFull;
     if_packet_info.sid = 0xAABBCCDD;
     if_packet_info.num_payload_words32 = 4;
     if_packet_info.num_payload_bytes = 16;
--- host/tests/fp_compare_delta_test.cpp.orig
+++ host/tests/fp_compare_delta_test.cpp
@@ -239,12 +239,12 @@ BOOST_AUTO_TEST_CASE(double_greaterthanequals_operators) {
 
 BOOST_AUTO_TEST_CASE(frequency_compare_function) {
 
-    BOOST_CHECK(uhd::math::frequencies_are_equal(6817333232, 6817333232));
-    BOOST_CHECK(!uhd::math::frequencies_are_equal(6817333233, 6817333232));
+    BOOST_CHECK(uhd::math::frequencies_are_equal(6817333232.0, 6817333232.0));
+    BOOST_CHECK(!uhd::math::frequencies_are_equal(6817333233.0, 6817333232.0));
     BOOST_CHECK(uhd::math::frequencies_are_equal(6817333232.1, 6817333232.1));
     BOOST_CHECK(!uhd::math::frequencies_are_equal(6817333232.5, 6817333232.6));
     BOOST_CHECK(uhd::math::frequencies_are_equal(16.8173332321e9, 16.8173332321e9));
     BOOST_CHECK(!uhd::math::frequencies_are_equal(16.8173332322e9, 16.8173332321e9));
     BOOST_CHECK(!uhd::math::frequencies_are_equal(5.0, 4.0));
-    BOOST_CHECK(uhd::math::frequencies_are_equal(48750000, 48749999.9946));
+    BOOST_CHECK(uhd::math::frequencies_are_equal(48750000.0, 48749999.9946));
 }
--- host/tests/sid_t_test.cpp.orig
+++ host/tests/sid_t_test.cpp
@@ -30,12 +30,12 @@ BOOST_AUTO_TEST_CASE(test_sid_t) {
     BOOST_CHECK_EQUAL(sid.is_set(), true);
     BOOST_CHECK_EQUAL(sid.to_pp_string(), "1.2>3.16");
     BOOST_CHECK_EQUAL(sid.to_pp_string_hex(), "01:02>03:10");
-    BOOST_CHECK_EQUAL(sid.get_src(), 0x0102);
-    BOOST_CHECK_EQUAL(sid.get_dst(), 0x0310);
-    BOOST_CHECK_EQUAL(sid.get_src_addr(), 0x01);
-    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), 0x02);
-    BOOST_CHECK_EQUAL(sid.get_dst_addr(), 0x03);
-    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), 0x10);
+    BOOST_CHECK_EQUAL(sid.get_src(), (uint32_t)0x0102);
+    BOOST_CHECK_EQUAL(sid.get_dst(), (uint32_t)0x0310);
+    BOOST_CHECK_EQUAL(sid.get_src_addr(), (uint32_t)0x01);
+    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), (uint32_t)0x02);
+    BOOST_CHECK_EQUAL(sid.get_dst_addr(), (uint32_t)0x03);
+    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), (uint32_t)0x10);
     BOOST_CHECK_EQUAL(sid == sid, true);
     BOOST_CHECK_EQUAL(sid == sid_value, true);
 
@@ -68,88 +68,88 @@ BOOST_AUTO_TEST_CASE(test_sid_t_set) {
     sid_t sid(sid_value);
 
     sid.set(0x01020304);
-    BOOST_CHECK_EQUAL(sid.get(), 0x01020304);
-    BOOST_CHECK_EQUAL(sid.get_src_addr(), 0x01);
-    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), 0x02);
-    BOOST_CHECK_EQUAL(sid.get_dst_addr(), 0x03);
-    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), 0x04);
-    BOOST_CHECK_EQUAL(sid.get_dst_xbarport(), 0x0);
-    BOOST_CHECK_EQUAL(sid.get_dst_blockport(), 0x4);
+    BOOST_CHECK_EQUAL(sid.get(), (uint32_t)0x01020304);
+    BOOST_CHECK_EQUAL(sid.get_src_addr(),(uint32_t)0x01);
+    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), (uint32_t)0x02);
+    BOOST_CHECK_EQUAL(sid.get_dst_addr(), (uint32_t)0x03);
+    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), (uint32_t)0x04);
+    BOOST_CHECK_EQUAL(sid.get_dst_xbarport(), (uint32_t)0x0);
+    BOOST_CHECK_EQUAL(sid.get_dst_blockport(), (uint32_t)0x4);
 
     sid.set_src_addr(0x0a);
-    BOOST_CHECK_EQUAL(sid.get(), 0x0a020304);
-    BOOST_CHECK_EQUAL(sid.get_src_addr(), 0x0a);
-    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), 0x02);
-    BOOST_CHECK_EQUAL(sid.get_dst_addr(), 0x03);
-    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), 0x04);
+    BOOST_CHECK_EQUAL(sid.get(), (uint32_t)0x0a020304);
+    BOOST_CHECK_EQUAL(sid.get_src_addr(), (uint32_t)0x0a);
+    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), (uint32_t)0x02);
+    BOOST_CHECK_EQUAL(sid.get_dst_addr(), (uint32_t)0x03);
+    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), (uint32_t)0x04);
 
     sid.set_src_endpoint(0x0b);
-    BOOST_CHECK_EQUAL(sid.get(), 0x0a0b0304);
-    BOOST_CHECK_EQUAL(sid.get_src_addr(), 0x0a);
-    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), 0x0b);
-    BOOST_CHECK_EQUAL(sid.get_dst_addr(), 0x03);
-    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), 0x04);
+    BOOST_CHECK_EQUAL(sid.get(), (uint32_t)0x0a0b0304);
+    BOOST_CHECK_EQUAL(sid.get_src_addr(), (uint32_t)0x0a);
+    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), (uint32_t)0x0b);
+    BOOST_CHECK_EQUAL(sid.get_dst_addr(), (uint32_t)0x03);
+    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), (uint32_t)0x04);
 
     sid.set_dst_addr(0x0c);
-    BOOST_CHECK_EQUAL(sid.get(), 0x0a0b0c04);
-    BOOST_CHECK_EQUAL(sid.get_src_addr(), 0x0a);
-    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), 0x0b);
-    BOOST_CHECK_EQUAL(sid.get_dst_addr(), 0x0c);
-    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), 0x04);
+    BOOST_CHECK_EQUAL(sid.get(), (uint32_t)0x0a0b0c04);
+    BOOST_CHECK_EQUAL(sid.get_src_addr(), (uint32_t)0x0a);
+    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), (uint32_t)0x0b);
+    BOOST_CHECK_EQUAL(sid.get_dst_addr(), (uint32_t)0x0c);
+    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), (uint32_t)0x04);
 
     sid.set_dst_endpoint(0x0d);
-    BOOST_CHECK_EQUAL(sid.get(), 0x0a0b0c0d);
-    BOOST_CHECK_EQUAL(sid.get_src_addr(), 0x0a);
-    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), 0x0b);
-    BOOST_CHECK_EQUAL(sid.get_dst_addr(), 0x0c);
-    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), 0x0d);
+    BOOST_CHECK_EQUAL(sid.get(), (uint32_t)0x0a0b0c0d);
+    BOOST_CHECK_EQUAL(sid.get_src_addr(), (uint32_t)0x0a);
+    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), (uint32_t)0x0b);
+    BOOST_CHECK_EQUAL(sid.get_dst_addr(), (uint32_t)0x0c);
+    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), (uint32_t)0x0d);
 
     sid.set_dst_xbarport(0xb);
-    BOOST_CHECK_EQUAL(sid.get(), 0x0a0b0cbd);
-    BOOST_CHECK_EQUAL(sid.get_src_addr(), 0x0a);
-    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), 0x0b);
-    BOOST_CHECK_EQUAL(sid.get_dst_addr(), 0x0c);
-    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), 0xbd);
+    BOOST_CHECK_EQUAL(sid.get(), (uint32_t)0x0a0b0cbd);
+    BOOST_CHECK_EQUAL(sid.get_src_addr(), (uint32_t)0x0a);
+    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), (uint32_t)0x0b);
+    BOOST_CHECK_EQUAL(sid.get_dst_addr(), (uint32_t)0x0c);
+    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), (uint32_t)0xbd);
 
     sid.set_dst_blockport(0xc);
-    BOOST_CHECK_EQUAL(sid.get(), 0x0a0b0cbc);
-    BOOST_CHECK_EQUAL(sid.get_src_addr(), 0x0a);
-    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), 0x0b);
-    BOOST_CHECK_EQUAL(sid.get_dst_addr(), 0x0c);
-    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), 0xbc);
+    BOOST_CHECK_EQUAL(sid.get(), (uint32_t)0x0a0b0cbc);
+    BOOST_CHECK_EQUAL(sid.get_src_addr(), (uint32_t)0x0a);
+    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), (uint32_t)0x0b);
+    BOOST_CHECK_EQUAL(sid.get_dst_addr(), (uint32_t)0x0c);
+    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), (uint32_t)0xbc);
 
     sid_t flipped_sid = sid.reversed();
-    BOOST_CHECK_EQUAL(flipped_sid.get(), 0x0cbc0a0b);
+    BOOST_CHECK_EQUAL(flipped_sid.get(), (uint32_t)0x0cbc0a0b);
 
     // In-place
     sid.reverse();
-    BOOST_CHECK_EQUAL(sid.get(), 0x0cbc0a0b);
+    BOOST_CHECK_EQUAL(sid.get(), (uint32_t)0x0cbc0a0b);
 }
 
 BOOST_AUTO_TEST_CASE(test_sid_t_from_str) {
     sid_t sid("1.2>3.4");
-    BOOST_CHECK_EQUAL(sid.get_src_addr(), 1);
-    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), 2);
-    BOOST_CHECK_EQUAL(sid.get_dst_addr(), 3);
-    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), 4);
+    BOOST_CHECK_EQUAL(sid.get_src_addr(), (uint32_t)1);
+    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), (uint32_t)2);
+    BOOST_CHECK_EQUAL(sid.get_dst_addr(), (uint32_t)3);
+    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), (uint32_t)4);
 
     sid = "01:02>03:10";
-    BOOST_CHECK_EQUAL(sid.get_src_addr(), 1);
-    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), 2);
-    BOOST_CHECK_EQUAL(sid.get_dst_addr(), 3);
-    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), 16);
+    BOOST_CHECK_EQUAL(sid.get_src_addr(), (uint32_t)1);
+    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), (uint32_t)2);
+    BOOST_CHECK_EQUAL(sid.get_dst_addr(), (uint32_t)3);
+    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), (uint32_t)16);
 
     sid = "01:06/03:10";
-    BOOST_CHECK_EQUAL(sid.get_src_addr(), 1);
-    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), 6);
-    BOOST_CHECK_EQUAL(sid.get_dst_addr(), 3);
-    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), 16);
+    BOOST_CHECK_EQUAL(sid.get_src_addr(), (uint32_t)1);
+    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), (uint32_t)6);
+    BOOST_CHECK_EQUAL(sid.get_dst_addr(), (uint32_t)3);
+    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), (uint32_t)16);
 
     sid = "01:02:04:10";
-    BOOST_CHECK_EQUAL(sid.get_src_addr(), 1);
-    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), 2);
-    BOOST_CHECK_EQUAL(sid.get_dst_addr(), 4);
-    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), 16);
+    BOOST_CHECK_EQUAL(sid.get_src_addr(), (uint32_t)1);
+    BOOST_CHECK_EQUAL(sid.get_src_endpoint(), (uint32_t)2);
+    BOOST_CHECK_EQUAL(sid.get_dst_addr(), (uint32_t)4);
+    BOOST_CHECK_EQUAL(sid.get_dst_endpoint(), (uint32_t)16);
 
     BOOST_REQUIRE_THROW(sid_t fail_sid("foobar"), uhd::value_error);
     BOOST_REQUIRE_THROW(sid_t fail_sid("01:02:03:4"), uhd::value_error);
--- host/tests/sph_recv_test.cpp.orig
+++ host/tests/sph_recv_test.cpp
@@ -675,7 +675,7 @@ BOOST_AUTO_TEST_CASE(test_sph_recv_multi_channel_fragment){
         BOOST_CHECK_EQUAL(metadata.error_code, uhd::rx_metadata_t::ERROR_CODE_NONE);
         BOOST_CHECK(metadata.has_time_spec);
         BOOST_CHECK_TS_CLOSE(metadata.time_spec, uhd::time_spec_t::from_ticks(num_accum_samps, SAMP_RATE));
-        BOOST_CHECK_EQUAL(num_samps_ret, 10);
+        BOOST_CHECK_EQUAL(num_samps_ret, (size_t)10);
         num_accum_samps += num_samps_ret;
 
         if (not metadata.more_fragments) continue;
@@ -685,7 +685,7 @@ BOOST_AUTO_TEST_CASE(test_sph_recv_multi_channel_fragment){
         );
         BOOST_CHECK_EQUAL(metadata.error_code, uhd::rx_metadata_t::ERROR_CODE_NONE);
         BOOST_CHECK(not metadata.more_fragments);
-        BOOST_CHECK_EQUAL(metadata.fragment_offset, 10);
+        BOOST_CHECK_EQUAL(metadata.fragment_offset, (size_t)10);
         BOOST_CHECK(metadata.has_time_spec);
         BOOST_CHECK_TS_CLOSE(metadata.time_spec, uhd::time_spec_t::from_ticks(num_accum_samps, SAMP_RATE));
         BOOST_CHECK_EQUAL(num_samps_ret, i%10);
--- host/tests/sph_send_test.cpp.orig
+++ host/tests/sph_send_test.cpp
@@ -182,7 +182,7 @@ BOOST_AUTO_TEST_CASE(test_sph_send_one_channel_full_buffer_mode){
     for (size_t i = 0; i < NUM_PKTS_TO_TEST; i++){
         std::cout << "data check " << i << std::endl;
         dummy_send_xport.pop_front_packet(ifpi);
-        BOOST_CHECK_EQUAL(ifpi.num_payload_words32, 20);
+        BOOST_CHECK_EQUAL(ifpi.num_payload_words32, (size_t)20);
         BOOST_CHECK(ifpi.has_tsf);
         BOOST_CHECK_EQUAL(ifpi.tsf, num_accum_samps*TICK_RATE/SAMP_RATE);
         BOOST_CHECK_EQUAL(ifpi.sob, i == 0);
--- host/tests/time_spec_test.cpp.orig
+++ host/tests/time_spec_test.cpp
@@ -112,8 +112,8 @@ BOOST_AUTO_TEST_CASE(test_time_large_ticks_to_time_spec)
 
 BOOST_AUTO_TEST_CASE(test_time_error_irrational_rate)
 {
-    static const double rate = 1625e3/6;
-    const long long tick_in = 23423436291667;
+    static const double rate = 1625e3/6.0;
+    const long long tick_in = 23423436291667ll;
     const uhd::time_spec_t ts = uhd::time_spec_t::from_ticks(tick_in, rate);
     const long long tick_out = ts.to_ticks(rate);
     const long long err = tick_in - tick_out;
