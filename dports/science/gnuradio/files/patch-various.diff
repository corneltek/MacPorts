--- gr-audio/lib/osx/circular_buffer.h.orig
+++ gr-audio/lib/osx/circular_buffer.h
@@ -199,9 +199,9 @@ public:
       n_now_I = bufLen_I;
     else if (n_now_I < bufLen_I)
       n_start_I = bufLen_I - n_now_I;
-    bcopy (buf, &(d_buffer[d_writeNdx_I]), n_now_I * sizeof (T));
+    memcpy (&(d_buffer[d_writeNdx_I]), buf, n_now_I * sizeof (T));
     if (n_start_I) {
-      bcopy (&(buf[n_now_I]), d_buffer, n_start_I * sizeof (T));
+      memcpy (d_buffer, &(buf[n_now_I]), n_start_I * sizeof (T));
       d_writeNdx_I = n_start_I;
     } else
       d_writeNdx_I += n_now_I;
@@ -295,9 +295,9 @@ public:
       n_now_I = l_bufLen_I;
     else if (n_now_I < l_bufLen_I)
       n_start_I = l_bufLen_I - n_now_I;
-    bcopy (&(d_buffer[d_readNdx_I]), buf, n_now_I * sizeof (T));
+    memcpy (buf, &(d_buffer[d_readNdx_I]), n_now_I * sizeof (T));
     if (n_start_I) {
-      bcopy (d_buffer, &(buf[n_now_I]), n_start_I * sizeof (T));
+      memcpy (&(buf[n_now_I]), d_buffer, n_start_I * sizeof (T));
       d_readNdx_I = n_start_I;
     } else
       d_readNdx_I += n_now_I;
--- gr-audio/lib/osx/osx_impl.cc.orig
+++ gr-audio/lib/osx/osx_impl.cc
@@ -42,9 +42,9 @@ operator<<
 (std::ostream& s,
  const AudioStreamBasicDescription& asbd)
 {
-  char format_id[5];
-  *((UInt32*)format_id) = asbd.mFormatID;
-  format_id[4] = 0;
+  char format_id[sizeof(asbd.mFormatID)+1];
+  memcpy((void*)(&asbd.mFormatID), format_id, sizeof(asbd.mFormatID));
+  format_id[sizeof(asbd.mFormatID)] = 0;
   s << "  Sample Rate      : " << asbd.mSampleRate << std::endl;
   s << "  Format ID        : " << format_id << std::endl;
   s << "  Format Flags     : " << asbd.mFormatFlags << std::endl;
@@ -166,10 +166,6 @@ find_audio_devices
 
   OSStatus err = noErr;
 
-  // set the default audio device id to "unknown"
-
-  AudioDeviceID d_ad_id = kAudioDeviceUnknown;
-
   // retrieve the size of the array of known audio device IDs
 
   UInt32 prop_size = 0;
--- gr-blocks/lib/multiply_matrix_ff_impl.cc.orig
+++ gr-blocks/lib/multiply_matrix_ff_impl.cc
@@ -141,7 +141,7 @@ namespace gr {
           GR_LOG_ALERT(d_logger, "Invalid message to set A (wrong type).");
           return;
       }
-      if (!pmt::length(A) == d_A.size()) {
+      if (pmt::length(A) != d_A.size()) {
           GR_LOG_ALERT(d_logger, "Invalid message to set A (wrong size).");
           return;
       }
@@ -181,7 +181,7 @@ namespace gr {
     void
     multiply_matrix_ff_impl::set_tag_propagation_policy(gr::block::tag_propagation_policy_t tpp)
     {
-      if (tpp == TPP_SELECT_BY_MATRIX) {
+      if (((int) tpp) == TPP_SELECT_BY_MATRIX) {
         set_tag_propagation_policy(TPP_DONT);
         d_tag_prop_select = true;
       } else {
--- gr-digital/lib/glfsr.cc.orig
+++ gr-digital/lib/glfsr.cc
@@ -59,7 +59,7 @@ namespace gr {
       0x10000002,		// x^29 + x^2 + 1
       0x20000029,		// x^30 + x^4 + x^1 + 1
       0x40000004,		// x^31 + x^3 + 1
-      0x80000057		// x^32 + x^7 + x^5 + x^3 + x^2 + x^1 + 1
+      (int) 0x80000057		// x^32 + x^7 + x^5 + x^3 + x^2 + x^1 + 1
     };
 
     glfsr::~glfsr()
--- gr-fcd/lib/hid/hidmac.c.orig
+++ gr-fcd/lib/hid/hidmac.c
@@ -444,7 +444,6 @@ struct hid_device_info  HID_API_EXPORT *hid_enumerate(unsigned short vendor_id,
 		if ((vendor_id == 0x0 && product_id == 0x0) ||
 		    (vendor_id == dev_vid && product_id == dev_pid)) {
 			struct hid_device_info *tmp;
-			size_t len;
 
 		    	/* VID/PID match. Create the record. */
 			tmp = malloc(sizeof(struct hid_device_info));
@@ -462,7 +461,7 @@ struct hid_device_info  HID_API_EXPORT *hid_enumerate(unsigned short vendor_id,
 
 			/* Fill out the record */
 			cur_dev->next = NULL;
-			len = make_path(dev, cbuf, sizeof(cbuf));
+			(void) make_path(dev, cbuf, sizeof(cbuf));
 			cur_dev->path = strdup(cbuf);
 
 			/* Serial Number */
@@ -709,10 +708,9 @@ hid_device * HID_API_EXPORT hid_open_path(const char *path)
 	CFSetGetValues(device_set, (const void **) device_array);
 	for (i = 0; i < num_devices; i++) {
 		char cbuf[BUF_LEN];
-		size_t len;
 		IOHIDDeviceRef os_dev = device_array[i];
 
-		len = make_path(os_dev, cbuf, sizeof(cbuf));
+		(void) make_path(os_dev, cbuf, sizeof(cbuf));
 		if (!strcmp(cbuf, path)) {
 			// Matched Paths. Open this Device.
 			IOReturn ret = IOHIDDeviceOpen(os_dev, kIOHIDOptionsTypeNone);
--- gr-filter/lib/pfb_channelizer_ccf_impl.cc.orig
+++ gr-filter/lib/pfb_channelizer_ccf_impl.cc
@@ -61,7 +61,7 @@ namespace gr {
       // requirement within a few significant figures.
       const double srate = nfilts / oversample_rate;
       const double rsrate = round(srate);
-      if(fabsf(srate - rsrate) > 0.00001)
+      if(fabs(srate - rsrate) > 0.00001)
 	throw std::invalid_argument("pfb_channelizer: oversample rate must be N/i for i in [1, N]");
 
       set_relative_rate(oversample_rate);
--- gr-pager/lib/flex_modes.cc.orig
+++ gr-pager/lib/flex_modes.cc
@@ -28,11 +28,11 @@ namespace gr {
     const flex_mode_t
     flex_modes[] =
       {
-	{ 0x870C78F3, 1600, 2 },
-	{ 0xB0684F97, 1600, 4 },
-	{ 0x7B1884E7, 3200, 2 },
-	{ 0xDEA0215F, 3200, 4 },
-	{ 0x4C7CB383, 3200, 4 }
+	{ (int32_t) 0x870C78F3, 1600, 2 },
+	{ (int32_t) 0xB0684F97, 1600, 4 },
+	{ (int32_t) 0x7B1884E7, 3200, 2 },
+	{ (int32_t) 0xDEA0215F, 3200, 4 },
+	{ (int32_t) 0x4C7CB383, 3200, 4 }
       };
 
     const int num_flex_modes = sizeof(flex_modes)/sizeof(flex_modes[0]);
--- gr-qtgui/lib/SpectrumGUIClass.cc.orig
+++ gr-qtgui/lib/SpectrumGUIClass.cc
@@ -359,15 +359,17 @@ SpectrumGUIClass::getFFTSizeIndex()
 {
   gr::thread::scoped_lock lock(d_mutex);
   int fftsize = getFFTSize();
+  int rv = 0;
   switch(fftsize) {
-  case(1024): return 0; break;
-  case(2048): return 1; break;
-  case(4096): return 2; break;
-  case(8192): return 3; break;
-  case(16384): return 3; break;
-  case(32768): return 3; break;
-  default: return 0;
+  case(1024): rv = 0; break;
+  case(2048): rv = 1; break;
+  case(4096): rv = 2; break;
+  case(8192): rv = 3; break;
+  case(16384): rv = 3; break;
+  case(32768): rv = 3; break;
+  default: rv = 0; break;
   }
+  return rv;
 }
 
 void
--- volk/include/volk/volk_prefs.h.orig
+++ volk/include/volk/volk_prefs.h
@@ -14,7 +14,8 @@ typedef struct volk_arch_pref
 } volk_arch_pref_t;
 
 ////////////////////////////////////////////////////////////////////////
-// get path to volk_config profiling info
+// get path to volk_config profiling info;
+// returns \0 in the argument on failure.
 ////////////////////////////////////////////////////////////////////////
 VOLK_API void volk_get_config_path(char *);
 
--- volk/kernels/volk/volk_32f_log2_32f.h.orig
+++ volk/kernels/volk/volk_32f_log2_32f.h
@@ -330,3 +330,5 @@ static inline void volk_32f_log2_32f_u_sse4_1(float* bVector, const float* aVect
 #endif /* LV_HAVE_SSE4_1 for unaligned */
 
 #endif /* INCLUDED_volk_32f_log2_32f_u_H */
+
+#undef LOG_POLY_DEGREE
--- volk/kernels/volk/volk_32f_x2_pow_32f.h.orig
+++ volk/kernels/volk/volk_32f_x2_pow_32f.h
@@ -296,3 +296,5 @@ static inline void volk_32f_x2_pow_32f_u_sse4_1(float* cVector, const float* bVe
 #endif /* LV_HAVE_SSE4_1 for unaligned */
 
 #endif /* INCLUDED_volk_32f_x2_log2_32f_u_H */
+
+#undef LOG_POLY_DEGREE
--- volk/kernels/volk/volk_64u_popcnt.h.orig
+++ volk/kernels/volk/volk_64u_popcnt.h
@@ -36,7 +36,7 @@ static inline void volk_64u_popcnt_generic(uint64_t* ret, const uint64_t value)
 
   // This is faster than a lookup table
   //uint32_t retVal = valueVector[0];
-  uint32_t retVal = (uint32_t)(value & 0x00000000FFFFFFFF);
+  uint32_t retVal = (uint32_t)(value & 0x00000000FFFFFFFFull);
 
   retVal = (retVal & 0x55555555) + (retVal >> 1 & 0x55555555);
   retVal = (retVal & 0x33333333) + (retVal >> 2 & 0x33333333);
@@ -46,7 +46,7 @@ static inline void volk_64u_popcnt_generic(uint64_t* ret, const uint64_t value)
   uint64_t retVal64  = retVal;
 
   //retVal = valueVector[1];
-  retVal = (uint32_t)((value & 0xFFFFFFFF00000000) >> 31);
+  retVal = (uint32_t)((value & 0xFFFFFFFF00000000ull) >> 31);
   retVal = (retVal & 0x55555555) + (retVal >> 1 & 0x55555555);
   retVal = (retVal & 0x33333333) + (retVal >> 2 & 0x33333333);
   retVal = (retVal + (retVal >> 4)) & 0x0F0F0F0F;
--- volk/lib/qa_utils.cc.orig
+++ volk/lib/qa_utils.cc
@@ -295,7 +295,7 @@ bool icompare(t *in1, t *in2, unsigned int vlen, unsigned int tol) {
     bool fail = false;
     int print_max_errs = 10;
     for(unsigned int i=0; i<vlen; i++) {
-        if(abs(int(((t *)(in1))[i]) - int(((t *)(in2))[i])) > tol) {
+      if(((unsigned int)abs(int(((t *)(in1))[i]) - int(((t *)(in2))[i]))) > tol) {
             fail=true;
             if(print_max_errs-- > 0) {
                 std::cout << "offset " << i << " in1: " << static_cast<int>(t(((t *)(in1))[i])) << " in2: " << static_cast<int>(t(((t *)(in2))[i])) << std::endl;
--- volk/lib/volk_prefs.c.orig
+++ volk/lib/volk_prefs.c
@@ -9,12 +9,13 @@
 
 void volk_get_config_path(char *path)
 {
+    if (!path) return;
     const char *suffix = "/.volk/volk_config";
     char *home = NULL;
     if (home == NULL) home = getenv("HOME");
     if (home == NULL) home = getenv("APPDATA");
     if (home == NULL){
-        path = NULL;
+        path[0] = 0;
         return;
     }
     strcpy(path, home);
@@ -30,7 +31,7 @@ size_t volk_load_preferences(volk_arch_pref_t **prefs_res)
 
     //get the config path
     volk_get_config_path(path);
-    if (path == NULL) return n_arch_prefs; //no prefs found
+    if (!path[0]) return n_arch_prefs; //no prefs found
     config_file = fopen(path, "r");
     if(!config_file) return n_arch_prefs; //no prefs found
 
