--- texk/tetex/updmap.pl	2011-06-20 16:47:32.000000000 -0400
+++ texk/tetex/updmap.pl	2011-07-14 17:44:02.000000000 -0400
@@ -6,16 +6,10 @@
 # Anyone may freely use, modify, and/or distribute this file, without
 # limitation.
 
-BEGIN {
-  $^W=1;
-  chomp($TEXMFROOT = `kpsewhich -var-value=TEXMFROOT`);
-  unshift (@INC, "$TEXMFROOT/tlpkg");
-}
 
 my $version = '$Id: updmap.pl 23034 2011-06-17 23:44:39Z karl $';
 
 use strict;
-use TeXLive::TLUtils qw(mkdirhier mktexupd win32);
 use Getopt::Long;
 $Getopt::Long::autoabbrev=0;
 Getopt::Long::Configure (qw(ignore_case_always));
@@ -65,6 +59,100 @@
 my $cache = 0; # don't change!
 my $pdftexStripEnc = 0;
 
+# MacPorts: the following are from TLUtils.pm, part of the TeXLive
+# perl package (which we don't install)
+sub mktexupd {
+  my %files;
+  my $mustexist=0;
+
+  my $hash={
+    "add" => sub {     
+      foreach my $file (@_) {
+        $file =~ s|\\|/|g;
+        $files{$file}=1;
+      }
+    },
+    # "reset" => sub { 
+    #    %files=();
+    # },
+    "mustexist" => sub {
+      $mustexist=shift;
+    },
+   "exec" => sub {
+      # check whether files exist
+      if ($mustexist) {
+        foreach my $file (keys %files) {
+          die "File \"$file\" doesn't exist.\n" if (! -f $file);
+        }
+      }
+      my $delim= (&win32)? ';' : ':';
+      my $TEXMFDBS;
+      chomp($TEXMFDBS=`kpsewhich --show-path="ls-R"`);
+
+      my @texmfdbs=split ($delim, "$TEXMFDBS");
+      my %dbs;
+     
+      foreach my $path (keys %files) {
+        foreach my $db (@texmfdbs) {
+          $db=substr($db, -1) if ($db=~m|/$|); # strip leading /
+          if (substr($path, 0, length("$db/")) eq "$db/") {
+            # we appended a / because otherwise "texmf" is recognized as a
+            # substring of "texmf-dist".
+            my $path='./' . substr($path, length("$db/"));
+            my ($dir, $file);
+            $_=$path;
+            ($dir, $file) = m|(.*)/(.*)|;
+            $dbs{$db}{$dir}{$file}=1;
+          }
+        }
+      }
+      foreach my $db (keys %dbs) {
+        if (! -f "$db" || ! -w "$db/ls-R") {
+          &mkdirhier ($db);
+        }
+        open LSR, ">>$db/ls-R";
+        foreach my $dir (keys %{$dbs{$db}}) {
+          print LSR "\n$dir:\n";
+          foreach my $file (keys %{$dbs{$db}{$dir}}) {
+            print LSR "$file\n";
+          }
+        }
+        close LSR;
+      }
+    }
+  };
+  return $hash;
+}
+
+sub mkdirhier {
+  my ($tree,$mode) = @_;
+
+  return if (-d "$tree");
+  my $subdir = "";
+  # win32 is special as usual: we need to separate //servername/ part
+  # from the UNC path, since (! -d //servername/) tests true
+  $subdir = $& if ( win32() && ($tree =~ s!^//[^/]+/!!) );
+
+  my @dirs = split (/\//, $tree);
+  for my $dir (@dirs) {
+    $subdir .= "$dir/";
+    if (! -d $subdir) {
+      if (defined $mode) {
+        mkdir ($subdir, $mode)
+        || die "$0: mkdir($subdir,$mode) failed, goodbye: $!\n";
+      } else {
+        mkdir ($subdir) || die "$0: mkdir($subdir) failed, goodbye: $!\n";
+      }
+    }
+  }
+}
+
+sub win32
+{
+  return 0;
+}
+
+
 # initialize mktexupd
 my $updLSR=&mktexupd();
 $updLSR->{mustexist}(0);
