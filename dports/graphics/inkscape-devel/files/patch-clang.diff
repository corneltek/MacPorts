=== modified file 'src/2geom/sbasis.h'
--- src/2geom/sbasis.h	2012-03-04 20:14:33 +0000
+++ src/2geom/sbasis.h	2013-10-10 21:02:08 +0000
@@ -78,10 +78,18 @@
         return d[i];
     }
     Linear& operator[](unsigned i) { return d.at(i); }
-    Linear const* begin() const { return (Linear const*)&*d.begin();}
-    Linear const* end() const { return (Linear const*)&*d.end();}
-    Linear* begin() { return (Linear*)&*d.begin();}
-    Linear* end() { return (Linear*)&*d.end();}
+	
+    //Linear const* begin() const { return (Linear const*)&*d.begin();}
+    //Linear const* end() const { return (Linear const*)&*d.end();}
+    //Linear* begin() { return (Linear*)&*d.begin();}
+    //Linear* end() { return (Linear*)&*d.end();}
+	
+	std::vector<Linear>::const_iterator begin() const { return d.begin(); }
+	std::vector<Linear>::const_iterator end() const { return d.end(); }
+	
+	std::vector<Linear>::iterator begin() { return d.begin(); }
+	std::vector<Linear>::iterator end() { return d.end(); }
+	
     bool empty() const {return d.empty();}
     Linear &back() {return d.back();}
     Linear const &back() const {return d.back();}
@@ -90,7 +98,11 @@
     void resize(unsigned n, Linear const& l) { d.resize(n, l);}
     void reserve(unsigned n) { d.reserve(n);}
     void clear() {d.clear();}
-    void insert(Linear* before, const Linear* src_begin, const Linear* src_end) { d.insert(std::vector<Linear>::iterator(before), src_begin, src_end);}
+	
+    void insert(std::vector<Linear>::iterator before, std::vector<Linear>::const_iterator src_begin, std::vector<Linear>::const_iterator src_end) {
+		d.insert(before, src_begin, src_end);
+	}
+	
     //void insert(Linear* aa, Linear* bb, Linear* cc} { d.insert(aa, bb, cc);}
     Linear& at(unsigned i) { return d.at(i);}
     //void insert(Linear* before, int& n, Linear const &l) { d.insert(std::vector<Linear>::iterator(before), n, l);}
@@ -291,7 +303,13 @@
 
 inline SBasis truncate(SBasis const &a, unsigned terms) {
     SBasis c;
-    c.insert(c.begin(), a.begin(), a.begin() + std::min(terms, (unsigned)a.size()));
+	
+	std::vector<Linear>::const_iterator e = a.begin();
+	std::advance(e, std::min(terms, (unsigned)a.size()));
+	
+    //c.insert(c.begin(), a.begin(), a.begin() + std::min(terms, (unsigned)a.size()));
+	c.insert(c.begin(), a.begin(), e);
+	
     return c;
 }
 

=== modified file 'src/libnrtype/Layout-TNG-OutIter.cpp'
--- src/libnrtype/Layout-TNG-OutIter.cpp	2012-04-13 23:32:19 +0000
+++ src/libnrtype/Layout-TNG-OutIter.cpp	2013-10-10 21:47:45 +0000
@@ -198,7 +198,23 @@
 
 Layout::iterator Layout::sourceToIterator(void *source_cookie) const
 {
-    return sourceToIterator(source_cookie, Glib::ustring::const_iterator(std::string::const_iterator(NULL)));
+    //return sourceToIterator(source_cookie, Glib::ustring::const_iterator(std::string::const_iterator(NULL)));
+	
+	// simply copied from above... what is an iterator to NULL?
+	unsigned source_index;
+    if (_characters.empty()) return end();
+    for (source_index = 0 ; source_index < _input_stream.size() ; source_index++)
+        if (_input_stream[source_index]->source_cookie == source_cookie) break;
+    if (source_index == _input_stream.size()) return end();
+	
+    unsigned char_index = _sourceToCharacter(source_index);
+    
+    if (_input_stream[source_index]->Type() != TEXT_SOURCE)
+        return iterator(this, char_index);
+	
+    InputStreamTextSource const *text_source = static_cast<InputStreamTextSource const *>(_input_stream[source_index]);
+    //if (text_iterator <= text_source->text_begin) return iterator(this, char_index);
+	return iterator(this, char_index);
 }
 
 Geom::OptRect Layout::glyphBoundingBox(iterator const &it, double *rotation) const
@@ -535,18 +551,23 @@
     *source_cookie = stream_item->source_cookie;
     if (text_iterator && stream_item->Type() == TEXT_SOURCE) {
         InputStreamTextSource const *text_source = static_cast<InputStreamTextSource const *>(stream_item);
-        Glib::ustring::const_iterator text_iter_const = text_source->text_begin;
+        //Glib::ustring::const_iterator text_iter_const = text_source->text_begin;
+        Glib::ustring::iterator text_iter = const_cast<Glib::ustring*>(text_source->text)->begin();
         unsigned char_index = it._char_index;
         unsigned original_input_source_index = _spans[_characters[char_index].in_span].in_input_stream_item;
         // confusing algorithm because the iterator goes forwards while the index goes backwards.
         // It's just that it's faster doing it that way
         while (char_index && _spans[_characters[char_index - 1].in_span].in_input_stream_item == original_input_source_index) {
-            ++text_iter_const;
+            //++text_iter_const;
+            ++text_iter;
             char_index--;
         }
-        text_source->text->begin().base() + (text_iter_const.base() - text_source->text->begin().base());
-        *text_iterator = Glib::ustring::iterator(std::string::iterator(const_cast<char*>(&*text_source->text->begin().base() + (text_iter_const.base() - text_source->text->begin().base()))));
+        //text_source->text->begin().base() + (text_iter_const.base() - text_source->text->begin().base());
+        
+		// FIXME C++11
+		//*text_iterator = Glib::ustring::iterator(std::string::iterator(const_cast<char*>(&*text_source->text->begin().base() + (text_iter_const.base() - text_source->text->begin().base()))));
              // the caller owns the string, so they're going to want a non-const iterator
+        *text_iterator = text_iter;
     }
 }
 

=== modified file 'src/remove-last.h'
--- src/remove-last.h	2010-11-17 02:12:56 +0000
+++ src/remove-last.h	2013-10-10 21:02:08 +0000
@@ -12,8 +12,9 @@
 
     typename vector<T>::reverse_iterator i(find(seq.rbegin(), seq.rend(), elem));
     g_assert( i != seq.rend() );
-    typename vector<T>::iterator ii(&*i);
-    seq.erase(ii);
+    //typename vector<T>::iterator ii(&*i);
+    //seq.erase(ii);
+	seq.erase(i.base());
 }
 
 

=== modified file 'src/sp-item-rm-unsatisfied-cns.cpp'
--- src/sp-item-rm-unsatisfied-cns.cpp	2013-07-23 16:54:03 +0000
+++ src/sp-item-rm-unsatisfied-cns.cpp	2013-10-10 21:02:08 +0000
@@ -24,10 +24,15 @@
         g_assert( snappoint_ix < int(snappoints.size()) );
 
         if (!Geom::are_near(cn.g->getDistanceFrom(snappoints[snappoint_ix].getPoint()), 0, 1e-2)) {
+			
             remove_last(cn.g->attached_items, SPGuideAttachment(&item, cn.snappoint_ix));
-            g_assert( i < item.constraints.size() );
-            vector<SPGuideConstraint>::iterator const ei(&item.constraints[i]);
-            item.constraints.erase(ei);
+            
+			g_assert( i < item.constraints.size() );
+            
+			//vector<SPGuideConstraint>::iterator const ei(&item.constraints[i]);
+            
+			//item.constraints.erase(ei);
+			item.constraints.erase(item.constraints.begin() + i);
         }
     }
 }

=== modified file 'src/trace/siox.cpp'
--- src/trace/siox.cpp	2013-06-12 03:48:35 +0000
+++ src/trace/siox.cpp	2013-10-10 21:02:08 +0000
@@ -11,6 +11,7 @@
 #include <stdarg.h>
 #include <map>
 #include <algorithm>
+#include <cstdlib>
 
 
 namespace org

=== modified file 'src/ui/tool/node.h'
--- src/ui/tool/node.h	2012-07-12 22:10:43 +0000
+++ src/ui/tool/node.h	2013-10-10 21:02:08 +0000
@@ -16,7 +16,13 @@
 #include <iosfwd>
 #include <stdexcept>
 #include <cstddef>
+
+#if __cplusplus >= 201103L
+#include <functional>
+#else
 #include <tr1/functional>
+#endif
+
 #include <boost/enable_shared_from_this.hpp>
 #include <boost/shared_ptr.hpp>
 #include "ui/tool/selectable-control-point.h"
@@ -31,11 +37,13 @@
 }
 }
 
+#if __cplusplus < 201103L
 namespace std {
 namespace tr1 {
 template <typename N> struct hash< Inkscape::UI::NodeIterator<N> >;
 }
 }
+#endif
 
 namespace Inkscape {
 namespace UI {

