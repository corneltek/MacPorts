--- ../src/mac/menuitem.cpp	Sat Feb  7 13:24:02 2004
+++ ../src/mac/menuitem.cpp.new	Sat Feb  7 13:20:36 2004
@@ -34,12 +34,6 @@
 // wxMenuItem
 // ----------------------------------------------------------------------------
 
-//
-// Helper Functions to get Mac Menus the way they should be ;-)
-//
-
-void wxMacCtoPString(const char* theCString, Str255 thePString);
-
 // remove inappropriate characters, if useShortcuts is false, the ampersand will not auto-generate a mac menu-shortcut
 
 int wxMenuItem::MacBuildMenuString(StringPtr outMacItemText, SInt16 *outMacShortcutChar , UInt8 *outMacModifiers , const char *inItemText , bool useShortcuts )
@@ -175,6 +169,8 @@
 	return 0 ;
 }
 
+
+//
 // ctor & dtor
 // -----------
 
@@ -186,114 +182,181 @@
                        wxMenu *pSubMenu) 
           : wxMenuItemBase(pParentMenu, id, text, strHelp, kind, pSubMenu)
 {
-    // VZ: what about translations?? (FIXME)
-    if ( m_text ==  "E&xit"  ||m_text == "Exit"  ||m_text.Left(5) == "Exit\t" || m_text.Left(6) == "E&xit\t" )
+    // In other languages there is no difference in naming the Exit/Quit menu item between MacOS and Windows guidelines
+    // therefore these item must not be translated
+    if ( wxStripMenuCodes(m_text).Upper() ==  wxT("EXIT") )
     {
-        m_text = "Quit\tCtrl+Q" ;
+        m_text =wxT("Quit\tCtrl+Q") ;
     }
+
+    m_radioGroup.start = -1;
+    m_isRadioGroupStart = FALSE;
 }
 
 wxMenuItem::~wxMenuItem() 
 {
 }
 
-bool wxMenuItem::IsChecked() const
+// change item state
+// -----------------
+
+void wxMenuItem::SetBitmap(const wxBitmap& bitmap)
 {
-    return wxMenuItemBase::IsChecked() ;
+      m_bitmap = bitmap;
+      UpdateItemBitmap() ;
 }
 
-wxString wxMenuItem::GetLabel() const
+void wxMenuItem::UpdateItemBitmap()
 {
-    return wxStripMenuCodes(m_text);
-}
+    if ( !m_parentMenu )
+        return ;
 
-// accelerators
-// ------------
+    MenuHandle mhandle = MAC_WXHMENU(m_parentMenu->GetHMenu()) ;
+    MenuItemIndex index = m_parentMenu->MacGetIndexFromItem( this ) ;
+    if( mhandle == NULL || index == 0)
+        return ;
 
-#if wxUSE_ACCEL
+    if ( m_bitmap.Ok() )
+    {
+        ControlButtonContentInfo info ;
+        wxMacCreateBitmapButton( &info , m_bitmap , kControlContentCIconHandle ) ;
+        if ( info.contentType != kControlNoContent )
+        {
+            if ( info.contentType == kControlContentCIconHandle )
+                SetMenuItemIconHandle( mhandle , index ,
+                    kMenuColorIconType , (Handle) info.u.cIconHandle ) ;
+        }
 
-wxAcceleratorEntry *wxMenuItem::GetAccel() const
-{
-    return wxGetAccelFromString(GetText());
+    }
 }
 
-#endif // wxUSE_ACCEL
-
-// misc
-// ----
+void wxMenuItem::UpdateItemStatus()
+{
+    if ( !m_parentMenu )
+        return ;
 
-/*
+#if TARGET_CARBON
+    if ( UMAGetSystemVersion() >= 0x1000 && GetId() == wxApp::s_macPreferencesMenuItemId)
+    {
+        if ( !IsEnabled() )
+            DisableMenuCommand( NULL , kHICommandPreferences ) ;
+        else
+            EnableMenuCommand( NULL , kHICommandPreferences ) ;
+    }
+    if ( UMAGetSystemVersion() >= 0x1000 && GetId() == wxApp::s_macExitMenuItemId)
+    {
+        if ( !IsEnabled() )
+            DisableMenuCommand( NULL , kHICommandQuit ) ;
+        else
+            EnableMenuCommand( NULL , kHICommandQuit ) ;
+    }
+#endif
+    {
+        MenuHandle mhandle = MAC_WXHMENU(m_parentMenu->GetHMenu()) ;
+        MenuItemIndex index = m_parentMenu->MacGetIndexFromItem( this ) ;
+        if( mhandle == NULL || index == 0)
+            return ;
+
+          UMAEnableMenuItem( mhandle , index , m_isEnabled ) ;
+          if ( IsCheckable() && IsChecked() )
+            ::SetItemMark( mhandle , index , 0x12 ) ; // checkmark
+        else
+            ::SetItemMark( mhandle , index , 0 ) ; // no mark
+
+           UMASetMenuItemText( mhandle , index , m_text ) ;
+           wxAcceleratorEntry *entry = wxGetAccelFromString( m_text ) ;
+        UMASetMenuItemShortcut( mhandle , index , entry ) ;
+        delete entry ;
+    }
+}
 
-// delete the sub menu
-void wxMenuItem::DeleteSubMenu()
+void wxMenuItem::UpdateItemText()
 {
-  wxASSERT( m_subMenu != NULL );
+    if ( !m_parentMenu )
+        return ;
 
-  delete m_subMenu;
-  m_subMenu = NULL;
+    MenuHandle mhandle = MAC_WXHMENU(m_parentMenu->GetHMenu()) ;
+    MenuItemIndex index = m_parentMenu->MacGetIndexFromItem( this ) ;
+    if( mhandle == NULL || index == 0)
+        return ;
+
+       UMASetMenuItemText( mhandle , index , m_text ) ;
+       wxAcceleratorEntry *entry = wxGetAccelFromString( m_text ) ;
+    UMASetMenuItemShortcut( mhandle , index , entry ) ;
+    delete entry ;
 }
 
-*/
-
-// change item state
-// -----------------
 
 void wxMenuItem::Enable(bool bDoEnable)
 {
-  if ( m_isEnabled != bDoEnable ) {
-    if ( m_subMenu == NULL ) 
-    {     
-    	// normal menu item
-	    if ( MAC_WXHMENU(m_parentMenu->GetHMenu()) )
-	    {
-	   	 	int index = m_parentMenu->MacGetIndexFromItem( this ) ;
-	   	 	if ( index >= 1 )
+    if ( m_isEnabled != bDoEnable )
 	   	 	{
-	   	 		if ( bDoEnable )
-	   	 			UMAEnableMenuItem( MAC_WXHMENU(m_parentMenu->GetHMenu()) , index ) ;
-	   	 		else
-	   	 			UMADisableMenuItem( MAC_WXHMENU(m_parentMenu->GetHMenu()) , index ) ;
-	   	 	}
+        wxMenuItemBase::Enable( bDoEnable ) ;
+        UpdateItemStatus() ;
 	    }
-    }
-    else                            
-    {
-  		// submenu
-	    if ( MAC_WXHMENU(m_parentMenu->GetHMenu()) )
-	    {
-	   	 	int index = m_parentMenu->MacGetIndexFromItem( this ) ;
-	   	 	if ( index >= 1 )
+}
+void wxMenuItem::UncheckRadio()
+{
+    if ( m_isChecked )
 	   	 	{
-	   	 		if ( bDoEnable )
-	   	 			UMAEnableMenuItem( MAC_WXHMENU(m_parentMenu->GetHMenu()) , index ) ;
-	   	 		else
-	   	 			UMADisableMenuItem( MAC_WXHMENU(m_parentMenu->GetHMenu()) , index ) ;
-	   	 	}
-	    }
+        wxMenuItemBase::Check( false ) ;
+        UpdateItemStatus() ;
     }
-
-    m_isEnabled = bDoEnable;
-  }
 }
 
 void wxMenuItem::Check(bool bDoCheck)
 {
-  wxCHECK_RET( IsCheckable(), "only checkable items may be checked" );
+    wxCHECK_RET( IsCheckable(), wxT("only checkable items may be checked") );
 
   if ( m_isChecked != bDoCheck ) 
-  {
-    m_isChecked = bDoCheck;
-   	if ( MAC_WXHMENU(m_parentMenu->GetHMenu()) )
     {
-   	 	int index = m_parentMenu->MacGetIndexFromItem( this ) ;
-   	 	if ( index >= 1 )
+        if ( GetKind() == wxITEM_RADIO )
    	 	{
    	 		if ( bDoCheck )
-					::SetItemMark( MAC_WXHMENU(m_parentMenu->GetHMenu()) , index , 0x12 ) ; // checkmark
-				else
- 					::SetItemMark( MAC_WXHMENU(m_parentMenu->GetHMenu()) , index , 0 ) ; // no mark
+            {
+                wxMenuItemBase::Check( bDoCheck ) ;
+                UpdateItemStatus() ;
+
+                // get the index of this item in the menu
+                const wxMenuItemList& items = m_parentMenu->GetMenuItems();
+                int pos = items.IndexOf(this);
+                wxCHECK_RET( pos != wxNOT_FOUND,
+                             _T("menuitem not found in the menu items list?") );
+
+                // get the radio group range
+                int start,
+                    end;
+
+                if ( m_isRadioGroupStart )
+                {
+                    // we already have all information we need
+                    start = pos;
+                    end = m_radioGroup.end;
+                }
+                else // next radio group item
+                {
+                    // get the radio group end from the start item
+                    start = m_radioGroup.start;
+                    end = items.Item(start)->GetData()->m_radioGroup.end;
+                }
+
+                // also uncheck all the other items in this radio group
+                wxMenuItemList::Node *node = items.Item(start);
+                for ( int n = start; n <= end && node; n++ )
+                {
+                    if ( n != pos )
+                    {
+                        ((wxMenuItem*)node->GetData())->UncheckRadio();
+                    }
+                    node = node->GetNext();
+                }
   	 	}
   	}
+        else
+        {
+            wxMenuItemBase::Check( bDoCheck ) ;
+            UpdateItemStatus() ;
+        }
   }
 }
 
@@ -304,29 +367,32 @@
         return;
 
     wxMenuItemBase::SetText(text);
-//    OWNER_DRAWN_ONLY( wxOwnerDrawn::SetName(text) );
 
-    wxCHECK_RET( m_parentMenu && m_parentMenu->GetHMenu(), wxT("menuitem without menu") );
-   	if ( MAC_WXHMENU(m_parentMenu->GetHMenu()) )
-    {
-   	 	int index = m_parentMenu->MacGetIndexFromItem( this ) ;
-   	 	if ( index >= 1 )
-   	 	{
- 			Str255 label;
-			MacBuildMenuString( label , NULL , NULL , text ,false);
-   	 		::SetMenuItemText( MAC_WXHMENU(m_parentMenu->GetHMenu()) , index , label ) ; // checkmark
-  	 	}
-  	}
+    UpdateItemText() ;
+}
 
-#if wxUSE_ACCEL
-    m_parentMenu->UpdateAccel(this);
-#endif // wxUSE_ACCEL
+// radio group stuff
+// -----------------
 
+void wxMenuItem::SetAsRadioGroupStart()
+{
+    m_isRadioGroupStart = TRUE;
 }
-void wxMenuItem::SetCheckable(bool checkable)
+
+void wxMenuItem::SetRadioGroupStart(int start)
 {
-    wxMenuItemBase::SetCheckable(checkable);
-   // OWNER_DRAWN_ONLY( wxOwnerDrawn::SetCheckable(checkable) );
+    wxASSERT_MSG( !m_isRadioGroupStart,
+                  _T("should only be called for the next radio items") );
+
+    m_radioGroup.start = start;
+}
+
+void wxMenuItem::SetRadioGroupEnd(int end)
+{
+    wxASSERT_MSG( m_isRadioGroupStart,
+                  _T("should only be called for the first radio item") );
+
+    m_radioGroup.end = end;
 }
 
 // ----------------------------------------------------------------------------
