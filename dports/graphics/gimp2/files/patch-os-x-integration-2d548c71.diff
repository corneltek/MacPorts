From 2d548c71df2e62bd345e02f50e5a3c1b08a1cf1e Mon Sep 17 00:00:00 2001
From: Daniel Sabo <DanielSabo@gmail.com>
Date: Sat, 09 Nov 2013 20:00:55 +0000
Subject: app: Port to gtk-mac-integration

Replace deprecated Carbon APIs with Cocoa.

Includes code by:
Simone Karin Lehmann
Michael Natterer
Daniel Sabo

(cherry picked from commit e56344294c90e1ba97de5c134b50c4c522f0808f)
---
diff --git a/app/Makefile.am b/app/Makefile.am
index a4ef552..a2a1bde 100644
--- app/Makefile.am
+++ app/Makefile.am
@@ -90,7 +90,7 @@ gimp_2_8_SOURCES = $(libapp_sources) main.c
 
 
 if PLATFORM_OSX
-framework_carbon = -framework Carbon
+framework_cocoa = -framework Cocoa
 endif
 
 if OS_WIN32
@@ -186,7 +186,7 @@ gimpconsoleldadd = \
 gimp_2_8_LDFLAGS = \
 	$(AM_LDFLAGS)		\
 	$(win32_ldflags)	\
-	$(framework_carbon)
+	$(framework_cocoa)
 
 gimp_2_8_LDADD = \
 	gui/libappgui.a		\
diff --git a/app/gui/Makefile.am b/app/gui/Makefile.am
index 10f9c32..d2b07d5 100644
--- app/gui/Makefile.am
+++ app/gui/Makefile.am
@@ -1,17 +1,23 @@
 ## Process this file with automake to produce Makefile.in
 
+if PLATFORM_OSX
+xobjective_c = "-xobjective-c"
+endif
+
 AM_CPPFLAGS = \
 	-DG_LOG_DOMAIN=\"Gimp-GUI\"	\
 	-DGIMP_COMMAND=\"@GIMP_COMMAND@\"
 
 INCLUDES = \
-	-I$(top_builddir)	\
-	-I$(top_srcdir)		\
-	-I$(top_builddir)/app	\
-	-I$(top_srcdir)/app	\
-	$(GEGL_CFLAGS)		\
-	$(GTK_CFLAGS)		\
-	$(DBUS_GLIB_CFLAGS)	\
+	-I$(top_builddir)		\
+	-I$(top_srcdir)			\
+	-I$(top_builddir)/app		\
+	-I$(top_srcdir)/app		\
+	$(xobjective_c)			\
+	$(GEGL_CFLAGS)			\
+	$(GTK_CFLAGS)			\
+	$(DBUS_GLIB_CFLAGS)		\
+	$(GTK_MAC_INTEGRATION_CFLAGS)	\
 	-I$(includedir)
 
 noinst_LIBRARIES = libappgui.a
@@ -37,9 +43,7 @@ libappgui_a_sources = \
 	splash.c		\
 	splash.h		\
 	themes.c		\
-	themes.h		\
-	ige-mac-menu.c		\
-	ige-mac-menu.h
+	themes.h
 
 libappgui_a_built_sources = gimpdbusservice-glue.h 
 
diff --git a/app/gui/gui-unique.c b/app/gui/gui-unique.c
index 122d0f6..5218d78 100644
--- app/gui/gui-unique.c
+++ app/gui/gui-unique.c
@@ -24,8 +24,8 @@
 #endif
 
 #ifdef GDK_WINDOWING_QUARTZ
-#include <Carbon/Carbon.h>
-#include <sys/param.h>
+#import <AppKit/AppKit.h>
+#include <gtkosxapplication.h>
 #endif
 
 #if HAVE_DBUS_GLIB
@@ -63,11 +63,16 @@ static HWND             proxy_window     = NULL;
 #endif
 
 #ifdef GDK_WINDOWING_QUARTZ
-static void  gui_unique_mac_init (Gimp *gimp);
-static void  gui_unique_mac_exit (void);
+static void gui_unique_quartz_init (Gimp *gimp);
+static void gui_unique_quartz_exit (void);
 
-static Gimp            *unique_gimp      = NULL;
-AEEventHandlerUPP       open_document_callback_proc;
+@interface GimpAppleEventHandler : NSObject {}
+- (void) handleEvent:(NSAppleEventDescriptor *) inEvent
+        andReplyWith:(NSAppleEventDescriptor *) replyEvent;
+@end
+
+static Gimp                   *unique_gimp   = NULL;
+static GimpAppleEventHandler  *event_handler = NULL;
 #endif
 
 
@@ -76,13 +81,11 @@ gui_unique_init (Gimp *gimp)
 {
 #ifdef G_OS_WIN32
   gui_unique_win32_init (gimp);
-#elif HAVE_DBUS_GLIB
+#elif defined (GDK_WINDOWING_QUARTZ)
+  gui_unique_quartz_init (gimp);
+#elif defined (HAVE_DBUS_GLIB)
   gui_dbus_service_init (gimp);
 #endif
-
-#ifdef GDK_WINDOWING_QUARTZ
-  gui_unique_mac_init (gimp);
-#endif
 }
 
 void
@@ -90,13 +93,11 @@ gui_unique_exit (void)
 {
 #ifdef G_OS_WIN32
   gui_unique_win32_exit ();
-#elif HAVE_DBUS_GLIB
+#elif defined (GDK_WINDOWING_QUARTZ)
+  gui_unique_quartz_exit ();
+#elif defined (HAVE_DBUS_GLIB)
   gui_dbus_service_exit ();
 #endif
-
-#ifdef GDK_WINDOWING_QUARTZ
-  gui_unique_mac_exit ();
-#endif
 }
 
 
@@ -280,7 +281,7 @@ gui_unique_win32_exit (void)
 #ifdef GDK_WINDOWING_QUARTZ
 
 static gboolean
-gui_unique_mac_idle_open (gchar *data)
+gui_unique_quartz_idle_open (gchar *path)
 {
   /*  We want to be called again later in case that GIMP is not fully
    *  started yet.
@@ -288,94 +289,126 @@ gui_unique_mac_idle_open (gchar *data)
   if (! gimp_is_restored (unique_gimp))
     return TRUE;
 
-  if (data)
+  if (path)
     {
-      file_open_from_command_line (unique_gimp, data, FALSE);
+      file_open_from_command_line (unique_gimp, path, FALSE);
     }
 
   return FALSE;
 }
 
-/* Handle the kAEOpenDocuments Apple events. This will register
- * an idle source callback for each filename in the event.
- */
-static pascal OSErr
-gui_unique_mac_open_documents (const AppleEvent *inAppleEvent,
-                               AppleEvent       *outAppleEvent,
-                               long              handlerRefcon)
+static gboolean
+gui_unique_quartz_nsopen_file_callback (GtkosxApplication *osx_app,
+                                        gchar             *path,
+                                        gpointer           user_data)
 {
-  OSStatus    status;
-  AEDescList  documents;
-  gchar       path[MAXPATHLEN];
-
-  status = AEGetParamDesc (inAppleEvent,
-                           keyDirectObject, typeAEList,
-                           &documents);
-  if (status == noErr)
-    {
-      long count = 0;
-      int  i;
+  gchar    *callback_path;
+  GSource  *source;
+  GClosure *closure;
 
-      AECountItems (&documents, &count);
+  callback_path = g_strdup (path);
 
-      for (i = 0; i < count; i++)
-        {
-          FSRef    ref;
-          gchar    *callback_path;
-          GSource  *source;
-          GClosure *closure;
+  closure = g_cclosure_new (G_CALLBACK (gui_unique_quartz_idle_open),
+                            (gpointer) callback_path,
+                            (GClosureNotify) g_free);
 
-          status = AEGetNthPtr (&documents, i + 1, typeFSRef,
-                                0, 0, &ref, sizeof (ref),
-                                0);
-          if (status != noErr)
-            continue;
+  g_object_watch_closure (G_OBJECT (unique_gimp), closure);
 
-          FSRefMakePath (&ref, (UInt8 *) path, MAXPATHLEN);
+  source = g_idle_source_new ();
 
-          callback_path = g_strdup (path);
+  g_source_set_priority (source, G_PRIORITY_LOW);
+  g_source_set_closure (source, closure);
+  g_source_attach (source, NULL);
+  g_source_unref (source);
 
-          closure = g_cclosure_new (G_CALLBACK (gui_unique_mac_idle_open),
-                                    (gpointer) callback_path,
-                                    (GClosureNotify) g_free);
+  return TRUE;
+}
 
-          g_object_watch_closure (G_OBJECT (unique_gimp), closure);
+@implementation GimpAppleEventHandler
+- (void) handleEvent: (NSAppleEventDescriptor *) inEvent
+        andReplyWith: (NSAppleEventDescriptor *) replyEvent
+{
+  const gchar       *path;
+  NSURL             *url;
+  NSAutoreleasePool *urlpool;
+  NSInteger          count;
+  NSInteger          i;
 
-          source = g_idle_source_new ();
-          g_source_set_priority (source, G_PRIORITY_LOW);
-          g_source_set_closure (source, closure);
-          g_source_attach (source, NULL);
-          g_source_unref (source);
-        }
+  urlpool = [[NSAutoreleasePool alloc] init];
+
+  count = [inEvent numberOfItems];
+
+  for (i = 1; i <= count; i++)
+    {
+      gchar    *callback_path;
+      GSource  *source;
+      GClosure *closure;
+
+      url = [NSURL URLWithString: [[inEvent descriptorAtIndex: i] stringValue]];
+      path = [[url path] UTF8String];
+
+      callback_path = g_strdup (path);
+      closure = g_cclosure_new (G_CALLBACK (gui_unique_quartz_idle_open),
+                                (gpointer) callback_path,
+                                (GClosureNotify) g_free);
+
+      g_object_watch_closure (G_OBJECT (unique_gimp), closure);
+
+      source = g_idle_source_new ();
+      g_source_set_priority (source, G_PRIORITY_LOW);
+      g_source_set_closure (source, closure);
+      g_source_attach (source, NULL);
+      g_source_unref (source);
     }
 
-    return status;
+  [urlpool drain];
 }
+@end
 
 static void
-gui_unique_mac_init (Gimp *gimp)
+gui_unique_quartz_init (Gimp *gimp)
 {
+  GtkosxApplication *osx_app;
+
   g_return_if_fail (GIMP_IS_GIMP (gimp));
   g_return_if_fail (unique_gimp == NULL);
 
+  osx_app = gtkosx_application_get ();
+
   unique_gimp = gimp;
 
-  open_document_callback_proc = NewAEEventHandlerUPP(gui_unique_mac_open_documents);
+  g_signal_connect (osx_app, "NSApplicationOpenFile",
+                    G_CALLBACK (gui_unique_quartz_nsopen_file_callback),
+                    gimp);
+
+  /* Using the event handler is a hack, it is neccesary becuase
+   * gtkosx_application will drop the file open events if any
+   * event processing is done before gtkosx_application_ready is
+   * called, which we unfortuantly can't avoid doing right now.
+   */
+  event_handler = [[GimpAppleEventHandler alloc] init];
 
-  AEInstallEventHandler (kCoreEventClass, kAEOpenDocuments,
-                         open_document_callback_proc,
-                         0L, TRUE);
+  [[NSAppleEventManager sharedAppleEventManager]
+      setEventHandler: event_handler
+          andSelector: @selector (handleEvent: andReplyWith:)
+        forEventClass: kCoreEventClass
+           andEventID: kAEOpenDocuments];
 }
 
 static void
-gui_unique_mac_exit (void)
+gui_unique_quartz_exit (void)
 {
+  g_return_if_fail (GIMP_IS_GIMP (unique_gimp));
+
   unique_gimp = NULL;
 
-  AERemoveEventHandler (kCoreEventClass, kAEOpenDocuments,
-                        open_document_callback_proc, TRUE);
+  [[NSAppleEventManager sharedAppleEventManager]
+      removeEventHandlerForEventClass: kCoreEventClass
+                           andEventID: kAEOpenDocuments];
+
+  [event_handler release];
 
-  DisposeAEEventHandlerUPP(open_document_callback_proc);
+  event_handler = NULL;
 }
 
 #endif /* GDK_WINDOWING_QUARTZ */
diff --git a/app/gui/gui.c b/app/gui/gui.c
index f3ad117..faaa91b 100644
--- app/gui/gui.c
+++ app/gui/gui.c
@@ -77,7 +77,7 @@
 #include "splash.h"
 #include "themes.h"
 #ifdef GDK_WINDOWING_QUARTZ
-#include "ige-mac-menu.h"
+#include <gtkosxapplication.h>
 #endif /* GDK_WINDOWING_QUARTZ */
 
 #include "gimp-intl.h"
@@ -427,17 +427,26 @@ gui_restore_callback (Gimp               *gimp,
 
 #ifdef GDK_WINDOWING_QUARTZ
 static void
-gui_add_to_app_menu (GimpUIManager   *ui_manager,
-                     IgeMacMenuGroup *group,
-                     const gchar     *action_path,
-                     const gchar     *label)
+gui_add_to_app_menu (GimpUIManager     *ui_manager,
+                     GtkosxApplication *osx_app,
+                     const gchar       *action_path,
+                     gint               index)
 {
   GtkWidget *item;
 
   item = gtk_ui_manager_get_widget (GTK_UI_MANAGER (ui_manager), action_path);
 
   if (GTK_IS_MENU_ITEM (item))
-    ige_mac_menu_add_app_menu_item (group, GTK_MENU_ITEM (item), label);
+    gtkosx_application_insert_app_menu_item (osx_app, GTK_WIDGET (item), index);
+}
+
+static gboolean
+gui_quartz_quit_callback (GtkosxApplication *osx_app,
+                          GimpUIManager     *ui_manager)
+{
+  gimp_ui_manager_activate_action (ui_manager, "file", "file-quit");
+
+  return TRUE;
 }
 #endif
 
@@ -468,47 +477,50 @@ gui_restore_after_callback (Gimp               *gimp,
 
 #ifdef GDK_WINDOWING_QUARTZ
   {
-    IgeMacMenuGroup *group;
-    GtkWidget       *menu;
-    GtkWidget       *item;
+    GtkosxApplication *osx_app;
+    GtkWidget         *menu;
+    GtkWidget         *item;
 
-    menu = gtk_ui_manager_get_widget (GTK_UI_MANAGER (image_ui_manager),
-				      "/dummy-menubar/image-popup");
+    osx_app = gtkosx_application_get ();
 
+    menu = gtk_ui_manager_get_widget (GTK_UI_MANAGER (image_ui_manager),
+                                      "/image-menubar");
     if (GTK_IS_MENU_ITEM (menu))
       menu = gtk_menu_item_get_submenu (GTK_MENU_ITEM (menu));
 
-    ige_mac_menu_set_menu_bar (GTK_MENU_SHELL (menu));
+    gtkosx_application_set_menu_bar (osx_app, GTK_MENU_SHELL (menu));
+    gtkosx_application_set_use_quartz_accelerators (osx_app, FALSE);
 
-    item = gtk_ui_manager_get_widget (GTK_UI_MANAGER (image_ui_manager),
-                                      "/dummy-menubar/image-popup/File/file-quit");
-    if (GTK_IS_MENU_ITEM (item))
-      ige_mac_menu_set_quit_menu_item (GTK_MENU_ITEM (item));
+    gui_add_to_app_menu (image_ui_manager, osx_app,
+                         "/image-menubar/Help/dialogs-about", 0);
+
+#define PREFERENCES "/image-menubar/Edit/Preferences/"
 
-    /*  the about group  */
-    group = ige_mac_menu_add_app_menu_group ();
+    gui_add_to_app_menu (image_ui_manager, osx_app,
+                         PREFERENCES "dialogs-preferences", 2);
+    gui_add_to_app_menu (image_ui_manager, osx_app,
+                         PREFERENCES "dialogs-input-devices", 3);
+    gui_add_to_app_menu (image_ui_manager, osx_app,
+                         PREFERENCES "dialogs-keyboard-shortcuts", 4);
+    gui_add_to_app_menu (image_ui_manager, osx_app,
+                         PREFERENCES "dialogs-module-dialog", 5);
+    gui_add_to_app_menu (image_ui_manager, osx_app,
+                         PREFERENCES "plug-in-unit-editor", 6);
 
-    gui_add_to_app_menu (image_ui_manager, group,
-                         "/dummy-menubar/image-popup/Help/dialogs-about",
-                         _("About GIMP"));
+#undef PREFERENCES
 
-    /*  the preferences group  */
-    group = ige_mac_menu_add_app_menu_group ();
+    item = gtk_separator_menu_item_new ();
+    gtkosx_application_insert_app_menu_item (osx_app, item, 7);
 
-#define PREFERENCES "/dummy-menubar/image-popup/Edit/Preferences/"
+    item = gtk_ui_manager_get_widget (GTK_UI_MANAGER (image_ui_manager),
+                                      "/image-menubar/File/file-quit");
+    gtk_widget_hide (item);
 
-    gui_add_to_app_menu (image_ui_manager, group,
-                         PREFERENCES "dialogs-preferences", NULL);
-    gui_add_to_app_menu (image_ui_manager, group,
-                         PREFERENCES "dialogs-input-devices", NULL);
-    gui_add_to_app_menu (image_ui_manager, group,
-                         PREFERENCES "dialogs-keyboard-shortcuts", NULL);
-    gui_add_to_app_menu (image_ui_manager, group,
-                         PREFERENCES "dialogs-module-dialog", NULL);
-    gui_add_to_app_menu (image_ui_manager, group,
-                         PREFERENCES "plug-in-unit-editor", NULL);
+    g_signal_connect (osx_app, "NSApplicationBlockTermination",
+                      G_CALLBACK (gui_quartz_quit_callback),
+                      image_ui_manager);
 
-#undef PREFERENCES
+    gtkosx_application_ready (osx_app);
   }
 #endif /* GDK_WINDOWING_QUARTZ */
 
diff --git a/app/gui/ige-mac-menu.c b/app/gui/ige-mac-menu.c
deleted file mode 100644
index c352f8f..0000000
--- app/gui/ige-mac-menu.c
+++ /dev/null
@@ -1,988 +0,0 @@
-/* GTK+ Integration for the Mac OS X Menubar.
- *
- * Copyright (C) 2007 Pioneer Research Center USA, Inc.
- * Copyright (C) 2007 Imendio AB
- *
- * For further information, see:
- * http://developer.imendio.com/projects/gtk-macosx/menubar
- *
- * This library is free software: you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; version 2.1
- * of the License.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library.  If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#include "config.h"
-
-#include <gtk/gtk.h>
-
-#ifdef GDK_WINDOWING_QUARTZ
-
-#include <gdk/gdkkeysyms.h>
-#include <Carbon/Carbon.h>
-
-#include "ige-mac-menu.h"
-
-/* TODO
- *
- * - Adding a standard Window menu (Minimize etc)?
- * - Sync reordering items? Does that work now?
- * - Create on demand? (can this be done with gtk+? ie fill in menu
-     items when the menu is opened)
- * - Figure out what to do per app/window...
- *
- */
-
-#define IGE_QUARTZ_MENU_CREATOR 'IGEC'
-#define IGE_QUARTZ_ITEM_WIDGET  'IWID'
-
-
-static void   sync_menu_shell (GtkMenuShell *menu_shell,
-			       MenuRef       carbon_menu,
-			       gboolean      toplevel,
-			       gboolean      debug);
-
-
-/*
- * utility functions
- */
-
-static GtkWidget *
-find_menu_label (GtkWidget *widget)
-{
-  GtkWidget *label = NULL;
-
-  if (GTK_IS_LABEL (widget))
-    return widget;
-
-  if (GTK_IS_CONTAINER (widget))
-    {
-      GList *children;
-      GList *l;
-
-      children = gtk_container_get_children (GTK_CONTAINER (widget));
-
-      for (l = children; l; l = l->next)
-	{
-	  label = find_menu_label (l->data);
-	  if (label)
-	    break;
-	}
-
-      g_list_free (children);
-    }
-
-  return label;
-}
-
-static const gchar *
-get_menu_label_text (GtkWidget  *menu_item,
-		     GtkWidget **label)
-{
-  GtkWidget *my_label;
-
-  my_label = find_menu_label (menu_item);
-  if (label)
-    *label = my_label;
-
-  if (my_label)
-    return gtk_label_get_text (GTK_LABEL (my_label));
-
-  return NULL;
-}
-
-static gboolean
-accel_find_func (GtkAccelKey *key,
-		 GClosure    *closure,
-		 gpointer     data)
-{
-  return (GClosure *) data == closure;
-}
-
-
-/*
- * CarbonMenu functions
- */
-
-typedef struct
-{
-  MenuRef menu;
-  guint   toplevel : 1;
-} CarbonMenu;
-
-static GQuark carbon_menu_quark = 0;
-
-static CarbonMenu *
-carbon_menu_new (void)
-{
-  return g_slice_new0 (CarbonMenu);
-}
-
-static void
-carbon_menu_free (CarbonMenu *menu)
-{
-  g_slice_free (CarbonMenu, menu);
-}
-
-static CarbonMenu *
-carbon_menu_get (GtkWidget *widget)
-{
-  return g_object_get_qdata (G_OBJECT (widget), carbon_menu_quark);
-}
-
-static void
-carbon_menu_connect (GtkWidget *menu,
-		     MenuRef    menuRef,
-                     gboolean   toplevel)
-{
-  CarbonMenu *carbon_menu = carbon_menu_get (menu);
-
-  if (!carbon_menu)
-    {
-      carbon_menu = carbon_menu_new ();
-
-      g_object_set_qdata_full (G_OBJECT (menu), carbon_menu_quark,
-			       carbon_menu,
-			       (GDestroyNotify) carbon_menu_free);
-    }
-
-  carbon_menu->menu     = menuRef;
-  carbon_menu->toplevel = toplevel;
-}
-
-
-/*
- * CarbonMenuItem functions
- */
-
-typedef struct
-{
-  MenuRef        menu;
-  MenuItemIndex  index;
-  MenuRef        submenu;
-  GClosure      *accel_closure;
-} CarbonMenuItem;
-
-static GQuark carbon_menu_item_quark = 0;
-
-static CarbonMenuItem *
-carbon_menu_item_new (void)
-{
-  return g_slice_new0 (CarbonMenuItem);
-}
-
-static void
-carbon_menu_item_free (CarbonMenuItem *menu_item)
-{
-  if (menu_item->accel_closure)
-    g_closure_unref (menu_item->accel_closure);
-
-  g_slice_free (CarbonMenuItem, menu_item);
-}
-
-static CarbonMenuItem *
-carbon_menu_item_get (GtkWidget *widget)
-{
-  return g_object_get_qdata (G_OBJECT (widget), carbon_menu_item_quark);
-}
-
-static void
-carbon_menu_item_update_state (CarbonMenuItem *carbon_item,
-			       GtkWidget      *widget)
-{
-  gboolean sensitive;
-  gboolean visible;
-  UInt32   set_attrs = 0;
-  UInt32   clear_attrs = 0;
-
-  g_object_get (widget,
-                "sensitive", &sensitive,
-                "visible",   &visible,
-                NULL);
-
-  if (!sensitive)
-    set_attrs |= kMenuItemAttrDisabled;
-  else
-    clear_attrs |= kMenuItemAttrDisabled;
-
-  if (!visible)
-    set_attrs |= kMenuItemAttrHidden;
-  else
-    clear_attrs |= kMenuItemAttrHidden;
-
-  ChangeMenuItemAttributes (carbon_item->menu, carbon_item->index,
-                            set_attrs, clear_attrs);
-}
-
-static void
-carbon_menu_item_update_active (CarbonMenuItem *carbon_item,
-				GtkWidget      *widget)
-{
-  gboolean active;
-
-  g_object_get (widget,
-                "active", &active,
-                NULL);
-
-  CheckMenuItem (carbon_item->menu, carbon_item->index,
-		 active);
-}
-
-static void
-carbon_menu_item_update_submenu (CarbonMenuItem *carbon_item,
-				 GtkWidget      *widget)
-{
-  GtkWidget *submenu;
-
-  submenu = gtk_menu_item_get_submenu (GTK_MENU_ITEM (widget));
-
-  if (submenu)
-    {
-      const gchar *label_text;
-      CFStringRef  cfstr = NULL;
-
-      label_text = get_menu_label_text (widget, NULL);
-      if (label_text)
-        cfstr = CFStringCreateWithCString (NULL, label_text,
-					   kCFStringEncodingUTF8);
-
-      CreateNewMenu (0, 0, &carbon_item->submenu);
-      SetMenuTitleWithCFString (carbon_item->submenu, cfstr);
-      SetMenuItemHierarchicalMenu (carbon_item->menu, carbon_item->index,
-				   carbon_item->submenu);
-
-      sync_menu_shell (GTK_MENU_SHELL (submenu), carbon_item->submenu, FALSE, FALSE);
-
-      if (cfstr)
-	CFRelease (cfstr);
-    }
-  else
-    {
-      SetMenuItemHierarchicalMenu (carbon_item->menu, carbon_item->index,
-				   NULL);
-      carbon_item->submenu = NULL;
-    }
-}
-
-static void
-carbon_menu_item_update_label (CarbonMenuItem *carbon_item,
-			       GtkWidget      *widget)
-{
-  const gchar *label_text;
-  CFStringRef  cfstr = NULL;
-
-  label_text = get_menu_label_text (widget, NULL);
-  if (label_text)
-    cfstr = CFStringCreateWithCString (NULL, label_text,
-				       kCFStringEncodingUTF8);
-
-  SetMenuItemTextWithCFString (carbon_item->menu, carbon_item->index,
-			       cfstr);
-
-  if (cfstr)
-    CFRelease (cfstr);
-}
-
-static void
-carbon_menu_item_update_accelerator (CarbonMenuItem *carbon_item,
-				     GtkWidget      *widget)
-{
-  GtkWidget *label;
-
-  get_menu_label_text (widget, &label);
-
-  if (GTK_IS_ACCEL_LABEL (label))
-    {
-      GClosure      *closure;
-
-      g_object_get (label, "accel-closure", &closure, NULL);
-
-      if (closure)
-	{
-	  GtkAccelGroup *group;
-	  GtkAccelKey   *key;
-
-	  group = gtk_accel_group_from_accel_closure (closure);
-	  key = gtk_accel_group_find (group, accel_find_func, closure);
-
-	  g_closure_unref (closure);
-
-	  if (key            &&
-	      key->accel_key &&
-	      key->accel_flags & GTK_ACCEL_VISIBLE)
-	    {
-	      GdkDisplay      *display = gtk_widget_get_display (widget);
-	      GdkKeymap       *keymap  = gdk_keymap_get_for_display (display);
-	      GdkKeymapKey    *keys;
-	      gint             n_keys;
-
-	      if (gdk_keymap_get_entries_for_keyval (keymap, key->accel_key,
-						     &keys, &n_keys))
-		{
-		  UInt8 modifiers = 0;
-
-		  SetMenuItemCommandKey (carbon_item->menu, carbon_item->index,
-					 true, keys[0].keycode);
-
-		  g_free (keys);
-
-		  if (key->accel_mods)
-		    {
-		      if (key->accel_mods & GDK_SHIFT_MASK)
-			modifiers |= kMenuShiftModifier;
-
-		      if (key->accel_mods & GDK_MOD1_MASK)
-			modifiers |= kMenuOptionModifier;
-		    }
-
-		  if (!(key->accel_mods & GDK_META_MASK))
-		    {
-		      modifiers |= kMenuNoCommandModifier;
-		    }
-
-		  SetMenuItemModifiers (carbon_item->menu, carbon_item->index,
-					modifiers);
-
-		  return;
-		}
-	    }
-	}
-    }
-
-  /*  otherwise, clear the menu shortcut  */
-  SetMenuItemModifiers (carbon_item->menu, carbon_item->index,
-			kMenuNoModifiers | kMenuNoCommandModifier);
-  ChangeMenuItemAttributes (carbon_item->menu, carbon_item->index,
-			    0, kMenuItemAttrUseVirtualKey);
-  SetMenuItemCommandKey (carbon_item->menu, carbon_item->index,
-			 false, 0);
-}
-
-static void
-carbon_menu_item_accel_changed (GtkAccelGroup   *accel_group,
-				guint            keyval,
-				GdkModifierType  modifier,
-				GClosure        *accel_closure,
-				GtkWidget       *widget)
-{
-  CarbonMenuItem *carbon_item = carbon_menu_item_get (widget);
-  GtkWidget      *label;
-
-  get_menu_label_text (widget, &label);
-
-  if (GTK_IS_ACCEL_LABEL (label))
-    {
-      GClosure *closure;
-
-      g_object_get (label, "accel-closure", &closure, NULL);
-
-      if (closure)
-	{
-	  if (closure == accel_closure)
-	    carbon_menu_item_update_accelerator (carbon_item, widget);
-
-	  g_closure_unref (closure);
-	}
-    }
-}
-
-static void
-carbon_menu_item_update_accel_closure (CarbonMenuItem *carbon_item,
-				       GtkWidget      *widget)
-{
-  GtkAccelGroup *group;
-  GtkWidget     *label;
-
-  get_menu_label_text (widget, &label);
-
-  if (carbon_item->accel_closure)
-    {
-      group = gtk_accel_group_from_accel_closure (carbon_item->accel_closure);
-
-      g_signal_handlers_disconnect_by_func (group,
-					    carbon_menu_item_accel_changed,
-					    widget);
-
-      g_closure_unref (carbon_item->accel_closure);
-      carbon_item->accel_closure = NULL;
-    }
-
-  if (GTK_IS_ACCEL_LABEL (label))
-    g_object_get (label, "accel-closure", &carbon_item->accel_closure, NULL);
-
-  if (carbon_item->accel_closure)
-    {
-      group = gtk_accel_group_from_accel_closure (carbon_item->accel_closure);
-
-      g_signal_connect_object (group, "accel-changed",
-			       G_CALLBACK (carbon_menu_item_accel_changed),
-			       widget, 0);
-    }
-
-  carbon_menu_item_update_accelerator (carbon_item, widget);
-}
-
-static void
-carbon_menu_item_notify (GObject        *object,
-			 GParamSpec     *pspec,
-			 CarbonMenuItem *carbon_item)
-{
-  if (!strcmp (pspec->name, "sensitive") ||
-      !strcmp (pspec->name, "visible"))
-    {
-      carbon_menu_item_update_state (carbon_item, GTK_WIDGET (object));
-    }
-  else if (!strcmp (pspec->name, "active"))
-    {
-      carbon_menu_item_update_active (carbon_item, GTK_WIDGET (object));
-    }
-  else if (!strcmp (pspec->name, "submenu"))
-    {
-      carbon_menu_item_update_submenu (carbon_item, GTK_WIDGET (object));
-    }
-}
-
-static void
-carbon_menu_item_notify_label (GObject    *object,
-			       GParamSpec *pspec,
-			       gpointer    data)
-{
-  CarbonMenuItem *carbon_item = carbon_menu_item_get (GTK_WIDGET (object));
-
-  if (!strcmp (pspec->name, "label"))
-    {
-      carbon_menu_item_update_label (carbon_item,
-				     GTK_WIDGET (object));
-    }
-  else if (!strcmp (pspec->name, "accel-closure"))
-    {
-      carbon_menu_item_update_accel_closure (carbon_item,
-					     GTK_WIDGET (object));
-    }
-}
-
-static CarbonMenuItem *
-carbon_menu_item_connect (GtkWidget     *menu_item,
-			  GtkWidget     *label,
-			  MenuRef        menu,
-			  MenuItemIndex  index)
-{
-  CarbonMenuItem *carbon_item = carbon_menu_item_get (menu_item);
-
-  if (!carbon_item)
-    {
-      carbon_item = carbon_menu_item_new ();
-
-      g_object_set_qdata_full (G_OBJECT (menu_item), carbon_menu_item_quark,
-			       carbon_item,
-			       (GDestroyNotify) carbon_menu_item_free);
-
-      g_signal_connect (menu_item, "notify",
-                        G_CALLBACK (carbon_menu_item_notify),
-                        carbon_item);
-
-      if (label)
-	g_signal_connect_swapped (label, "notify::label",
-				  G_CALLBACK (carbon_menu_item_notify_label),
-				  menu_item);
-    }
-
-  carbon_item->menu  = menu;
-  carbon_item->index = index;
-
-  return carbon_item;
-}
-
-static gboolean
-menu_event_activate_callback (GtkMenuItem *widget)
-{
-  gtk_menu_item_activate (GTK_MENU_ITEM  (widget));
-
-  return FALSE;
-}
-
-/*
- * carbon event handler
- */
-
-static OSStatus
-menu_event_handler_func (EventHandlerCallRef  event_handler_call_ref,
-			 EventRef             event_ref,
-			 void                *data)
-{
-  UInt32  event_class = GetEventClass (event_ref);
-  UInt32  event_kind = GetEventKind (event_ref);
-  MenuRef menu_ref;
-
-  switch (event_class)
-    {
-    case kEventClassCommand:
-      /* This is called when activating (is that the right GTK+ term?)
-       * a menu item.
-       */
-      if (event_kind == kEventCommandProcess)
-	{
-	  HICommand command;
-	  OSStatus  err;
-
-	  /*g_printerr ("Menu: kEventClassCommand/kEventCommandProcess\n");*/
-
-	  err = GetEventParameter (event_ref, kEventParamDirectObject,
-				   typeHICommand, 0,
-				   sizeof (command), 0, &command);
-
-	  if (err == noErr)
-	    {
-	      GtkWidget *widget = NULL;
-
-	      /* Get any GtkWidget associated with the item. */
-	      err = GetMenuItemProperty (command.menu.menuRef,
-					 command.menu.menuItemIndex,
-					 IGE_QUARTZ_MENU_CREATOR,
-					 IGE_QUARTZ_ITEM_WIDGET,
-					 sizeof (widget), 0, &widget);
-	      if (err == noErr && GTK_IS_WIDGET (widget))
-		{
-                  GSource  *source;
-                  GClosure *closure;
-
-                  closure = g_cclosure_new (G_CALLBACK (menu_event_activate_callback),
-                                            widget, NULL);
-
-                  g_object_watch_closure (G_OBJECT (widget), closure);
-
-                  source = g_idle_source_new ();
-                  g_source_set_priority (source, G_PRIORITY_HIGH);
-                  g_source_set_closure (source, closure);
-                  g_source_attach (source, NULL);
-                  g_source_unref (source);
-
-		  return noErr;
-		}
-	    }
-	}
-      break;
-
-    case kEventClassMenu:
-      GetEventParameter (event_ref,
-			 kEventParamDirectObject,
-			 typeMenuRef,
-			 NULL,
-			 sizeof (menu_ref),
-			 NULL,
-			 &menu_ref);
-
-      switch (event_kind)
-	{
-	case kEventMenuTargetItem:
-	  /* This is called when an item is selected (what is the
-	   * GTK+ term? prelight?)
-	   */
-	  /*g_printerr ("kEventClassMenu/kEventMenuTargetItem\n");*/
-	  break;
-
-	case kEventMenuOpening:
-	  /* Is it possible to dynamically build the menu here? We
-	   * can at least set visibility/sensitivity.
-	   */
-	  /*g_printerr ("kEventClassMenu/kEventMenuOpening\n");*/
-	  break;
-
-	case kEventMenuClosed:
-	  /*g_printerr ("kEventClassMenu/kEventMenuClosed\n");*/
-	  break;
-
-	default:
-	  break;
-	}
-
-      break;
-
-    default:
-      break;
-    }
-
-  return CallNextEventHandler (event_handler_call_ref, event_ref);
-}
-
-static void
-setup_menu_event_handler (void)
-{
-  static gboolean is_setup = FALSE;
-
-  EventHandlerUPP menu_event_handler_upp;
-  EventHandlerRef menu_event_handler_ref;
-  const EventTypeSpec menu_events[] = {
-    { kEventClassCommand, kEventCommandProcess },
-    { kEventClassMenu, kEventMenuTargetItem },
-    { kEventClassMenu, kEventMenuOpening },
-    { kEventClassMenu, kEventMenuClosed }
-  };
-
-  if (is_setup)
-    return;
-
-  /* FIXME: We might have to install one per window? */
-
-  menu_event_handler_upp = NewEventHandlerUPP (menu_event_handler_func);
-  InstallEventHandler (GetApplicationEventTarget (), menu_event_handler_upp,
-		       GetEventTypeCount (menu_events), menu_events, 0,
-		       &menu_event_handler_ref);
-
-#if 0
-  /* FIXME: Remove the handler with: */
-  RemoveEventHandler(menu_event_handler_ref);
-  DisposeEventHandlerUPP(menu_event_handler_upp);
-#endif
-
-  is_setup = TRUE;
-}
-
-static void
-sync_menu_shell (GtkMenuShell *menu_shell,
-                 MenuRef       carbon_menu,
-		 gboolean      toplevel,
-		 gboolean      debug)
-{
-  GList         *children;
-  GList         *l;
-  MenuItemIndex  carbon_index = 1;
-
-  if (debug)
-    g_printerr ("%s: syncing shell %p\n", G_STRFUNC, menu_shell);
-
-  carbon_menu_connect (GTK_WIDGET (menu_shell), carbon_menu, toplevel);
-
-  children = gtk_container_get_children (GTK_CONTAINER (menu_shell));
-
-  for (l = children; l; l = l->next)
-    {
-      GtkWidget      *menu_item = l->data;
-      CarbonMenuItem *carbon_item;
-
-      if (GTK_IS_TEAROFF_MENU_ITEM (menu_item))
-	continue;
-
-      if (toplevel && g_object_get_data (G_OBJECT (menu_item),
-					 "gtk-empty-menu-item"))
-	continue;
-
-      carbon_item = carbon_menu_item_get (menu_item);
-
-      if (debug)
-	g_printerr ("%s: carbon_item %d for menu_item %d (%s, %s)\n",
-		    G_STRFUNC, carbon_item ? carbon_item->index : -1,
-		    carbon_index, get_menu_label_text (menu_item, NULL),
-		    g_type_name (G_TYPE_FROM_INSTANCE (menu_item)));
-
-      if (carbon_item && carbon_item->index != carbon_index)
-	{
-	  if (debug)
-	    g_printerr ("%s:   -> not matching, deleting\n", G_STRFUNC);
-
-	  DeleteMenuItem (carbon_item->menu, carbon_index);
-	  carbon_item = NULL;
-	}
-
-      if (!carbon_item)
-	{
-	  GtkWidget          *label      = NULL;
-	  const gchar        *label_text;
-	  CFStringRef         cfstr      = NULL;
-	  MenuItemAttributes  attributes = 0;
-
-	  if (debug)
-	    g_printerr ("%s:   -> creating new\n", G_STRFUNC);
-
-	  label_text = get_menu_label_text (menu_item, &label);
-	  if (label_text)
-	    cfstr = CFStringCreateWithCString (NULL, label_text,
-					       kCFStringEncodingUTF8);
-
-	  if (GTK_IS_SEPARATOR_MENU_ITEM (menu_item))
-	    attributes |= kMenuItemAttrSeparator;
-
-	  if (!gtk_widget_is_sensitive (menu_item))
-	    attributes |= kMenuItemAttrDisabled;
-
-	  if (!gtk_widget_get_visible (menu_item))
-	    attributes |= kMenuItemAttrHidden;
-
-	  InsertMenuItemTextWithCFString (carbon_menu, cfstr,
-					  carbon_index - 1,
-					  attributes, 0);
-	  SetMenuItemProperty (carbon_menu, carbon_index,
-			       IGE_QUARTZ_MENU_CREATOR,
-			       IGE_QUARTZ_ITEM_WIDGET,
-			       sizeof (menu_item), &menu_item);
-
-	  if (cfstr)
-	    CFRelease (cfstr);
-
-	  carbon_item = carbon_menu_item_connect (menu_item, label,
-						  carbon_menu,
-						  carbon_index);
-
-	  if (GTK_IS_CHECK_MENU_ITEM (menu_item))
-	    carbon_menu_item_update_active (carbon_item, menu_item);
-
-	  carbon_menu_item_update_accel_closure (carbon_item, menu_item);
-
-	  if (gtk_menu_item_get_submenu (GTK_MENU_ITEM (menu_item)))
-	    carbon_menu_item_update_submenu (carbon_item, menu_item);
-	}
-
-      carbon_index++;
-    }
-
-  g_list_free (children);
-}
-
-static gulong emission_hook_id    = 0;
-static gint   emission_hook_count = 0;
-
-static gboolean
-parent_set_emission_hook (GSignalInvocationHint *ihint,
-			  guint                  n_param_values,
-			  const GValue          *param_values,
-			  gpointer               data)
-{
-  GtkWidget *instance = g_value_get_object (param_values);
-
-  if (GTK_IS_MENU_ITEM (instance))
-    {
-      GtkWidget *previous_parent = g_value_get_object (param_values + 1);
-      GtkWidget *menu_shell      = NULL;
-
-      if (GTK_IS_MENU_SHELL (previous_parent))
-	{
-	  menu_shell = previous_parent;
-        }
-      else
-      {
-        GtkWidget *parent;
-
-        parent = gtk_widget_get_parent (instance);
-
-        if (GTK_IS_MENU_SHELL (parent))
-	  {
-	    menu_shell = parent;
-	  }
-      }
-
-      if (menu_shell)
-        {
-	  CarbonMenu *carbon_menu = carbon_menu_get (menu_shell);
-
-	  if (carbon_menu)
-	    {
-#if 0
-	      g_printerr ("%s: item %s %p (%s, %s)\n", G_STRFUNC,
-			  previous_parent ? "removed from" : "added to",
-			  menu_shell,
-			  get_menu_label_text (instance, NULL),
-			  g_type_name (G_TYPE_FROM_INSTANCE (instance)));
-#endif
-
-	      sync_menu_shell (GTK_MENU_SHELL (menu_shell),
-			       carbon_menu->menu,
-			       carbon_menu->toplevel,
-			       FALSE);
-	    }
-        }
-    }
-
-  return TRUE;
-}
-
-static void
-parent_set_emission_hook_remove (GtkWidget *widget,
-				 gpointer   data)
-{
-  emission_hook_count--;
-
-  if (emission_hook_count > 0)
-    return;
-
-  g_signal_remove_emission_hook (g_signal_lookup ("parent-set",
-						  GTK_TYPE_WIDGET),
-				 emission_hook_id);
-  emission_hook_id = 0;
-}
-
-
-/*
- * public functions
- */
-
-void
-ige_mac_menu_set_menu_bar (GtkMenuShell *menu_shell)
-{
-  CarbonMenu *current_menu;
-  MenuRef     carbon_menubar;
-
-  g_return_if_fail (GTK_IS_MENU_SHELL (menu_shell));
-
-  if (carbon_menu_quark == 0)
-    carbon_menu_quark = g_quark_from_static_string ("CarbonMenu");
-
-  if (carbon_menu_item_quark == 0)
-    carbon_menu_item_quark = g_quark_from_static_string ("CarbonMenuItem");
-
-  current_menu = carbon_menu_get (GTK_WIDGET (menu_shell));
-  if (current_menu)
-    {
-      SetRootMenu (current_menu->menu);
-      return;
-    }
-
-  CreateNewMenu (0 /*id*/, 0 /*options*/, &carbon_menubar);
-  SetRootMenu (carbon_menubar);
-
-  setup_menu_event_handler ();
-
-  if (emission_hook_id == 0)
-    {
-      emission_hook_id =
-        g_signal_add_emission_hook (g_signal_lookup ("parent-set",
-                                                     GTK_TYPE_WIDGET),
-                                    0,
-                                    parent_set_emission_hook,
-                                    NULL, NULL);
-    }
-
-  emission_hook_count++;
-
-  g_signal_connect (menu_shell, "destroy",
-		    G_CALLBACK (parent_set_emission_hook_remove),
-		    NULL);
-
-  sync_menu_shell (menu_shell, carbon_menubar, TRUE, FALSE);
-}
-
-void
-ige_mac_menu_set_quit_menu_item (GtkMenuItem *menu_item)
-{
-  MenuRef       appmenu;
-  MenuItemIndex index;
-
-  g_return_if_fail (GTK_IS_MENU_ITEM (menu_item));
-
-  setup_menu_event_handler ();
-
-  if (GetIndMenuItemWithCommandID (NULL, kHICommandQuit, 1,
-                                   &appmenu, &index) == noErr)
-    {
-      SetMenuItemCommandID (appmenu, index, 0);
-      SetMenuItemProperty (appmenu, index,
-                           IGE_QUARTZ_MENU_CREATOR,
-                           IGE_QUARTZ_ITEM_WIDGET,
-                           sizeof (menu_item), &menu_item);
-
-      gtk_widget_hide (GTK_WIDGET (menu_item));
-    }
-}
-
-
-struct _IgeMacMenuGroup
-{
-  GList *items;
-};
-
-static GList *app_menu_groups = NULL;
-
-IgeMacMenuGroup *
-ige_mac_menu_add_app_menu_group (void)
-{
-  IgeMacMenuGroup *group = g_slice_new0 (IgeMacMenuGroup);
-
-  app_menu_groups = g_list_append (app_menu_groups, group);
-
-  return group;
-}
-
-void
-ige_mac_menu_add_app_menu_item (IgeMacMenuGroup *group,
-				GtkMenuItem     *menu_item,
-				const gchar     *label)
-{
-  MenuRef  appmenu;
-  GList   *list;
-  gint     index = 0;
-
-  g_return_if_fail (group != NULL);
-  g_return_if_fail (GTK_IS_MENU_ITEM (menu_item));
-
-  setup_menu_event_handler ();
-
-  if (GetIndMenuItemWithCommandID (NULL, kHICommandHide, 1,
-                                   &appmenu, NULL) != noErr)
-    {
-      g_warning ("%s: retrieving app menu failed",
-		 G_STRFUNC);
-      return;
-    }
-
-  for (list = app_menu_groups; list; list = g_list_next (list))
-    {
-      IgeMacMenuGroup *list_group = list->data;
-
-      index += g_list_length (list_group->items);
-
-      /*  adjust index for the separator between groups, but not
-       *  before the first group
-       */
-      if (list_group->items && list->prev)
-	index++;
-
-      if (group == list_group)
-	{
-	  CFStringRef cfstr;
-
-	  /*  add a separator before adding the first item, but not
-	   *  for the first group
-	   */
-	  if (!group->items && list->prev)
-	    {
-	      InsertMenuItemTextWithCFString (appmenu, NULL, index,
-					      kMenuItemAttrSeparator, 0);
-	      index++;
-	    }
-
-	  if (!label)
-	    label = get_menu_label_text (GTK_WIDGET (menu_item), NULL);
-
-	  cfstr = CFStringCreateWithCString (NULL, label,
-					     kCFStringEncodingUTF8);
-
-	  InsertMenuItemTextWithCFString (appmenu, cfstr, index, 0, 0);
-	  SetMenuItemProperty (appmenu, index + 1,
-			       IGE_QUARTZ_MENU_CREATOR,
-			       IGE_QUARTZ_ITEM_WIDGET,
-			       sizeof (menu_item), &menu_item);
-
-	  CFRelease (cfstr);
-
-	  gtk_widget_hide (GTK_WIDGET (menu_item));
-
-	  group->items = g_list_append (group->items, menu_item);
-
-	  return;
-	}
-    }
-
-  if (!list)
-    g_warning ("%s: app menu group %p does not exist",
-	       G_STRFUNC, group);
-}
-
-#endif /* GDK_WINDOWING_QUARTZ */
diff --git a/app/gui/ige-mac-menu.h b/app/gui/ige-mac-menu.h
deleted file mode 100644
index b7def85..0000000
--- app/gui/ige-mac-menu.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/* GTK+ Integration for the Mac OS X Menubar.
- *
- * Copyright (C) 2007 Pioneer Research Center USA, Inc.
- * Copyright (C) 2007 Imendio AB
- *
- * For further information, see:
- * http://developer.imendio.com/projects/gtk-macosx/menubar
- *
- * This library is free software: you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; version 2.1
- * of the License.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library.  If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#ifndef __IGE_MAC_MENU_H__
-#define __IGE_MAC_MENU_H__
-
-#include <gtk/gtk.h>
-
-G_BEGIN_DECLS
-
-typedef struct _IgeMacMenuGroup IgeMacMenuGroup;
-
-void              ige_mac_menu_set_menu_bar       (GtkMenuShell    *menu_shell);
-void              ige_mac_menu_set_quit_menu_item (GtkMenuItem     *menu_item);
-
-IgeMacMenuGroup * ige_mac_menu_add_app_menu_group (void);
-void              ige_mac_menu_add_app_menu_item  (IgeMacMenuGroup *group,
-						   GtkMenuItem     *menu_item,
-						   const gchar     *label);
-
-G_END_DECLS
-
-#endif /* __IGE_MAC_MENU_H__ */
diff --git a/configure.ac b/configure.ac
index 712f30f..038b5e6 100644
--- configure.ac
+++ configure.ac
@@ -64,6 +64,7 @@ m4_define([exif_required_version], [0.6.15])
 m4_define([lcms1_required_version], [1.16])
 m4_define([lcms2_required_version], [2.2])
 m4_define([libpng_required_version], [1.2.37])
+m4_define([gtk_mac_integration_required_version], [1.0.1])
 
 
 AC_INIT([GIMP], [gimp_version],
@@ -1843,6 +1844,14 @@ if test "x$enable_python" != xno; then
 fi
 AM_CONDITIONAL(BUILD_PYTHON, test "x$enable_python" != xno)
 
+####################################
+# Check for GTK Mac Integration
+####################################
+
+if test "x$platform_osx" != xno; then
+  PKG_CHECK_MODULES(GTK_MAC_INTEGRATION, gtk-mac-integration >= gtk_mac_integration_required_version)
+fi
+
 
 #########################################
 # Check whether Script-Fu should be built
--
cgit v0.9.2
