=== modified file 'src/color-profile.cpp'
--- src/color-profile.cpp	2013-12-10 12:44:19 +0000
+++ src/color-profile.cpp	2013-12-15 00:47:56 +0000
@@ -980,7 +980,7 @@
         }
         nameStr = Glib::ustring(data.begin(), data.end());
     }
-    if (nameStr.empty()) {
+    if (nameStr.empty() || !g_utf8_validate(nameStr.c_str(), -1, NULL)) {
         nameStr = _("(invalid UTF-8 string)");
     }
 #endif

=== modified file 'src/gc-core.h'
--- src/gc-core.h	2011-12-08 22:05:10 +0000
+++ src/gc-core.h	2014-01-21 06:52:09 +0000
@@ -57,7 +57,7 @@
                                            CleanupFunc *old_func,
                                            void **old_data);
     int (*general_register_disappearing_link)(void **p_ptr,
-                                              void *base);
+                                              void const *base);
     int (*unregister_disappearing_link)(void **p_ptr);
     std::size_t (*get_heap_size)();
     std::size_t (*get_free_bytes)();

=== modified file 'src/gc.cpp'
--- src/gc.cpp	2011-12-08 22:05:10 +0000
+++ src/gc.cpp	2014-01-21 06:52:09 +0000
@@ -70,9 +70,13 @@
     return base + debug_base_fixup();
 }
 
-int debug_general_register_disappearing_link(void **p_ptr, void *base) {
-    char *real_base=reinterpret_cast<char *>(base) - debug_base_fixup();
+int debug_general_register_disappearing_link(void **p_ptr, void const *base) {
+    char const *real_base = reinterpret_cast<char const *>(base) - debug_base_fixup();
+#if (GC_MAJOR_VERSION >= 7 && GC_MINOR_VERSION >= 4)
     return GC_general_register_disappearing_link(p_ptr, real_base);
+#else // compatibility with older Boehm GC versions
+    return GC_general_register_disappearing_link(p_ptr, const_cast<char *>(real_base));
+#endif
 }
 
 void dummy_do_init() {}
@@ -90,7 +94,7 @@
     }
 }
 
-int dummy_general_register_disappearing_link(void **, void *) { return false; }
+int dummy_general_register_disappearing_link(void **, void const *) { return false; }
 
 int dummy_unregister_disappearing_link(void **/*link*/) { return false; }
 
@@ -112,7 +116,11 @@
     &GC_malloc_atomic_uncollectable,
     &GC_base,
     &GC_register_finalizer_ignore_self,
-    &GC_general_register_disappearing_link,
+#if (GC_MAJOR_VERSION >= 7 && GC_MINOR_VERSION >= 4)
+     &GC_general_register_disappearing_link,
+#else // compatibility with older Boehm GC versions
+    (int (*)(void**, const void*))(&GC_general_register_disappearing_link),
+#endif
     &GC_unregister_disappearing_link,
     &GC_get_heap_size,
     &GC_get_free_bytes,
@@ -202,7 +210,7 @@
     die_because_not_initialized();
 }
 
-int stub_general_register_disappearing_link(void **, void *) {
+int stub_general_register_disappearing_link(void **, void const *) {
     die_because_not_initialized();
     return 0;
 }

=== modified file 'src/main.cpp'
--- src/main.cpp	2011-12-08 22:05:10 +0000
+++ src/main.cpp	2014-01-21 06:52:09 +0000
@@ -520,6 +520,9 @@
     } else {
         printf("python not found\n\n");
     }*/
+	
+	// fix bug #950781
+	SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX);
 
     g_free(python);
     g_free(scripts);

=== modified file 'src/preferences.cpp'
--- src/preferences.cpp	2009-11-29 15:33:18 +0000
+++ src/preferences.cpp	2014-01-21 06:52:09 +0000
@@ -629,6 +629,9 @@
     // No longer necessary, can cause problems with input devices which have a dot in the name
     // g_assert( pref_key.find('.') == Glib::ustring::npos );
 
+    if (_prefs_doc == NULL){
+        return NULL;
+    }
     Inkscape::XML::Node *node = _prefs_doc->root();
     Inkscape::XML::Node *child = NULL;
     gchar **splits = g_strsplit(pref_key.c_str(), "/", 0);

=== modified file 'src/ui/tool/multi-path-manipulator.cpp'
--- src/ui/tool/multi-path-manipulator.cpp	2013-12-10 12:44:18 +0000
+++ src/ui/tool/multi-path-manipulator.cpp	2013-12-12 16:04:06 +0000
@@ -333,18 +333,21 @@
 
 void MultiPathManipulator::insertNodes()
 {
+    if (_selection.empty()) return;
     invokeForAll(&PathManipulator::insertNodes);
     _done(_("Add nodes"));
 }
 
 void MultiPathManipulator::duplicateNodes()
 {
+    if (_selection.empty()) return;
     invokeForAll(&PathManipulator::duplicateNodes);
     _done(_("Duplicate nodes"));
 }
 
 void MultiPathManipulator::joinNodes()
 {
+    if (_selection.empty()) return;
     invokeForAll(&PathManipulator::hideDragPoint);
     // Node join has two parts. In the first one we join two subpaths by fusing endpoints
     // into one. In the second we fuse nodes in each subpath.
@@ -422,6 +425,7 @@
 /** Join selected endpoints to create segments. */
 void MultiPathManipulator::joinSegments()
 {
+    if (_selection.empty()) return;
     IterPairList joins;
     find_join_iterators(_selection, joins);
 
@@ -454,6 +458,7 @@
 
 void MultiPathManipulator::alignNodes(Geom::Dim2 d)
 {
+    if (_selection.empty()) return;
     _selection.align(d);
     if (d == Geom::X) {
         _done("Align nodes to a horizontal line");
@@ -464,6 +469,7 @@
 
 void MultiPathManipulator::distributeNodes(Geom::Dim2 d)
 {
+    if (_selection.empty()) return;
     _selection.distribute(d);
     if (d == Geom::X) {
         _done("Distrubute nodes horizontally");
@@ -706,7 +712,7 @@
         case GDK_u:
         case GDK_U:
             if (held_only_shift(event->key)) {
-                // Shift+L - make segments curves
+                // Shift+U - make segments curves
                 setSegmentType(SEGMENT_CUBIC_BEZIER);
                 return true;
             }

=== modified file 'src/widgets/toolbox.cpp'
--- src/widgets/toolbox.cpp	2011-05-21 23:22:03 +0000
+++ src/widgets/toolbox.cpp	2013-12-12 16:04:06 +0000
@@ -3769,7 +3769,7 @@
     GtkAdjustment *adj;
 
     // fixme: make settable
-    gdouble rev = 5;
+    gdouble rev = 3;
     gdouble exp = 1.0;
     gdouble t0 = 0.0;
 

