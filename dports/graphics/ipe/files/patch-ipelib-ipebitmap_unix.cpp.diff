--- ipelib/ipebitmap_unix.cpp.orig	2015-12-23 04:02:26.000000000 +0100
+++ ipelib/ipebitmap_unix.cpp	2015-12-23 04:03:35.000000000 +0100
@@ -32,64 +32,13 @@
 
 #include <png.h>
 
-#ifdef __APPLE__
-#include <CoreGraphics.h>
-#else
 #include <csetjmp>
 #include <jpeglib.h>
-#endif
 
 using namespace ipe;
 
 // --------------------------------------------------------------------
 
-#ifdef __APPLE__
-
-bool dctDecode(Buffer dctData, Buffer pixelData, int components)
-{
-  CGDataProviderRef source =
-    CGDataProviderCreateWithData(NULL, dctData.data(),
-				 dctData.size(), NULL);
-  CGImageRef bitmap =
-    CGImageCreateWithJPEGDataProvider(source, NULL, false,
-				      kCGRenderingIntentDefault);
-
-  if (CGImageGetBitsPerComponent(bitmap) != 8)
-    return false;
-
-  int w = CGImageGetWidth(bitmap);
-  int h = CGImageGetHeight(bitmap);
-  int bytes = CGImageGetBitsPerPixel(bitmap) / 8;
-  int stride = CGImageGetBytesPerRow(bitmap);
-
-  CGBitmapInfo info = CGImageGetBitmapInfo(bitmap);
-  // TODO: check for alpha channel, float pixel values, and byte order?
-  ipeDebug("dctDecode: %d x %d x %d, stride %d, info %x",
-	   w, h, bytes, stride, info);
-
-  // TODO: Is it necessary to copy the data?
-  CFDataRef pixels = CGDataProviderCopyData(CGImageGetDataProvider(bitmap));
-  const uchar *inRow = CFDataGetBytePtr(pixels);
-
-  uchar *q = (uchar *) pixelData.data();
-  for (int y = 0; y < h; ++y) {
-    const uchar *p = inRow;
-    for (int x = 0; x < w; ++x) {
-      *q++ = p[0];
-      *q++ = p[1];
-      *q++ = p[2];
-      p += bytes;
-    }
-    inRow += stride;
-  }
-  CFRelease(pixels);
-  CGImageRelease(bitmap);
-  CGDataProviderRelease(source);
-  return true;
-}
-
-#else
-
 // Decode jpeg image using libjpeg API with error handling
 // Code contributed by Michael Thon, 2015.
 
@@ -139,7 +88,6 @@
   jpeg_destroy_decompress(&cinfo);
   return true;
 }
-#endif
 
 // --------------------------------------------------------------------
 
