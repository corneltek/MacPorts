Index: src/mozilla-plugin/openvrml.cpp
===================================================================
--- src/mozilla-plugin/openvrml.cpp	(revision 4241)
+++ src/mozilla-plugin/openvrml.cpp	(revision 4242)
@@ -2,7 +2,7 @@
 //
 // OpenVRML Mozilla plug-in
 //
-// Copyright 2004, 2005, 2006, 2007, 2008  Braden McDaniel
+// Copyright 2004, 2005, 2006, 2007, 2008, 2010  Braden McDaniel
 //
 // This program is free software; you can redistribute it and/or modify it
 // under the terms of the GNU General Public License as published by the Free
@@ -25,9 +25,8 @@
 # include <vector>
 # include <sys/socket.h>
 # include <sys/wait.h>
-# include <boost/concept_check.hpp>
 # include <boost/lexical_cast.hpp>
-# include <boost/multi_index/detail/scope_guard.hpp>
+# include <boost/scope_exit.hpp>
 # include <boost/noncopyable.hpp>
 # include <boost/ref.hpp>
 # include <boost/scoped_ptr.hpp>
@@ -75,8 +74,6 @@
 # include "browser-factory-client-glue.h"
 # include "browser-client-glue.h"
 
-using namespace boost::multi_index::detail;  // for scope_guard
-
 namespace {
 
     void printerr(const char * str);
@@ -169,7 +166,9 @@
                      G_TYPE_NONE, 0);
 
     GError * error = 0;
-    scope_guard error_guard = make_guard(g_error_free, boost::ref(error));
+    BOOST_SCOPE_EXIT((&error)) {
+        if (error) { g_error_free(error); }
+    } BOOST_SCOPE_EXIT_END
     klass->connection = dbus_g_bus_get(DBUS_BUS_SESSION, &error);
     if (!klass->connection) {
         g_critical("Failed to open connection to bus: %s", error->message);
@@ -184,8 +183,9 @@
                                   DBUS_SERVICE_DBUS,
                                   DBUS_PATH_DBUS,
                                   DBUS_INTERFACE_DBUS);
-    scope_guard driver_proxy_guard = make_guard(g_object_unref, driver_proxy);
-    boost::ignore_unused_variable_warning(driver_proxy_guard);
+    BOOST_SCOPE_EXIT((driver_proxy)) {
+        g_object_unref(driver_proxy);
+    } BOOST_SCOPE_EXIT_END
 
     guint request_ret;
     if (!org_freedesktop_DBus_request_name(driver_proxy,
@@ -200,7 +200,6 @@
     dbus_g_object_type_install_info(
         OPENVRML_NP_TYPE_BROWSER_HOST,
         &dbus_glib_openvrml_np_browser_host_object_info);
-    error_guard.dismiss();
 }
 
 int openvrml_np_browser_host_get_url(OpenvrmlNpBrowserHost * const host,
@@ -589,12 +588,10 @@
     return pluginInstance.write(stream, len, buffer);
 }
 
-void NPP_StreamAsFile(const NPP instance,
+void NPP_StreamAsFile(NPP,
                       NPStream *,
                       const char * /* fname */)
 {
-    boost::ignore_unused_variable_warning(instance);
-    assert(instance);
 }
 
 void NPP_Print(const NPP instance, NPPrint * const printInfo)
@@ -1095,9 +1092,9 @@
                                       "/org/openvrml/BrowserFactory",
                                       "org.openvrml.BrowserFactory");
         g_return_val_if_fail(browser_factory, 0);
-        scope_guard browser_factory_guard =
-            make_guard(g_object_unref, G_OBJECT(browser_factory));
-        boost::ignore_unused_variable_warning(browser_factory_guard);
+        BOOST_SCOPE_EXIT((browser_factory)) {
+            g_object_unref(browser_factory);
+        } BOOST_SCOPE_EXIT_END
 
         char * browser_path = 0;
         if (!org_openvrml_BrowserFactory_create_control(browser_factory,
@@ -1140,7 +1137,9 @@
             OPENVRML_NP_BROWSER_HOST_GET_CLASS(this->browser_host);
 
         GError * error = 0;
-        scope_guard error_guard = make_guard(g_error_free, boost::ref(error));
+        BOOST_SCOPE_EXIT((&error)) {
+            if (error) { g_error_free(error); }
+        } BOOST_SCOPE_EXIT_END
 
         this->browser = get_browser(browser_host_class->connection,
                                     browser_host_class->host_name,
@@ -1151,8 +1150,6 @@
             g_critical("Browser creation failed: %s", error->message);
             return;
         }
-
-        error_guard.dismiss();
     }
 
     NPError plugin_instance::new_stream(const NPMIMEType type,
@@ -1161,7 +1158,9 @@
         if (!this->browser) { return NPERR_INVALID_INSTANCE_ERROR; }
 
         GError * error = 0;
-        scope_guard error_guard = make_guard(g_error_free, boost::ref(error));
+        BOOST_SCOPE_EXIT((&error)) {
+            if (error) { g_error_free(error); }
+        } BOOST_SCOPE_EXIT_END
         gboolean result = org_openvrml_Browser_new_stream(this->browser,
                                                           guint64(stream),
                                                           type,
@@ -1172,7 +1171,6 @@
                        error->message);
             return NPERR_GENERIC_ERROR;
         }
-        error_guard.dismiss();
         return NPERR_NO_ERROR;
     }
 

Index: src/openvrml-xembed/browser.cpp
===================================================================
--- src/openvrml-xembed/browser.cpp	(revision 4241)
+++ src/openvrml-xembed/browser.cpp	(revision 4242)
@@ -2,7 +2,7 @@
 //
 // OpenVRML XEmbed Control
 //
-// Copyright 2004, 2005, 2006, 2007, 2008  Braden N. McDaniel
+// Copyright 2004, 2005, 2006, 2007, 2008, 2010  Braden N. McDaniel
 //
 // This program is free software; you can redistribute it and/or modify it
 // under the terms of the GNU General Public License as published by the Free
@@ -18,7 +18,7 @@
 // with this library; if not, see <http://www.gnu.org/licenses/>.
 //
 
-# include <boost/multi_index/detail/scope_guard.hpp>
+# include <boost/scope_exit.hpp>
 // Must include before X11 headers.
 # include <boost/numeric/conversion/converter.hpp>
 # include <X11/keysym.h>
@@ -33,8 +33,6 @@
 # include <gtk/gtkdrawingarea.h>
 # include <dbus/dbus.h>
 
-using namespace boost::multi_index::detail; // for scope_guard
-
 GQuark openvrml_xembed_error_quark()
 {
     return g_quark_from_static_string("openvrml-xembed-error-quark");
@@ -321,6 +319,7 @@
                             const gchar * const host_name,
                             const GdkNativeWindow socket_id)
 {
+    bool succeeded = false;
     OpenvrmlXembedBrowser * const browser =
         OPENVRML_XEMBED_BROWSER(
             g_object_new(OPENVRML_XEMBED_TYPE_BROWSER,
@@ -329,21 +328,22 @@
                          "expect-initial-stream", expect_initial_stream,
                          static_cast<void *>(0)));
     if (!browser) { return 0; }
-    scope_guard browser_guard = make_guard(g_object_unref, browser);
+    BOOST_SCOPE_EXIT((&succeeded)(browser)) {
+        if (!succeeded) { g_object_unref(browser); }
+    } BOOST_SCOPE_EXIT_END
 
     GSource * const browser_ready_source =
         openvrml_xembed_browser_ready_source_new(browser, socket_id);
     if (!browser_ready_source) { return 0; }
-    scope_guard browser_ready_source_guard =
-        make_guard(g_object_unref, browser_ready_source);
+    BOOST_SCOPE_EXIT((&succeeded)(browser_ready_source)) {
+        if (!succeeded) { g_object_unref(browser_ready_source); }
+    } BOOST_SCOPE_EXIT_END
 
     gdk_threads_enter();
     g_source_attach(browser_ready_source, gtk_thread_context);
     gdk_threads_leave();
 
-    browser_ready_source_guard.dismiss();
-    browser_guard.dismiss();
-
+    succeeded = true;
     return browser;
 }
 
@@ -733,8 +733,9 @@
                      NULL);
 
         g_assert(browser);
-        scope_guard browser_guard = make_guard(g_object_unref, browser);
-        boost::ignore_unused_variable_warning(browser_guard);
+        BOOST_SCOPE_EXIT((browser)) {
+            g_object_unref(browser);
+        } BOOST_SCOPE_EXIT_END
 
         browser_plug->priv->drawing_area =
             GTK_DRAWING_AREA(g_object_new(GTK_TYPE_DRAWING_AREA, 0));
@@ -1260,12 +1261,6 @@
 
 namespace {
 
-    void cleanup_private_connection(DBusConnection * const connection)
-    {
-        dbus_connection_close(connection);
-        dbus_connection_unref(connection);
-    }
-
     int browser_host_proxy::do_get_url(const std::string & url)
     {
         //
@@ -1275,7 +1270,9 @@
         //
         DBusError error;
         dbus_error_init(&error);
-        scope_guard error_guard = make_guard(dbus_error_free, &error);
+        BOOST_SCOPE_EXIT((&error)) {
+            dbus_error_free(&error);
+        } BOOST_SCOPE_EXIT_END
         DBusConnection * const connection =
             dbus_bus_get_private(DBUS_BUS_SESSION, &error);
         if (!connection) {
@@ -1283,8 +1280,10 @@
                       error.message);
             return -1;
         }
-        scope_guard connection_guard =
-            make_guard(cleanup_private_connection, connection);
+        BOOST_SCOPE_EXIT((connection)) {
+            dbus_connection_close(connection);
+            dbus_connection_unref(connection);
+        } BOOST_SCOPE_EXIT_END
 
         DBusMessage * const get_url_call =
             dbus_message_new_method_call(
@@ -1292,8 +1291,9 @@
                 dbus_g_proxy_get_path(this->browser_.priv->control_host),
                 dbus_g_proxy_get_interface(this->browser_.priv->control_host),
                 "GetUrl");
-        scope_guard get_url_call_guard =
-            make_guard(dbus_message_unref, get_url_call);
+        BOOST_SCOPE_EXIT((get_url_call)) {
+            dbus_message_unref(get_url_call);
+        } BOOST_SCOPE_EXIT_END
 
         const char * const url_c_str = url.c_str();
         bool succeeded =
@@ -1314,8 +1314,9 @@
             g_warning("error fetching resource: %s", error.message);
             return -1;
         }
-        scope_guard get_url_response_guard =
-            make_guard(dbus_message_unref, get_url_response);
+        BOOST_SCOPE_EXIT((get_url_response)) {
+            dbus_message_unref(get_url_response);
+        } BOOST_SCOPE_EXIT_END
 
         gint get_url_result = -1;
         succeeded =
Index: src/openvrml-xembed/main.cpp
===================================================================
--- src/openvrml-xembed/main.cpp	(revision 4241)
+++ src/openvrml-xembed/main.cpp	(revision 4242)
@@ -25,10 +25,9 @@
 # include <gtk/gtk.h>
 # include <dbus/dbus-glib-bindings.h>
 # include <dbus/dbus-glib-lowlevel.h>
-# include <boost/concept_check.hpp>
 # include <boost/function.hpp>
 # include <boost/lexical_cast.hpp>
-# include <boost/multi_index/detail/scope_guard.hpp>
+# include <boost/scope_exit.hpp>
 # include <boost/ref.hpp>
 # include <boost/scoped_ptr.hpp>
 # include <boost/thread.hpp>
@@ -40,8 +39,6 @@
 #   include "config.h"
 # endif
 
-using namespace boost::multi_index::detail; // for scope_guard
-
 extern "C"
 G_GNUC_INTERNAL
 gboolean
@@ -87,8 +84,9 @@
         void operator()() const
         {
             GError * error = 0;
-            scope_guard error_guard =
-                make_guard(g_error_free, boost::ref(error));
+            BOOST_SCOPE_EXIT((&error)) {
+                if (error) { g_error_free(error); }
+            } BOOST_SCOPE_EXIT_END
 
             DBusGConnection * const connection =
                 bus_get(g_main_loop_get_context(&this->dbus_thread_main_),
@@ -98,9 +96,9 @@
                 g_critical("Failed to get session bus: %s", error->message);
                 return;
             }
-            scope_guard connection_guard =
-                make_guard(dbus_g_connection_unref, connection);
-            boost::ignore_unused_variable_warning(connection_guard);
+            BOOST_SCOPE_EXIT((connection)) {
+                dbus_g_connection_unref(connection);
+            } BOOST_SCOPE_EXIT_END
 
             OpenvrmlXembedBrowserFactory * const browser_factory =
                 OPENVRML_XEMBED_BROWSER_FACTORY(
@@ -109,18 +107,18 @@
                         "connection", connection,
                         "main-thread-context", &this->main_thread_context_,
                         static_cast<void *>(0)));
-            scope_guard browser_factory_guard =
-                make_guard(g_object_unref, browser_factory);
-            boost::ignore_unused_variable_warning(browser_factory_guard);
+            BOOST_SCOPE_EXIT((browser_factory)) {
+                g_object_unref(browser_factory);
+            } BOOST_SCOPE_EXIT_END
 
             DBusGProxy * driver_proxy =
                 dbus_g_proxy_new_for_name(connection,
                                           DBUS_SERVICE_DBUS,
                                           DBUS_PATH_DBUS,
                                           DBUS_INTERFACE_DBUS);
-            scope_guard driver_proxy_guard =
-                make_guard(g_object_unref, driver_proxy);
-            boost::ignore_unused_variable_warning(driver_proxy_guard);
+            BOOST_SCOPE_EXIT((driver_proxy)) {
+                g_object_unref(driver_proxy);
+            } BOOST_SCOPE_EXIT_END
 
             dbus_g_proxy_add_signal(driver_proxy,
                                     "NameOwnerChanged",
@@ -139,8 +137,6 @@
                 0);
 
             g_main_loop_run(&this->dbus_thread_main_);
-
-            error_guard.dismiss();
         }
 
     private:
@@ -179,7 +175,9 @@
     };
 
     GError * error = 0;
-    scope_guard error_guard = make_guard(g_error_free, ref(error));
+    BOOST_SCOPE_EXIT((&error)) {
+        if (error) { g_error_free(error); }
+    } BOOST_SCOPE_EXIT_END
 
     GOptionContext * const context =
         g_option_context_new("- render VRML/X3D worlds");
@@ -194,7 +192,6 @@
 
     if (version) {
         cout << application_name << ' ' << PACKAGE_VERSION << endl;
-        error_guard.dismiss();
         return EXIT_SUCCESS;
     }
 
@@ -206,13 +203,13 @@
     using boost::thread;
 
     GMainContext * dbus_thread_context = g_main_context_new();
-    scope_guard dbus_thread_context_guard =
-        make_guard(g_main_context_unref, dbus_thread_context);
-    boost::ignore_unused_variable_warning(dbus_thread_context_guard);
+    BOOST_SCOPE_EXIT((dbus_thread_context)) {
+        g_main_context_unref(dbus_thread_context);
+    } BOOST_SCOPE_EXIT_END
     GMainLoop * dbus_thread_main = g_main_loop_new(dbus_thread_context, false);
-    scope_guard dbus_thread_main_guard =
-        make_guard(g_main_loop_unref, dbus_thread_main);
-    boost::ignore_unused_variable_warning(dbus_thread_main_guard);
+    BOOST_SCOPE_EXIT((dbus_thread_main)) {
+        g_main_loop_unref(dbus_thread_main);
+    } BOOST_SCOPE_EXIT_END
 
     function<void ()> dbus_thread_func = dbus_thread_loop(*main_context,
                                                           *dbus_thread_main);
@@ -227,8 +224,6 @@
     // quit in openvrml_xembed_name_owner_changed.
     //
     dbus_thread->join();
-
-    error_guard.dismiss();
 }
 
 //
Index: src/openvrml-xembed/browserfactory.cpp
===================================================================
--- src/openvrml-xembed/browserfactory.cpp	(revision 4241)
+++ src/openvrml-xembed/browserfactory.cpp	(revision 4242)
@@ -2,7 +2,7 @@
 //
 // OpenVRML XEmbed Control
 //
-// Copyright 2008  Braden McDaniel
+// Copyright 2008, 2010  Braden McDaniel
 //
 // This program is free software; you can redistribute it and/or modify it
 // under the terms of the GNU General Public License as published by the Free
@@ -18,15 +18,15 @@
 // with this library; if not, see <http://www.gnu.org/licenses/>.
 //
 
-# include <boost/concept_check.hpp>
 # include <boost/intrusive_ptr.hpp>
-# include <boost/multi_index/detail/scope_guard.hpp>
+# include <boost/scope_exit.hpp>
 # include <boost/ref.hpp>
 # include <gtk/gtk.h>
 # include <dbus/dbus-glib-bindings.h>
 # include <dbus/dbus-glib-lowlevel.h>
 # include <map>
 # include <memory>
+# include <string>
 # include <cstring>
 # include <cstdlib>
 
@@ -34,8 +34,6 @@
 # include "browser-factory-server-glue.h"
 # include "browser.h"
 
-using namespace boost::multi_index::detail; // for scope_guard
-
 G_DEFINE_TYPE(OpenvrmlXembedBrowserFactory,
               openvrml_xembed_browser_factory,
               G_TYPE_OBJECT)
@@ -119,12 +117,14 @@
                                       DBUS_SERVICE_DBUS,
                                       DBUS_PATH_DBUS,
                                       DBUS_INTERFACE_DBUS);
-        scope_guard driver_proxy_guard =
-            make_guard(g_object_unref, driver_proxy);
-        boost::ignore_unused_variable_warning(driver_proxy_guard);
+        BOOST_SCOPE_EXIT((driver_proxy)) {
+            g_object_unref(driver_proxy);
+        } BOOST_SCOPE_EXIT_END
 
         GError * error = 0;
-        scope_guard error_guard = make_guard(g_error_free, boost::ref(error));
+        BOOST_SCOPE_EXIT((&error)) {
+            if (error) { g_error_free(error); }
+        } BOOST_SCOPE_EXIT_END
         guint request_ret;
         if (!org_freedesktop_DBus_request_name(
                 driver_proxy,
@@ -135,7 +135,6 @@
                        "failed: %s", error->message);
             return 0;
         }
-        error_guard.dismiss();
     } catch (std::bad_alloc &) {
         return 0;
     }
@@ -292,7 +291,9 @@
     DBusGMethodInvocation * const context)
 {
     GError * error = 0;
-    scope_guard error_guard = make_guard(g_error_free, boost::ref(error));
+    BOOST_SCOPE_EXIT((&error)) {
+        if (error) { g_error_free(error); }
+    } BOOST_SCOPE_EXIT_END
 
     DBusGProxy * host =
         dbus_g_proxy_new_for_name_owner(
@@ -330,8 +331,9 @@
         G_OBJECT(browser));
 
     char * const sender = dbus_g_method_get_sender(context);
-    scope_guard sender_guard = make_guard(g_free, sender);
-    boost::ignore_unused_variable_warning(sender_guard);
+    BOOST_SCOPE_EXIT((sender)) {
+        g_free(sender);
+    } BOOST_SCOPE_EXIT_END
     bool succeeded;
     try {
         using std::make_pair;
@@ -373,8 +375,6 @@
 
     dbus_g_method_return(context, control_obj_path);
 
-    error_guard.dismiss();
-
     return true;
 }
 
Index: src/script/java.cpp
===================================================================
--- src/script/java.cpp	(revision 4241)
+++ src/script/java.cpp	(revision 4242)
@@ -5,7 +5,7 @@
 // Copyright 1998  Chris Morley
 // Copyright 2001  Henri Manson
 // Copyright 2002  Thomas Flynn
-// Copyright 2007, 2008  Braden McDaniel
+// Copyright 2007, 2008, 2010  Braden McDaniel
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
@@ -85,7 +85,7 @@
 # include <private.h>
 # include <boost/array.hpp>
 # include <boost/filesystem/path.hpp>
-# include <boost/multi_index/detail/scope_guard.hpp>
+# include <boost/scope_exit.hpp>
 # include <boost/scoped_array.hpp>
 # include <algorithm>
 # include <iostream>
@@ -97,8 +97,6 @@
 #   include <config.h>
 # endif
 
-using namespace boost::multi_index::detail;  // for scope_guard
-
 namespace {
 
     OPENVRML_JAVA_LOCAL openvrml::local::dl::handle libjvm_handle;
@@ -354,23 +352,19 @@
     OPENVRML_JAVA_LOCAL jobject create_url(JNIEnv & env, const char * const url)
         OPENVRML_THROW2(std::runtime_error, std::bad_alloc)
     {
-        using boost::ref;
-
         //
         // We can safely run DeleteGlobalRef in the scope guard because
         // calling DeleteGlobalRef with 0 is a no-op.
         //
         jobject result_global_ref = 0;
-        scope_guard result_global_ref_guard =
-            make_obj_guard(env,
-                           &JNIEnv::DeleteGlobalRef,
-                           ref(result_global_ref));
-        boost::ignore_unused_variable_warning(result_global_ref_guard);
+        BOOST_SCOPE_EXIT((&env)(&result_global_ref)) {
+            env.DeleteGlobalRef(result_global_ref);
+        } BOOST_SCOPE_EXIT_END
         {
             if (env.PushLocalFrame(3) < 0) { throw std::bad_alloc(); }
-            scope_guard local_frame_guard =
-                make_obj_guard(env, &JNIEnv::PopLocalFrame, jobject(0));
-            boost::ignore_unused_variable_warning(local_frame_guard);
+            BOOST_SCOPE_EXIT((&env)) {
+                env.PopLocalFrame(0);
+            } BOOST_SCOPE_EXIT_END
 
             const jstring url_string = env.NewStringUTF(url);
             if (!url_string) {
@@ -422,23 +416,19 @@
                                                     const std::string & url_str)
         OPENVRML_THROW2(std::runtime_error, std::bad_alloc)
     {
-        using boost::ref;
-
         //
         // We can safely run DeleteGlobalRef in the scope guard because
         // calling DeleteGlobalRef with 0 is a no-op.
         //
         jobject result_global_ref = 0;
-        scope_guard result_global_ref_guard =
-            make_obj_guard(env,
-                           &JNIEnv::DeleteGlobalRef,
-                           ref(result_global_ref));
-        boost::ignore_unused_variable_warning(result_global_ref_guard);
+        BOOST_SCOPE_EXIT((&env)(&result_global_ref)) {
+            env.DeleteGlobalRef(result_global_ref);
+        } BOOST_SCOPE_EXIT_END
         {
             if (env.PushLocalFrame(4) < 0) { throw std::bad_alloc(); }
-            scope_guard local_frame_guard =
-                make_obj_guard(env, &JNIEnv::PopLocalFrame, jobject(0));
-            boost::ignore_unused_variable_warning(local_frame_guard);
+            BOOST_SCOPE_EXIT((&env)) {
+                env.PopLocalFrame(0);
+            } BOOST_SCOPE_EXIT_END
 
             const jobject url = create_url(env, url_str.c_str());
 
@@ -499,23 +489,19 @@
         assert(this->browser_);
         assert(this->script_class_);
 
-        using boost::ref;
-
         //
         // We can safely run DeleteGlobalRef in the scope guard because
         // calling DeleteGlobalRef with 0 is a no-op.
         //
         jobject result_global_ref = 0;
-        scope_guard result_global_ref_guard =
-            make_obj_guard(env,
-                           &JNIEnv::DeleteGlobalRef,
-                           ref(result_global_ref));
-        boost::ignore_unused_variable_warning(result_global_ref_guard);
+        BOOST_SCOPE_EXIT((&env)(&result_global_ref)) {
+            env.DeleteGlobalRef(result_global_ref);
+        } BOOST_SCOPE_EXIT_END
         {
             if (env.PushLocalFrame(1) < 0) { throw std::bad_alloc(); }
-            scope_guard local_frame_guard =
-                make_obj_guard(env, &JNIEnv::PopLocalFrame, jobject(0));
-            boost::ignore_unused_variable_warning(local_frame_guard);
+            BOOST_SCOPE_EXIT((&env)) {
+                env.PopLocalFrame(0);
+            } BOOST_SCOPE_EXIT_END
 
             //
             // We call AllocObject to create the Script instance, set the
@@ -586,23 +572,19 @@
         assert(this->class_loader_);
         assert(!class_name.empty());
 
-        using boost::ref;
-
         //
         // We can safely run DeleteGlobalRef in the scope guard because
         // calling DeleteGlobalRef with 0 is a no-op.
         //
         jclass result_global_ref = 0;
-        scope_guard result_global_ref_guard =
-            make_obj_guard(env,
-                           &JNIEnv::DeleteGlobalRef,
-                           ref(result_global_ref));
-        boost::ignore_unused_variable_warning(result_global_ref_guard);
+        BOOST_SCOPE_EXIT((&env)(&result_global_ref)) {
+            env.DeleteGlobalRef(result_global_ref);
+        } BOOST_SCOPE_EXIT_END
         {
             if (env.PushLocalFrame(2) < 0) { throw std::bad_alloc(); }
-            scope_guard local_frame_guard =
-                make_obj_guard(env, &JNIEnv::PopLocalFrame, jobject(0));
-            boost::ignore_unused_variable_warning(local_frame_guard);
+            BOOST_SCOPE_EXIT((&env)) {
+                env.PopLocalFrame(0);
+            } BOOST_SCOPE_EXIT_END
 
             const jclass class_loader_class =
                 env.GetObjectClass(this->class_loader_);
@@ -662,23 +644,19 @@
     jobject script::create_browser_obj(JNIEnv & env)
         OPENVRML_THROW2(std::runtime_error, std::bad_alloc)
     {
-        using boost::ref;
-
         //
         // We can safely run DeleteGlobalRef in the scope guard because
         // calling DeleteGlobalRef with 0 is a no-op.
         //
         jobject result_global_ref = 0;
-        scope_guard result_global_ref_guard =
-            make_obj_guard(env,
-                           &JNIEnv::DeleteGlobalRef,
-                           ref(result_global_ref));
-        boost::ignore_unused_variable_warning(result_global_ref_guard);
+        BOOST_SCOPE_EXIT((&env)(&result_global_ref)) {
+            env.DeleteGlobalRef(result_global_ref);
+        } BOOST_SCOPE_EXIT_END
         {
             if (env.PushLocalFrame(2) < 0) { throw std::bad_alloc(); }
-            scope_guard local_frame_guard =
-                make_obj_guard(env, &JNIEnv::PopLocalFrame, jobject(0));
-            boost::ignore_unused_variable_warning(local_frame_guard);
+            BOOST_SCOPE_EXIT((&env)) {
+                env.PopLocalFrame(0);
+            } BOOST_SCOPE_EXIT_END
 
             const jclass browser_class = this->find_class(env, "vrml.Browser");
 
@@ -733,23 +711,19 @@
                 const bool const_ = false)
         OPENVRML_THROW2(std::runtime_error, std::bad_alloc)
     {
-        using boost::ref;
-
         //
         // We can safely run DeleteGlobalRef in the scope guard because
         // calling DeleteGlobalRef with 0 is a no-op.
         //
         jobject result_global_ref = 0;
-        scope_guard result_global_ref_guard =
-            make_obj_guard(env,
-                           &JNIEnv::DeleteGlobalRef,
-                           ref(result_global_ref));
-        boost::ignore_unused_variable_warning(result_global_ref_guard);
+        BOOST_SCOPE_EXIT((&env)(&result_global_ref)) {
+            env.DeleteGlobalRef(result_global_ref);
+        } BOOST_SCOPE_EXIT_END
         {
             if (env.PushLocalFrame(2) < 0) { throw std::bad_alloc(); }
-            scope_guard local_frame_guard =
-                make_obj_guard(env, &JNIEnv::PopLocalFrame, jobject(0));
-            boost::ignore_unused_variable_warning(local_frame_guard);
+            BOOST_SCOPE_EXIT((&env)) {
+                env.PopLocalFrame(0);
+            } BOOST_SCOPE_EXIT_END
 
             using std::ostringstream;
             using openvrml::field_value;
@@ -800,23 +774,19 @@
                  const bool const_ = false)
         OPENVRML_THROW1(std::bad_alloc)
     {
-        using boost::ref;
-
         //
         // We can safely run DeleteGlobalRef in the scope guard because
         // calling DeleteGlobalRef with 0 is a no-op.
         //
         jobject result_global_ref = 0;
-        scope_guard result_global_ref_guard =
-            make_obj_guard(env,
-                           &JNIEnv::DeleteGlobalRef,
-                           ref(result_global_ref));
-        boost::ignore_unused_variable_warning(result_global_ref_guard);
+        BOOST_SCOPE_EXIT((&env)(&result_global_ref)) {
+            env.DeleteGlobalRef(result_global_ref);
+        } BOOST_SCOPE_EXIT_END
         {
             if (env.PushLocalFrame(2) < 0) { throw std::bad_alloc(); }
-            scope_guard local_frame_guard =
-                make_obj_guard(env, &JNIEnv::PopLocalFrame, jobject(0));
-            boost::ignore_unused_variable_warning(local_frame_guard);
+            BOOST_SCOPE_EXIT((&env)) {
+                env.PopLocalFrame(0);
+            } BOOST_SCOPE_EXIT_END
 
             using std::ostringstream;
             using openvrml::field_value;
@@ -865,9 +835,9 @@
         assert(script_class);
         assert(script);
         if (env.PushLocalFrame(2) < 0) { throw std::bad_alloc(); }
-        scope_guard local_frame_guard =
-            make_obj_guard(env, &JNIEnv::PopLocalFrame, jobject(0));
-        boost::ignore_unused_variable_warning(local_frame_guard);
+        BOOST_SCOPE_EXIT((&env)) {
+            env.PopLocalFrame(0);
+        } BOOST_SCOPE_EXIT_END
 
         const jfieldID fields = env.GetFieldID(script_class,
                                                "fields",
@@ -891,9 +861,9 @@
              field != field_map.end();
              ++field) {
             if (env.PushLocalFrame(3) < 0) { throw std::bad_alloc(); }
-            scope_guard local_frame_guard =
-                make_obj_guard(env, &JNIEnv::PopLocalFrame, jobject(0));
-            boost::ignore_unused_variable_warning(local_frame_guard);
+            BOOST_SCOPE_EXIT((&env)) {
+                env.PopLocalFrame(0);
+            } BOOST_SCOPE_EXIT_END
 
             const jstring name = env.NewStringUTF(field->first.c_str());
             const jobject val = clone_Field(env, *field->second);
@@ -908,23 +878,19 @@
                     const openvrml::field_value & value)
         OPENVRML_THROW1(std::bad_alloc)
     {
-        using boost::ref;
-
         //
         // We can safely run DeleteGlobalRef in the scope guard because
         // calling DeleteGlobalRef with 0 is a no-op.
         //
         jobject result_global_ref = 0;
-        scope_guard result_global_ref_guard =
-            make_obj_guard(env,
-                           &JNIEnv::DeleteGlobalRef,
-                           ref(result_global_ref));
-        boost::ignore_unused_variable_warning(result_global_ref_guard);
+        BOOST_SCOPE_EXIT((&env)(&result_global_ref)) {
+            env.DeleteGlobalRef(result_global_ref);
+        } BOOST_SCOPE_EXIT_END
         {
             if (env.PushLocalFrame(2) < 0) { return 0; }
-            scope_guard local_frame_guard =
-                make_obj_guard(env, &JNIEnv::PopLocalFrame, jobject(0));
-            boost::ignore_unused_variable_warning(local_frame_guard);
+            BOOST_SCOPE_EXIT((&env)) {
+                env.PopLocalFrame(0);
+            } BOOST_SCOPE_EXIT_END
 
             using std::ostringstream;
             using openvrml::field_value;
@@ -971,9 +937,9 @@
         assert(script_class);
         assert(script);
         if (env.PushLocalFrame(2) < 0) { throw std::bad_alloc(); }
-        scope_guard local_frame_guard =
-            make_obj_guard(env, &JNIEnv::PopLocalFrame, jobject(0));
-        boost::ignore_unused_variable_warning(local_frame_guard);
+        BOOST_SCOPE_EXIT((&env)) {
+            env.PopLocalFrame(0);
+        } BOOST_SCOPE_EXIT_END
 
         const jfieldID eventouts = env.GetFieldID(script_class,
                                                   "eventOuts",
@@ -998,9 +964,9 @@
              eventout != eventout_map.end();
              ++eventout) {
             if (env.PushLocalFrame(3) < 0) { throw std::bad_alloc(); }
-            scope_guard local_frame_guard =
-                make_obj_guard(env, &JNIEnv::PopLocalFrame, jobject(0));
-            boost::ignore_unused_variable_warning(local_frame_guard);
+            BOOST_SCOPE_EXIT((&env)) {
+                env.PopLocalFrame(0);
+            } BOOST_SCOPE_EXIT_END
 
             const jstring name = env.NewStringUTF(eventout->first.c_str());
             const jobject val =
@@ -1068,10 +1034,12 @@
             source_url.substr(0, last_slash_pos + 1);
 
         {
+            bool succeeded = false;
+
             if (env->PushLocalFrame(4) < 0) { throw std::bad_alloc(); }
-            scope_guard local_frame_guard =
-                make_obj_guard(*env, &JNIEnv::PopLocalFrame, jobject(0));
-            boost::ignore_unused_variable_warning(local_frame_guard);
+            BOOST_SCOPE_EXIT((env)) {
+                env->PopLocalFrame(0);
+            } BOOST_SCOPE_EXIT_END
 
             const jobject class_loader_local_ref =
                 create_class_loader(*env, url_path_prefix);
@@ -1080,9 +1048,9 @@
                 throw std::runtime_error("failed to create global reference "
                                          "to Java class loader instance");
             }
-            scope_guard class_loader_global_ref_guard =
-                make_obj_guard(*env, &JNIEnv::DeleteGlobalRef,
-                               this->class_loader_);
+            BOOST_SCOPE_EXIT((&succeeded)(env)(&class_loader_)) {
+                if (!succeeded) { env->DeleteGlobalRef(class_loader_); }
+            } BOOST_SCOPE_EXIT_END
 
             const jobject browser_local_ref = create_browser_obj(*env);
             this->browser_ = env->NewGlobalRef(browser_local_ref);
@@ -1090,8 +1058,9 @@
                 throw std::runtime_error("failed to create global reference "
                                          "to Java vrml.Browser instance");
             }
-            scope_guard browser_global_ref_guard =
-                make_obj_guard(*env, &JNIEnv::DeleteGlobalRef, this->browser_);
+            BOOST_SCOPE_EXIT((&succeeded)(env)(&browser_)) {
+                if (!succeeded) { env->DeleteGlobalRef(browser_); }
+            } BOOST_SCOPE_EXIT_END
 
             const std::string::size_type class_name_start_pos =
                 (last_slash_pos != std::string::npos) ? last_slash_pos + 1
@@ -1116,9 +1085,9 @@
                 throw std::runtime_error("failed to create global reference "
                                          "to Java " + class_name + " class");
             }
-            scope_guard script_class_global_ref_guard =
-                make_obj_guard(*env, &JNIEnv::DeleteGlobalRef,
-                               this->script_class_);
+            BOOST_SCOPE_EXIT((&succeeded)(env)(&script_class_)) {
+                if (!succeeded) { env->DeleteGlobalRef(script_class_); }
+            } BOOST_SCOPE_EXIT_END
 
             const jobject script_local_ref = this->create_script_obj(*env);
             this->script_ = env->NewGlobalRef(script_local_ref);
@@ -1127,8 +1096,9 @@
                                          "to Java " + class_name
                                          + " instance");
             }
-            scope_guard script_global_ref_guard =
-                make_obj_guard(*env, &JNIEnv::DeleteGlobalRef, this->script_);
+            BOOST_SCOPE_EXIT((&succeeded)(env)(&script_)) {
+                if (!succeeded) { env->DeleteGlobalRef(script_); }
+            } BOOST_SCOPE_EXIT_END
 
             this->process_events_ =
                 env->GetMethodID(this->script_class_, "processEvents",
@@ -1161,8 +1131,9 @@
                 throw std::runtime_error("failed to create global reference "
                                          "to Java vrml.Event instance");
             }
-            scope_guard event_class_global_ref_guard =
-                make_obj_guard(*env, &JNIEnv::DeleteGlobalRef, this->event_class_);
+            BOOST_SCOPE_EXIT((&succeeded)(env)(&event_class_)) {
+                if (!succeeded) { env->DeleteGlobalRef(event_class_); }
+            } BOOST_SCOPE_EXIT_END
 
             this->event_ctor_ =
                 env->GetMethodID(this->event_class_,
@@ -1184,11 +1155,7 @@
             init_script_eventouts(*env, this->script_class_, this->script_,
                                   this->node.eventout_map());
 
-            event_class_global_ref_guard.dismiss();
-            script_global_ref_guard.dismiss();
-            script_class_global_ref_guard.dismiss();
-            browser_global_ref_guard.dismiss();
-            class_loader_global_ref_guard.dismiss();
+            succeeded = true;
         }
     }
 
@@ -1291,9 +1258,9 @@
             throw std::runtime_error("failed to create local frame when "
                                      "processing event");
         }
-        scope_guard local_frame_guard =
-            make_obj_guard(*env, &JNIEnv::PopLocalFrame, jobject(0));
-        boost::ignore_unused_variable_warning(local_frame_guard);
+        BOOST_SCOPE_EXIT((env)) {
+            env->PopLocalFrame(0);
+        } BOOST_SCOPE_EXIT_END
 
         const jstring event_name = env->NewStringUTF(id.c_str());
         if (!event_name) {
@@ -1321,11 +1288,13 @@
 
         const jobject event_global_ref = env->NewGlobalRef(event);
         if (!event_global_ref) { throw std::bad_alloc(); }
-        scope_guard event_global_ref_guard =
-            make_obj_guard(*env, &JNIEnv::DeleteGlobalRef, event_global_ref);
+        bool succeeded = false;
+        BOOST_SCOPE_EXIT((&succeeded)(env)(&event_global_ref)) {
+            if (!succeeded) { env->DeleteGlobalRef(event_global_ref); }
+        } BOOST_SCOPE_EXIT_END
 
         this->events_received_.push_back(event_global_ref);
-        event_global_ref_guard.dismiss();
+        succeeded = true;
     }
 
     /**
@@ -1355,9 +1324,9 @@
                 throw std::runtime_error("failed to create local frame when "
                                          "processing events");
             }
-            scope_guard local_frame_guard =
-                make_obj_guard(*env, &JNIEnv::PopLocalFrame, jobject(0));
-            boost::ignore_unused_variable_warning(local_frame_guard);
+            BOOST_SCOPE_EXIT((env)) {
+                env->PopLocalFrame(0);
+            } BOOST_SCOPE_EXIT_END
 
             const jobjectArray events =
                 env->NewObjectArray(this->events_received_.size(),
@@ -1532,9 +1501,9 @@
         OPENVRML_THROW2(std::runtime_error, std::bad_alloc)
     {
         if (env.PushLocalFrame(2) < 0) { throw std::bad_alloc(); }
-        scope_guard local_frame_guard =
-            make_obj_guard(env, &JNIEnv::PopLocalFrame, jobject(0));
-        boost::ignore_unused_variable_warning(local_frame_guard);
+        BOOST_SCOPE_EXIT_TPL((&env)) {
+            env.PopLocalFrame(0);
+        } BOOST_SCOPE_EXIT_END
 
         jclass clazz;
 # ifndef NDEBUG
@@ -1570,9 +1539,9 @@
         OPENVRML_THROW2(std::runtime_error, std::bad_alloc)
     {
         if (env.PushLocalFrame(2) < 0) { throw std::bad_alloc(); }
-        scope_guard local_frame_guard =
-            make_obj_guard(env, &JNIEnv::PopLocalFrame, jobject(0));
-        boost::ignore_unused_variable_warning(local_frame_guard);
+        BOOST_SCOPE_EXIT((&env)) {
+            env.PopLocalFrame(0);
+        } BOOST_SCOPE_EXIT_END
 
         jclass clazz;
 # ifndef NDEBUG
@@ -1719,26 +1688,22 @@
     create_Node(JNIEnv & env, const boost::intrusive_ptr<openvrml::node> & node)
         OPENVRML_THROW2(std::runtime_error, std::bad_alloc)
     {
-        using boost::ref;
-
         //
         // We can safely run DeleteGlobalRef in the scope guard because
         // calling DeleteGlobalRef with 0 is a no-op.
         //
         jobject result_global_ref = 0;
-        scope_guard result_global_ref_guard =
-            make_obj_guard(env,
-                           &JNIEnv::DeleteGlobalRef,
-                           ref(result_global_ref));
-        boost::ignore_unused_variable_warning(result_global_ref_guard);
+        BOOST_SCOPE_EXIT((&env)(&result_global_ref)) {
+            env.DeleteGlobalRef(result_global_ref);
+        } BOOST_SCOPE_EXIT_END
         {
             using std::auto_ptr;
             using boost::intrusive_ptr;
 
             if (env.PushLocalFrame(2) < 0) { throw std::bad_alloc(); }
-            scope_guard local_frame_guard =
-                make_obj_guard(env, &JNIEnv::PopLocalFrame, jobject(0));
-            boost::ignore_unused_variable_warning(local_frame_guard);
+            BOOST_SCOPE_EXIT((&env)) {
+                env.PopLocalFrame(0);
+            } BOOST_SCOPE_EXIT_END
 
             const jclass clazz = env.FindClass("vrml/node/NodeImpl");
             if (!clazz) {
@@ -1783,25 +1748,21 @@
         std::vector<boost::intrusive_ptr<openvrml::node> > & nodes)
         OPENVRML_THROW2(std::runtime_error, std::bad_alloc)
     {
-        using boost::ref;
-
         //
         // We can safely run DeleteGlobalRef in the scope guard because
         // calling DeleteGlobalRef with 0 is a no-op.
         //
         jobjectArray result_global_ref = 0;
-        scope_guard result_global_ref_guard =
-            make_obj_guard(env,
-                           &JNIEnv::DeleteGlobalRef,
-                           ref(result_global_ref));
-        boost::ignore_unused_variable_warning(result_global_ref_guard);
+        BOOST_SCOPE_EXIT((&env)(&result_global_ref)) {
+            env.DeleteGlobalRef(result_global_ref);
+        } BOOST_SCOPE_EXIT_END
         {
             using boost::intrusive_ptr;
 
             if (env.PushLocalFrame(2) < 0) { throw std::bad_alloc(); }
-            scope_guard local_frame_guard =
-                make_obj_guard(env, &JNIEnv::PopLocalFrame, jobject(0));
-            boost::ignore_unused_variable_warning(local_frame_guard);
+            BOOST_SCOPE_EXIT((&env)) {
+                env.PopLocalFrame(0);
+            } BOOST_SCOPE_EXIT_END
 
             const jclass clazz = env.FindClass("vrml/BaseNode");
             if (!clazz) {
@@ -1816,9 +1777,9 @@
                  i != nodes.size();
                  ++i) {
                 if (env.PushLocalFrame(1) < 0) { throw std::bad_alloc(); }
-                scope_guard local_frame_guard =
-                    make_obj_guard(env, &JNIEnv::PopLocalFrame, jobject(0));
-                boost::ignore_unused_variable_warning(local_frame_guard);
+                BOOST_SCOPE_EXIT((&env)) {
+                    env.PopLocalFrame(0);
+                } BOOST_SCOPE_EXIT_END
                 env.SetObjectArrayElement(result, i,
                                           create_Node(env, nodes[i]));
             }
@@ -1865,10 +1826,9 @@
 
         const char * const vrmlSyntax_chars =
             env->GetStringUTFChars(vrmlSyntax, 0);
-        scope_guard vrmlSyntax_chars_guard =
-            make_obj_guard(*env, &JNIEnv::ReleaseStringUTFChars,
-                           vrmlSyntax, vrmlSyntax_chars);
-        boost::ignore_unused_variable_warning(vrmlSyntax_chars_guard);
+        BOOST_SCOPE_EXIT((env)(vrmlSyntax)(vrmlSyntax_chars)) {
+            env->ReleaseStringUTFChars(vrmlSyntax, vrmlSyntax_chars);
+        } BOOST_SCOPE_EXIT_END
 
         std::istringstream in(vrmlSyntax_chars);
         try {
@@ -1917,9 +1877,9 @@
         OPENVRML_THROW2(std::runtime_error, std::bad_alloc)
     {
         if (env.PushLocalFrame(2) < 0) { throw std::bad_alloc(); }
-        scope_guard local_frame_guard =
-            make_obj_guard(env, &JNIEnv::PopLocalFrame, jobject(0));
-        boost::ignore_unused_variable_warning(local_frame_guard);
+        BOOST_SCOPE_EXIT((&env)) {
+            env.PopLocalFrame(0);
+        } BOOST_SCOPE_EXIT_END
 
 # ifndef NDEBUG
         const jclass script_class = env.FindClass("vrml/node/Script");
@@ -1951,9 +1911,9 @@
         OPENVRML_THROW2(std::runtime_error, std::bad_alloc)
     {
         if (env.PushLocalFrame(2) < 0) { throw std::bad_alloc(); }
-        scope_guard local_frame_guard =
-            make_obj_guard(env, &JNIEnv::PopLocalFrame, jobject(0));
-        boost::ignore_unused_variable_warning(local_frame_guard);
+        BOOST_SCOPE_EXIT((&env)) {
+            env.PopLocalFrame(0);
+        } BOOST_SCOPE_EXIT_END
 
 # ifndef NDEBUG
         const jclass base_node_class = env.FindClass("vrml/BaseNode");
@@ -2014,10 +1974,9 @@
         const char * const eventout_id =
             env->GetStringUTFChars(fromEventOut, 0);
         if (!eventout_id) { return; }
-        scope_guard eventout_id_guard =
-            make_obj_guard(*env, &JNIEnv::ReleaseStringUTFChars,
-                           fromEventOut, eventout_id);
-        boost::ignore_unused_variable_warning(eventout_id_guard);
+        BOOST_SCOPE_EXIT((env)(fromEventOut)(eventout_id)) {
+            env->ReleaseStringUTFChars(fromEventOut, eventout_id);
+        } BOOST_SCOPE_EXIT_END
 
         const intrusive_ptr<openvrml::node> & to =
             get_BaseNode_peer(*env, toNode);
@@ -2025,10 +1984,9 @@
 
         const char * const eventin_id = env->GetStringUTFChars(toEventIn, 0);
         if (!eventin_id) { return; }
-        scope_guard eventin_id_guard =
-            make_obj_guard(*env, &JNIEnv::ReleaseStringUTFChars,
-                           toEventIn, eventin_id);
-        boost::ignore_unused_variable_warning(eventin_id_guard);
+        BOOST_SCOPE_EXIT((env)(toEventIn)(eventin_id)) {
+            env->ReleaseStringUTFChars(toEventIn, eventin_id);
+        } BOOST_SCOPE_EXIT_END
 
         openvrml::add_route(*from, eventout_id, *to, eventin_id);
     } catch (std::logic_error & ex) {
@@ -2074,10 +2032,9 @@
         const char * const eventout_id =
             env->GetStringUTFChars(fromEventOut, 0);
         if (!eventout_id) { return; }
-        scope_guard eventout_id_guard =
-            make_obj_guard(*env, &JNIEnv::ReleaseStringUTFChars,
-                           fromEventOut, eventout_id);
-        boost::ignore_unused_variable_warning(eventout_id_guard);
+        BOOST_SCOPE_EXIT((env)(fromEventOut)(eventout_id)) {
+            env->ReleaseStringUTFChars(fromEventOut, eventout_id);
+        } BOOST_SCOPE_EXIT_END
 
         const intrusive_ptr<openvrml::node> & to =
             get_BaseNode_peer(*env, toNode);
@@ -2085,10 +2042,9 @@
 
         const char * const eventin_id = env->GetStringUTFChars(toEventIn, 0);
         if (!eventin_id) { return; }
-        scope_guard eventin_id_guard =
-            make_obj_guard(*env, &JNIEnv::ReleaseStringUTFChars,
-                           toEventIn, eventin_id);
-        boost::ignore_unused_variable_warning(eventin_id_guard);
+        BOOST_SCOPE_EXIT((env)(toEventIn)(eventin_id)) {
+            env->ReleaseStringUTFChars(toEventIn, eventin_id);
+        } BOOST_SCOPE_EXIT_END
 
         openvrml::delete_route(*from, eventout_id, *to, eventin_id);
     } catch (openvrml::unsupported_interface & ex) {
@@ -2141,9 +2097,9 @@
             }
             const char * str = env->GetStringUTFChars(jstr, 0);
             if (!str) { return; } // OutOfMemoryError
-            scope_guard str_guard =
-                make_obj_guard(*env, &JNIEnv::ReleaseStringUTFChars, jstr, str);
-            boost::ignore_unused_variable_warning(str_guard);
+            BOOST_SCOPE_EXIT((env)(jstr)(str)) {
+                env->ReleaseStringUTFChars(jstr, str);
+            } BOOST_SCOPE_EXIT_END
             url_vec[i] = str; // Throws std::bad_alloc.
         }
 
@@ -2156,9 +2112,9 @@
             }
             const char * str = env->GetStringUTFChars(jstr, 0);
             if (!str) { return; } // OutOfMemoryError
-            scope_guard str_guard =
-                make_obj_guard(*env, &JNIEnv::ReleaseStringUTFChars, jstr, str);
-            boost::ignore_unused_variable_warning(str_guard);
+            BOOST_SCOPE_EXIT((env)(jstr)(str)) {
+                env->ReleaseStringUTFChars(jstr, str);
+            } BOOST_SCOPE_EXIT_END
             param_vec[i] = str; // Throws std::bad_alloc.
         }
 
@@ -2185,9 +2141,9 @@
 {
     const char * desc = env->GetStringUTFChars(description, 0);
     if (!desc) { return; } // OutOfMemoryError
-    scope_guard desc_guard =
-        make_obj_guard(*env, &JNIEnv::ReleaseStringUTFChars, description, desc);
-    boost::ignore_unused_variable_warning(desc_guard);
+    BOOST_SCOPE_EXIT((env)(description)(desc)) {
+        env->ReleaseStringUTFChars(description, desc);
+    } BOOST_SCOPE_EXIT_END
     try {
         openvrml::browser & browser = get_Browser_peer(*env, obj);
         browser.description(desc);
@@ -2258,9 +2214,9 @@
 {
     const char * id_chars = env->GetStringUTFChars(id, 0);
     if (!id_chars) { return; }
-    scope_guard id_chars_guard =
-        make_obj_guard(*env, &JNIEnv::ReleaseStringUTFChars, id, id_chars);
-    boost::ignore_unused_variable_warning(id_chars_guard);
+    BOOST_SCOPE_EXIT((env)(id)(id_chars)) {
+        env->ReleaseStringUTFChars(id, id_chars);
+    } BOOST_SCOPE_EXIT_END
 
     try {
         using openvrml::field_value;
@@ -2279,9 +2235,9 @@
 {
     const char * id_chars = env->GetStringUTFChars(id, 0);
     if (!id_chars) { return; }
-    scope_guard id_chars_guard =
-        make_obj_guard(*env, &JNIEnv::ReleaseStringUTFChars, id, id_chars);
-    boost::ignore_unused_variable_warning(id_chars_guard);
+    BOOST_SCOPE_EXIT((env)(id)(id_chars)) {
+        env->ReleaseStringUTFChars(id, id_chars);
+    } BOOST_SCOPE_EXIT_END
 
     try {
         using std::find_if;
@@ -2876,10 +2832,9 @@
     try {
         if (pixels) {
             jbyte * const elements = env->GetByteArrayElements(pixels, 0);
-            scope_guard elements_guard =
-                make_obj_guard(*env, &JNIEnv::ReleaseByteArrayElements,
-                               pixels, elements, 0);
-            boost::ignore_unused_variable_warning(elements_guard);
+            BOOST_SCOPE_EXIT((env)(pixels)(elements)) {
+                env->ReleaseByteArrayElements(pixels, elements, 0);
+            } BOOST_SCOPE_EXIT_END
             peer.reset(
                 new sfimage(
                     image(w, h, comp, elements, elements + (w * h * comp))));
@@ -2969,10 +2924,9 @@
         sfimage & peer = get_Field_peer<sfimage>(*env, obj);
         try {
             jbyte * const elements = env->GetByteArrayElements(pixels, NULL);
-            scope_guard elements_guard =
-                make_obj_guard(*env, &JNIEnv::ReleaseByteArrayElements,
-                               pixels, elements, 0);
-            boost::ignore_unused_variable_warning(elements_guard);
+            BOOST_SCOPE_EXIT((env)(pixels)(elements)) {
+                env->ReleaseByteArrayElements(pixels, elements, 0);
+            } BOOST_SCOPE_EXIT_END
             peer.value(image(width, height, components,
                              elements,
                              elements + (width * height * components)));
@@ -3269,12 +3223,9 @@
         if (jstr) {
             const char * str = env->GetStringUTFChars(jstr, 0);
             if (!str) { return 0; } // OutOfMemoryError
-            scope_guard str_guard =
-                make_obj_guard(*env,
-                               &JNIEnv::ReleaseStringUTFChars,
-                               jstr,
-                               str);
-            boost::ignore_unused_variable_warning(str_guard);
+            BOOST_SCOPE_EXIT((env)(jstr)(str)) {
+                env->ReleaseStringUTFChars(jstr, str);
+            } BOOST_SCOPE_EXIT_END
             peer.reset(new openvrml::sfstring(str));
         } else {
             peer.reset(new openvrml::sfstring);
@@ -3309,9 +3260,9 @@
         sfstring & sfstr = get_Field_peer<sfstring>(*env, obj);
         const char * const str = env->GetStringUTFChars(jstr, 0);
         if (!str) { return; } // OutOfMemoryError
-        scope_guard str_guard =
-            make_obj_guard(*env, &JNIEnv::ReleaseStringUTFChars, jstr, str);
-        boost::ignore_unused_variable_warning(str_guard);
+        BOOST_SCOPE_EXIT((env)(jstr)(str)) {
+            env->ReleaseStringUTFChars(jstr, str);
+        } BOOST_SCOPE_EXIT_END
         sfstr.value(str);
     } catch (std::exception & ex) {
         OPENVRML_PRINT_EXCEPTION_(ex);
@@ -4122,8 +4073,6 @@
         const jint size,
         const typename array_type<typename jni_type<typename FieldValue::value_type::value_type>::type>::type array)
     {
-        using boost::ref;
-
         typedef typename jni_type<
             typename FieldValue::value_type::value_type>::type elem_t;
 
@@ -4135,10 +4084,9 @@
         }
         elem_t * const elements = get_array_elements<elem_t>(env, array);
         if (!elements) { return 0; }
-        scope_guard elements_guard =
-            make_guard(release_array_elements<elem_t>,
-                       ref(env), array, elements);
-        boost::ignore_unused_variable_warning(elements_guard);
+        BOOST_SCOPE_EXIT_TPL((&env)(array)(elements)) {
+            release_array_elements<elem_t>(env, array, elements);
+        } BOOST_SCOPE_EXIT_END
         std::auto_ptr<FieldValue> peer;
         try {
             const typename FieldValue::value_type vec(elements,
@@ -4682,10 +4630,9 @@
     }
     jfloat * c = env->GetFloatArrayElements(jarr, 0);
     if (!c) { return 0; }
-    scope_guard c_guard =
-        make_obj_guard(*env, &JNIEnv::ReleaseFloatArrayElements,
-                       jarr, c, 0);
-    boost::ignore_unused_variable_warning(c_guard);
+    BOOST_SCOPE_EXIT((env)(jarr)(c)) {
+        env->ReleaseFloatArrayElements(jarr, c, 0);
+    } BOOST_SCOPE_EXIT_END
     std::auto_ptr<openvrml::mfcolor> peer;
     try {
         openvrml::mfcolor::value_type vec(size);
@@ -4724,10 +4671,9 @@
                 // Presumably we raised an OutOfMemoryError.
                 return 0;
             }
-            scope_guard c_guard =
-                make_obj_guard(*env, &JNIEnv::ReleaseFloatArrayElements,
-                               element, c, 0);
-            boost::ignore_unused_variable_warning(c_guard);
+            BOOST_SCOPE_EXIT((env)(element)(c)) {
+                env->ReleaseFloatArrayElements(element, c, 0);
+            } BOOST_SCOPE_EXIT_END
             vec[i] = openvrml::make_color(c[0], c[1], c[2]);
         }
         peer.reset(new openvrml::mfcolor(vec));
@@ -5465,9 +5411,9 @@
     try {
         for (jsize i = 0; i < jsize(mfn->value().size()); ++i) {
             if (env->PushLocalFrame(1) < 0) { throw std::bad_alloc(); }
-            scope_guard local_frame_guard =
-                make_obj_guard(*env, &JNIEnv::PopLocalFrame, jobject(0));
-            boost::ignore_unused_variable_warning(local_frame_guard);
+            BOOST_SCOPE_EXIT((env)) {
+                env->PopLocalFrame(0);
+            } BOOST_SCOPE_EXIT_END
 
             const jobject node = create_Node(*env, mfn->value()[i]);
             env->SetObjectArrayElement(nodes, i, node);
@@ -5687,10 +5633,9 @@
     }
     jfloat * r = env->GetFloatArrayElements(jarr, 0);
     if (!r) { return 0; }
-    scope_guard r_guard =
-        make_obj_guard(*env, &JNIEnv::ReleaseFloatArrayElements,
-                       jarr, r, 0);
-    boost::ignore_unused_variable_warning(r_guard);
+    BOOST_SCOPE_EXIT((env)(jarr)(r)) {
+        env->ReleaseFloatArrayElements(jarr, r, 0);
+    } BOOST_SCOPE_EXIT_END
     std::auto_ptr<openvrml::mfrotation> peer;
     try {
         openvrml::mfrotation::value_type vec(size);
@@ -5795,10 +5740,9 @@
                 // Presumably we raised an OutOfMemoryError.
                 return 0;
             }
-            scope_guard r_guard =
-                make_obj_guard(*env, &JNIEnv::ReleaseFloatArrayElements,
-                               element, r, 0);
-            boost::ignore_unused_variable_warning(r_guard);
+            BOOST_SCOPE_EXIT((env)(element)(r)) {
+                env->ReleaseFloatArrayElements(element, r, 0);
+            } BOOST_SCOPE_EXIT_END
             vec[i] = openvrml::make_rotation(r[0], r[1], r[2], r[3]);
         }
         peer.reset(new openvrml::mfrotation(vec));
@@ -5823,10 +5767,9 @@
     }
     jfloat * r = env->GetFloatArrayElements(jarr, 0);
     if (!r) { return 0; }
-    scope_guard r_guard =
-        make_obj_guard(*env, &JNIEnv::ReleaseFloatArrayElements,
-                       jarr, r, 0);
-    boost::ignore_unused_variable_warning(r_guard);
+    BOOST_SCOPE_EXIT((env)(jarr)(r)) {
+        env->ReleaseFloatArrayElements(jarr, r, 0);
+    } BOOST_SCOPE_EXIT_END
     std::auto_ptr<openvrml::mfrotation> peer;
     try {
         openvrml::mfrotation::value_type vec(size);
@@ -6075,9 +6018,9 @@
             if (!el) { return 0; } // ArrayIndexOutOfBoundsException
             const char * const temp = env->GetStringUTFChars(el, 0);
             if (!temp) { return 0; } // OutOfMemoryError
-            scope_guard temp_guard =
-                make_obj_guard(*env, &JNIEnv::ReleaseStringUTFChars, el, temp);
-            boost::ignore_unused_variable_warning(temp_guard);
+            BOOST_SCOPE_EXIT((env)(el)(temp)) {
+                env->ReleaseStringUTFChars(el, temp);
+            } BOOST_SCOPE_EXIT_END
             vec[i] = temp;
         }
         peer.reset(new openvrml::mfstring(vec));
@@ -6187,10 +6130,9 @@
         try {
             const char * utf8chars = env->GetStringUTFChars(value, 0);
             if (!utf8chars) { return; } // OutOfMemoryError
-            scope_guard utf8chars_guard =
-                make_obj_guard(*env, &JNIEnv::ReleaseStringUTFChars,
-                               value, utf8chars);
-            boost::ignore_unused_variable_warning(utf8chars_guard);
+            BOOST_SCOPE_EXIT((env)(value)(utf8chars)) {
+                env->ReleaseStringUTFChars(value, utf8chars);
+            } BOOST_SCOPE_EXIT_END
             mfstring::value_type temp = mfstr.value();
             temp.at(index) = utf8chars;
             mfstr.value(temp);
@@ -6222,10 +6164,9 @@
         try {
             const char * utf8chars = env->GetStringUTFChars(value, 0);
             if (!utf8chars) { return; } // OutOfMemoryError
-            scope_guard utf8chars_guard =
-                make_obj_guard(*env, &JNIEnv::ReleaseStringUTFChars,
-                               value, utf8chars);
-            boost::ignore_unused_variable_warning(utf8chars_guard);
+            BOOST_SCOPE_EXIT((env)(value)(utf8chars)) {
+                env->ReleaseStringUTFChars(value, utf8chars);
+            } BOOST_SCOPE_EXIT_END
             mfstring::value_type temp = mfstr.value();
             temp.push_back(utf8chars);
             mfstr.value(temp);
@@ -6259,10 +6200,9 @@
         try {
             const char * utf8chars = env->GetStringUTFChars(value, 0);
             if (!utf8chars) { return; } // OutOfMemoryError
-            scope_guard utf8chars_guard =
-                make_obj_guard(*env, &JNIEnv::ReleaseStringUTFChars,
-                               value, utf8chars);
-            boost::ignore_unused_variable_warning(utf8chars_guard);
+            BOOST_SCOPE_EXIT((env)(value)(utf8chars)) {
+                env->ReleaseStringUTFChars(value, utf8chars);
+            } BOOST_SCOPE_EXIT_END
             mfstring::value_type temp = mfstr.value();
             temp.insert(temp.begin() + index, utf8chars);
             mfstr.value(temp);
@@ -6521,10 +6461,9 @@
                 // Presumably we raised an OutOfMemoryError.
                 return 0;
             }
-            scope_guard v_guard =
-                make_obj_guard(*env, &JNIEnv::ReleaseFloatArrayElements,
-                               element, v, 0);
-            boost::ignore_unused_variable_warning(v_guard);
+            BOOST_SCOPE_EXIT((env)(element)(v)) {
+                env->ReleaseFloatArrayElements(element, v, 0);
+            } BOOST_SCOPE_EXIT_END
             vec[i] = openvrml::make_vec2f(v[0], v[1]);
         }
         peer.reset(new openvrml::mfvec2f(vec));
@@ -6548,10 +6487,9 @@
     }
     jfloat * v = env->GetFloatArrayElements(jarr, 0);
     if (!v) { return 0; }
-    scope_guard v_guard =
-        make_obj_guard(*env, &JNIEnv::ReleaseFloatArrayElements,
-                       jarr, v, 0);
-    boost::ignore_unused_variable_warning(v_guard);
+    BOOST_SCOPE_EXIT((env)(jarr)(v)) {
+        env->ReleaseFloatArrayElements(jarr, v, 0);
+    } BOOST_SCOPE_EXIT_END
     std::auto_ptr<openvrml::mfvec2f> peer;
     try {
         openvrml::mfvec2f::value_type vec(size);
@@ -6750,10 +6688,9 @@
     }
     jdouble * v = env->GetDoubleArrayElements(jarr, 0);
     if (!v) { return 0; }
-    scope_guard v_guard =
-        make_obj_guard(*env, &JNIEnv::ReleaseDoubleArrayElements,
-                       jarr, v, 0);
-    boost::ignore_unused_variable_warning(v_guard);
+    BOOST_SCOPE_EXIT((env)(jarr)(v)) {
+        env->ReleaseDoubleArrayElements(jarr, v, 0);
+    } BOOST_SCOPE_EXIT_END
     std::auto_ptr<openvrml::mfvec2d> peer;
     try {
         openvrml::mfvec2d::value_type vec(size);
@@ -6858,10 +6795,9 @@
                 // Presumably we raised an OutOfMemoryError.
                 return 0;
             }
-            scope_guard v_guard =
-                make_obj_guard(*env, &JNIEnv::ReleaseDoubleArrayElements,
-                               element, v, 0);
-            boost::ignore_unused_variable_warning(v_guard);
+            BOOST_SCOPE_EXIT((env)(element)(v)) {
+                env->ReleaseDoubleArrayElements(element, v, 0);
+            } BOOST_SCOPE_EXIT_END
             vec[i] = openvrml::make_vec2d(v[0], v[1]);
         }
         peer.reset(new openvrml::mfvec2d(vec));
@@ -6885,10 +6821,9 @@
     }
     jdouble * v = env->GetDoubleArrayElements(jarr, 0);
     if (!v) { return 0; }
-    scope_guard v_guard =
-        make_obj_guard(*env, &JNIEnv::ReleaseDoubleArrayElements,
-                       jarr, v, 0);
-    boost::ignore_unused_variable_warning(v_guard);
+    BOOST_SCOPE_EXIT((env)(jarr)(v)) {
+        env->ReleaseDoubleArrayElements(jarr, v, 0);
+    } BOOST_SCOPE_EXIT_END
     std::auto_ptr<openvrml::mfvec2d> peer;
     try {
         openvrml::mfvec2d::value_type vec(size);
@@ -7164,10 +7099,9 @@
                 // Presumably we raised an OutOfMemoryError.
                 return 0;
             }
-            scope_guard v_guard =
-                make_obj_guard(*env, &JNIEnv::ReleaseFloatArrayElements,
-                               element, v, 0);
-            boost::ignore_unused_variable_warning(v_guard);
+            BOOST_SCOPE_EXIT((env)(element)(v)) {
+                env->ReleaseFloatArrayElements(element, v, 0);
+            } BOOST_SCOPE_EXIT_END
             vec[i] = openvrml::make_vec3f(v[0], v[1], v[2]);
         }
         peer.reset(new openvrml::mfvec3f(vec));
@@ -7191,10 +7125,9 @@
     }
     jfloat * v = env->GetFloatArrayElements(jarr, 0);
     if (!v) { return 0; }
-    scope_guard v_guard =
-        make_obj_guard(*env, &JNIEnv::ReleaseFloatArrayElements,
-                       jarr, v, 0);
-    boost::ignore_unused_variable_warning(v_guard);
+    BOOST_SCOPE_EXIT((env)(jarr)(v)) {
+        env->ReleaseFloatArrayElements(jarr, v, 0);
+    } BOOST_SCOPE_EXIT_END
     std::auto_ptr<openvrml::mfvec3f> peer;
     try {
         openvrml::mfvec3f::value_type vec(size);
@@ -7476,10 +7409,9 @@
                 // Presumably we raised an OutOfMemoryError.
                 return 0;
             }
-            scope_guard v_guard =
-                make_obj_guard(*env, &JNIEnv::ReleaseDoubleArrayElements,
-                               element, v, 0);
-            boost::ignore_unused_variable_warning(v_guard);
+            BOOST_SCOPE_EXIT((env)(element)(v)) {
+                env->ReleaseDoubleArrayElements(element, v, 0);
+            } BOOST_SCOPE_EXIT_END
             vec[i] = openvrml::make_vec3d(v[0], v[1], v[2]);
         }
         peer.reset(new openvrml::mfvec3d(vec));
@@ -7503,10 +7435,9 @@
     }
     jdouble * v = env->GetDoubleArrayElements(jarr, 0);
     if (!v) { return 0; }
-    scope_guard v_guard =
-        make_obj_guard(*env, &JNIEnv::ReleaseDoubleArrayElements,
-                       jarr, v, 0);
-    boost::ignore_unused_variable_warning(v_guard);
+    BOOST_SCOPE_EXIT((env)(jarr)(v)) {
+        env->ReleaseDoubleArrayElements(jarr, v, 0);
+    } BOOST_SCOPE_EXIT_END
     std::auto_ptr<openvrml::mfvec3d> peer;
     try {
         openvrml::mfvec3d::value_type vec(size);
Index: src/script/javascript.cpp
===================================================================
--- src/script/javascript.cpp	(revision 4241)
+++ src/script/javascript.cpp	(revision 4242)
@@ -3,7 +3,7 @@
 // OpenVRML
 //
 // Copyright 1998  Chris Morley
-// Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007  Braden McDaniel
+// Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2010  Braden McDaniel
 //
 // This library is free software; you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
@@ -25,7 +25,7 @@
 # include <private.h>
 # include <jsapi.h>
 # include <boost/array.hpp>
-# include <boost/multi_index/detail/scope_guard.hpp>
+# include <boost/scope_exit.hpp>
 # include <algorithm>
 # include <iostream>
 # include <memory>
@@ -36,8 +36,6 @@
 #   include <config.h>
 # endif
 
-using namespace boost::multi_index::detail;  // for scope_guard
-
 namespace {
 
 # if OPENVRML_JSPROPERTYOP_USES_JSID
@@ -1139,9 +1137,9 @@
 
 # ifdef JS_THREADSAFE
         JS_SetContextThread(this->cx);
-        scope_guard context_thread_guard =
-            make_guard(&JS_ClearContextThread, this->cx);
-        boost::ignore_unused_variable_warning(context_thread_guard);
+        BOOST_SCOPE_EXIT((cx)) {
+            JS_ClearContextThread(cx);
+        } BOOST_SCOPE_EXIT_END
 # endif
 
         jsval fval, rval;

Index: src/node/vrml97/grouping_node_base.h
===================================================================
--- src/node/vrml97/grouping_node_base.h	(revision 4241)
+++ src/node/vrml97/grouping_node_base.h	(revision 4242)
@@ -2,7 +2,7 @@
 //
 // OpenVRML
 //
-// Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007  Braden McDaniel
+// Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2010  Braden McDaniel
 //
 // This library is free software; you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
@@ -23,7 +23,7 @@
 
 # include <openvrml/node_impl_util.h>
 # include <openvrml/viewer.h>
-# include <boost/multi_index/detail/scope_guard.hpp>
+# include <boost/scope_exit.hpp>
 
 namespace openvrml_node_vrml97 {
 
@@ -167,7 +167,6 @@
         OPENVRML_THROW1(std::bad_alloc)
     {
         using namespace openvrml;
-        using namespace boost::multi_index::detail;  // for scope_guard
 
         Derived & group = dynamic_cast<Derived &>(this->node());
 
@@ -190,19 +189,21 @@
                     // Throws std::bad_alloc.
                     //
                     children.push_back(*n);
-                    scope_guard guard =
-                        make_obj_guard(children, &children_t::pop_back);
+                    bool succeeded = false;
+                    BOOST_SCOPE_EXIT_TPL((&succeeded)(&children)) {
+                        if (!succeeded) { children.pop_back(); }
+                    } BOOST_SCOPE_EXIT_END
                     child_node * const child =
                         node_cast<child_node *>(n->get());
                     if (child) {
                         child->relocate(); // Throws std::bad_alloc.
                     }
-                    guard.dismiss();
+                    succeeded = true;
                 }
             }
         }
 
-        group.children_.mfnode::value(children);
+        group.children_.value(children);
 
         group.node::modified(true);
         group.bounding_volume_dirty(true);
@@ -353,7 +354,6 @@
         OPENVRML_THROW1(std::bad_alloc)
     {
         using namespace openvrml;
-        using namespace boost::multi_index::detail;  // for scope_guard
 
         typedef std::vector<boost::intrusive_ptr<openvrml::node> > children_t;
         children_t children;
@@ -367,12 +367,14 @@
             // least.
             //
             children.push_back(*n); // Throws std::bad_alloc.
-            scope_guard guard =
-                make_obj_guard(children, &children_t::pop_back);
+            bool succeeded = false;
+            BOOST_SCOPE_EXIT_TPL((&succeeded)(&children)) {
+                if (!succeeded) { children.pop_back(); }
+            } BOOST_SCOPE_EXIT_END
             child_node * const child =
                 node_cast<child_node *>(n->get());
             if (child) { child->relocate(); } // Throws std::bad_alloc.
-            guard.dismiss();
+            succeeded = true;
         }
 
         this->children_.mfnode::value(children);

Index: src/node/vrml97/image_stream_listener.cpp
===================================================================
--- src/node/vrml97/image_stream_listener.cpp	(revision 4241)
+++ src/node/vrml97/image_stream_listener.cpp	(revision 4242)
@@ -2,7 +2,7 @@
 //
 // OpenVRML
 //
-// Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007  Braden McDaniel
+// Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2010  Braden McDaniel
 //
 // This library is free software; you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
@@ -24,7 +24,7 @@
 
 # include <sstream>
 # include <boost/algorithm/string/predicate.hpp>
-# include <boost/multi_index/detail/scope_guard.hpp>
+# include <boost/scope_exit.hpp>
 # include "image_stream_listener.h"
 
 openvrml_node_vrml97::image_stream_listener::image_reader::~image_reader()
@@ -208,14 +208,15 @@
     stream_listener(stream_listener),
     gray_palette(false)
 {
-    using namespace boost::multi_index::detail;  // for scope_guard
     this->png_ptr_ =
         png_create_read_struct(PNG_LIBPNG_VER_STRING, 0, 0, 0);
     if (!this->png_ptr_) { throw std::bad_alloc(); }
-    scope_guard guard = make_guard(&png_destroy_read_struct,
-                                   &this->png_ptr_,
-                                   &this->info_ptr_,
-                                   png_infopp(0));
+    bool succeeded = false;
+    BOOST_SCOPE_EXIT((&succeeded)(&png_ptr_)(&info_ptr_)) {
+        if (!succeeded) {
+            png_destroy_read_struct(&png_ptr_, &info_ptr_, png_infopp(0));
+        }
+    } BOOST_SCOPE_EXIT_END
 
     this->info_ptr_ = png_create_info_struct(this->png_ptr_);
     if (!this->info_ptr_) { throw std::bad_alloc(); }
@@ -225,7 +226,7 @@
                                 openvrml_png_info_callback,
                                 openvrml_png_row_callback,
                                 openvrml_png_end_callback);
-    guard.dismiss();
+    succeeded = true;
 }
 
 openvrml_node_vrml97::image_stream_listener::png_reader::~png_reader()
Index: src/node/vrml97/text.cpp
===================================================================
--- src/node/vrml97/text.cpp	(revision 4241)
+++ src/node/vrml97/text.cpp	(revision 4242)
@@ -3,7 +3,8 @@
 // OpenVRML
 //
 // Copyright 1998  Chris Morley
-// Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007  Braden McDaniel
+// Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010
+//   Braden McDaniel
 // Copyright 2002  S. K. Bose
 //
 // This library is free software; you can redistribute it and/or modify it
@@ -41,7 +42,7 @@
 #   endif
 # endif
 # include <boost/array.hpp>
-# include <boost/multi_index/detail/scope_guard.hpp>
+# include <boost/scope_exit.hpp>
 # include <boost/ptr_container/ptr_vector.hpp>
 
 # ifdef HAVE_CONFIG_H
@@ -1237,7 +1238,6 @@
         advance_height_(0)
     {
         using std::vector;
-        using namespace boost::multi_index::detail;  // for scope_guard
 
         FT_Error error = FT_Err_Ok;
         error = FT_Load_Glyph(face, glyph_index, FT_LOAD_NO_SCALE);
@@ -1245,7 +1245,9 @@
         FT_Glyph glyph;
         error = FT_Get_Glyph(face->glyph, &glyph);
         assert(error == FT_Err_Ok);
-        scope_guard glyph_guard = make_guard(FT_Done_Glyph, glyph);
+        BOOST_SCOPE_EXIT((&glyph)) {
+            FT_Done_Glyph(glyph);
+        } BOOST_SCOPE_EXIT_END
         static FT_Outline_Funcs outlineFuncs = { moveTo_,
                                                  lineTo_,
                                                  conicTo_,
@@ -2342,8 +2344,6 @@
     {
         using std::vector;
 # ifdef _WIN32
-        using namespace boost::multi_index::detail;  // for scope_guard
-
         LOGFONT lf;
         lf.lfHeight =         0;
         lf.lfWidth =          0;
@@ -2360,7 +2360,9 @@
         lf.lfPitchAndFamily = VARIABLE_PITCH | FF_ROMAN;
 
         HDC hdc = CreateCompatibleDC(0);
-        scope_guard hdc_guard = make_guard(&DeleteDC, hdc);
+        BOOST_SCOPE_EXIT((hdc)) {
+            DeleteDC(hdc);
+        } BOOST_SCOPE_EXIT_END
         HFONT hfont = CreateFontIndirect(&lf);
         SelectObject(hdc, hfont);
         TCHAR faceName[256] = {};
@@ -2388,7 +2390,9 @@
                 KEY_READ,
                 &fontsKey);
         if (result != ERROR_SUCCESS) { /* bail */ }
-        scope_guard fontsKey_guard = make_guard(&RegCloseKey, fontsKey);
+        BOOST_SCOPE_EXIT((fontsKey)) {
+            RegCloseKey(fontsKey);
+        } BOOST_SCOPE_EXIT_END
 
         DWORD maxValueNameLen, maxValueLen;
         result = RegQueryInfoKey(fontsKey,
@@ -2453,7 +2457,6 @@
         face_index = 0;
 # else
         using std::string;
-        using namespace boost::multi_index::detail;  // for scope_guard
 
         string fontName;
         //
@@ -2496,9 +2499,9 @@
             FcNameParse(unsigned_char_string(fontName.begin(),
                                              fontName.end()).c_str());
         if (!initialPattern) { throw std::bad_alloc(); }
-        scope_guard initialPattern_guard =
-            make_guard(&FcPatternDestroy, initialPattern);
-        boost::ignore_unused_variable_warning(initialPattern_guard);
+        BOOST_SCOPE_EXIT((initialPattern)) {
+            FcPatternDestroy(initialPattern);
+        } BOOST_SCOPE_EXIT_END
 
         //
         // Set the language.
@@ -2517,9 +2520,9 @@
             FcFontMatch(0, initialPattern, &result);
         if (result != FcResultMatch) { throw FontconfigError(result); }
         assert(matchedPattern);
-        scope_guard matchedPattern_guard =
-            make_guard(&FcPatternDestroy, matchedPattern);
-        boost::ignore_unused_variable_warning(matchedPattern_guard);
+        BOOST_SCOPE_EXIT((matchedPattern)) {
+            FcPatternDestroy(matchedPattern);
+        } BOOST_SCOPE_EXIT_END
 
         FcChar8 * filename_c_str = 0;
         result = FcPatternGetString(matchedPattern,

Index: src/libopenvrml/openvrml/local/uri.cpp
===================================================================
--- src/libopenvrml/openvrml/local/uri.cpp	(revision 4241)
+++ src/libopenvrml/openvrml/local/uri.cpp	(revision 4242)
@@ -2,7 +2,7 @@
 //
 // OpenVRML
 //
-// Copyright 2008  Braden McDaniel
+// Copyright 2008, 2010  Braden McDaniel
 //
 // This library is free software; you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
@@ -23,8 +23,7 @@
 # include <cerrno>
 # include <cstring>
 # ifdef _WIN32
-#   include <boost/multi_index/detail/scope_guard.hpp>
-using namespace boost::multi_index::detail;  // for scope_guard
+#   include <boost/scope_exit.hpp>
 # endif
 
 openvrml::local::uri::uri() OPENVRML_THROW1(std::bad_alloc):
@@ -552,7 +551,9 @@
         using boost::ref;
         DWORD error = GetLastError();
         void * msgBuf = 0;
-        scope_guard msgBuf_guard = make_guard(LocalFree, ref(msgBuf));
+        BOOST_SCOPE_EXIT((&msgBuf)) {
+            LocalFree(msgBuf);
+        } BOOST_SCOPE_EXIT_END
         FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                       | FORMAT_MESSAGE_FROM_SYSTEM
                       | FORMAT_MESSAGE_IGNORE_INSERTS,
@@ -578,7 +579,9 @@
         using boost::ref;
         DWORD error = GetLastError();
         void * msgBuf = 0;
-        scope_guard msgBuf_guard = make_guard(LocalFree, ref(msgBuf));
+        BOOST_SCOPE_EXIT((&msgBuf)) {
+            LocalFree(msgBuf);
+        } BOOST_SCOPE_EXIT_END
         FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                       | FORMAT_MESSAGE_FROM_SYSTEM
                       | FORMAT_MESSAGE_IGNORE_INSERTS,

Index: src/libopenvrml/openvrml/local/node_metatype_registry_impl.cpp
===================================================================
--- src/libopenvrml/openvrml/local/node_metatype_registry_impl.cpp	(revision 4241)
+++ src/libopenvrml/openvrml/local/node_metatype_registry_impl.cpp	(revision 4242)
@@ -2,7 +2,7 @@
 //
 // OpenVRML
 //
-// Copyright 2008  Braden McDaniel
+// Copyright 2008, 2010  Braden McDaniel
 //
 // This library is free software; you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
@@ -21,12 +21,10 @@
 # include "node_metatype_registry_impl.h"
 # include "conf.h"
 # include <openvrml/browser.h>
-# include <boost/multi_index/detail/scope_guard.hpp>
+# include <boost/scope_exit.hpp>
 # include <iostream>
 # include <sstream>
 
-using namespace boost::multi_index::detail;  // for scope_guard
-
 const std::string openvrml::local::node_metatype_registry_impl::sym =
     "openvrml_register_node_metatypes";
 
@@ -43,7 +41,10 @@
         std::cerr << dl::error() << std::endl;
         return 0;
     }
-    scope_guard handle_guard = make_guard(dl::close, handle);
+    bool succeeded = false;
+    BOOST_SCOPE_EXIT((&succeeded)(handle)) {
+        if (!succeeded) { dl::close(handle); }
+    } BOOST_SCOPE_EXIT_END
 
     //
     // Make sure the module has what we're looking for.
@@ -52,9 +53,8 @@
         dl::sym(handle, openvrml::local::node_metatype_registry_impl::sym);
     if (!sym) { return 0; } // handle_guard will close the module.
 
-    const bool succeeded = registry.module_handles_.insert(handle).second;
+    succeeded = registry.module_handles_.insert(handle).second;
     assert(succeeded);
-    handle_guard.dismiss();
     return 0;
 }
 

Index: src/libopenvrml/openvrml/local/xml_reader.cpp
===================================================================
--- src/libopenvrml/openvrml/local/xml_reader.cpp	(revision 4241)
+++ src/libopenvrml/openvrml/local/xml_reader.cpp	(revision 4242)
@@ -2,7 +2,7 @@
 //
 // OpenVRML
 //
-// Copyright 2008  Braden McDaniel
+// Copyright 2008, 2010  Braden McDaniel
 //
 // This library is free software; you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
@@ -21,8 +21,7 @@
 # include "xml_reader.h"
 # ifdef _WIN32
 #   include <shlwapi.h>
-#   include <boost/multi_index/detail/scope_guard.hpp>
-using namespace boost::multi_index::detail;  // for scope_guard
+#   include <boost/scope_exit.hpp>
 # endif
 
 /**
@@ -125,31 +124,33 @@
 {
 # ifdef _WIN32
     HRESULT hr;
+    bool succeeded = false;
 
     hr = SHCreateStreamOnFile(filename.c_str(), STGM_READ, &this->input);
+    BOOST_SCOPE_EXIT((&succeeded)(&input)) {
+        if (!succeeded && input) { input->Release(); }
+    } BOOST_SCOPE_EXIT_END
     if (FAILED(hr)) {
         throw std::runtime_error("failed to open file \"" + filename
                                  + '\"');
     }
-    scope_guard input_guard =
-        make_obj_guard(*this->input, &IStream::Release);
 
     hr = CreateXmlReader(__uuidof(IXmlReader),
                          reinterpret_cast<void **>(&this->reader),
                          0);
+    BOOST_SCOPE_EXIT((&succeeded)(&reader)) {
+        if (!succeeded && reader) { reader->Release(); }
+    } BOOST_SCOPE_EXIT_END
     if (FAILED(hr)) {
         throw std::runtime_error("failed to create XML reader");
     }
-    scope_guard reader_guard =
-        make_obj_guard(*this->reader, &IXmlReader::Release);
 
     hr = this->reader->SetInput(this->input);
     if (FAILED(hr)) {
         throw std::runtime_error("failed to set input for XML reader");
     }
 
-    input_guard.dismiss();
-    reader_guard.dismiss();
+    succeeded = true;
 # else
     static const char * const encoding = 0;
     static const int options = 0;
Index: src/libopenvrml/openvrml/local/conf.cpp
===================================================================
--- src/libopenvrml/openvrml/local/conf.cpp	(revision 4241)
+++ src/libopenvrml/openvrml/local/conf.cpp	(revision 4242)
@@ -2,7 +2,7 @@
 //
 // OpenVRML
 //
-// Copyright 2009  Braden McDaniel
+// Copyright 2009, 2010  Braden McDaniel
 //
 // This library is free software; you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
@@ -20,7 +20,6 @@
 
 # include "conf.h"
 # include "error.h"
-# include <boost/multi_index/detail/scope_guard.hpp>
 # include <boost/ref.hpp>
 # include <boost/tokenizer.hpp>
 # ifdef _WIN32
@@ -30,8 +29,6 @@
 #   include <cstdlib>
 # endif
 
-using namespace boost::multi_index::detail;  // for scope_guard
-
 namespace {
 
     class OPENVRML_LOCAL no_environment_var : public std::runtime_error {
Index: src/libopenvrml/openvrml/local/externproto.cpp
===================================================================
--- src/libopenvrml/openvrml/local/externproto.cpp	(revision 4241)
+++ src/libopenvrml/openvrml/local/externproto.cpp	(revision 4242)
@@ -2,7 +2,7 @@
 //
 // OpenVRML
 //
-// Copyright 2009  Braden McDaniel
+// Copyright 2009, 2010  Braden McDaniel
 //
 // This library is free software; you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
@@ -25,10 +25,8 @@
 # include <openvrml/scene.h>
 # include <boost/function.hpp>
 # include <boost/mpl/for_each.hpp>
-# include <boost/multi_index/detail/scope_guard.hpp>
+# include <boost/scope_exit.hpp>
 
-using namespace boost::multi_index::detail;  // for scope_guard
-
 struct OPENVRML_LOCAL openvrml::local::externproto_node_metatype::load_proto {
     load_proto(externproto_node_metatype & externproto_class,
                const openvrml::scene & scene,
@@ -52,12 +50,9 @@
                 using boost::shared_ptr;
                 using local::uri;
 
-                scope_guard guard =
-                    make_obj_guard(
-                        *this->externproto_node_metatype_,
-                        &externproto_node_metatype::
-                            clear_externproto_node_types);
-                boost::ignore_unused_variable_warning(guard);
+                BOOST_SCOPE_EXIT((&externproto_node_metatype_)) {
+                    externproto_node_metatype_->clear_externproto_node_types();
+                } BOOST_SCOPE_EXIT_END
 
                 auto_ptr<resource_istream> in =
                     this->scene_->get_resource(this->alt_uris_);
Index: src/libopenvrml/openvrml/local/error.cpp
===================================================================
--- src/libopenvrml/openvrml/local/error.cpp	(revision 4241)
+++ src/libopenvrml/openvrml/local/error.cpp	(revision 4242)
@@ -2,7 +2,7 @@
 //
 // OpenVRML
 //
-// Copyright 2009  Braden McDaniel
+// Copyright 2009, 2010  Braden McDaniel
 //
 // This library is free software; you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
@@ -19,21 +19,17 @@
 //
 
 # include "error.h"
-# include <boost/multi_index/detail/scope_guard.hpp>
-# include <boost/ref.hpp>
+# include <boost/scope_exit.hpp>
 
-using namespace boost::multi_index::detail;  // for scope_guard
-
-
 # ifdef _WIN32
 void openvrml::local::throw_runtime_error_from_win32_system_error(LONG result)
     OPENVRML_THROW1(std::runtime_error)
 {
-    using boost::ref;
-
     static const LPCVOID source;
     LPTSTR buf = 0;
-    scope_guard buf_guard = make_guard(LocalFree, ref(buf));
+    BOOST_SCOPE_EXIT((&buf)) {
+        LocalFree(buf);
+    } BOOST_SCOPE_EXIT_END
     FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
                   | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                   source,
Index: src/libopenvrml/openvrml/browser.h
===================================================================
--- src/libopenvrml/openvrml/browser.h	(revision 4241)
+++ src/libopenvrml/openvrml/browser.h	(revision 4242)
@@ -215,8 +215,6 @@
                           std::vector<boost::intrusive_ptr<node> > & nodes,
                           std::map<std::string, std::string> & meta);
 
-        OPENVRML_LOCAL void send_initialized();
-
         boost::scoped_ptr<node_metatype_registry> node_metatype_registry_;
 
         const boost::scoped_ptr<null_node_metatype> null_node_metatype_;
Index: src/libopenvrml/openvrml/scene.cpp
===================================================================
--- src/libopenvrml/openvrml/scene.cpp	(revision 4241)
+++ src/libopenvrml/openvrml/scene.cpp	(revision 4242)
@@ -25,14 +25,12 @@
 # include <openvrml/local/parse_vrml.h>
 # include <private.h>
 # include <boost/function.hpp>
-# include <boost/multi_index/detail/scope_guard.hpp>
+# include <boost/scope_exit.hpp>
 
 # ifdef HAVE_CONFIG_H
 #   include <config.h>
 # endif
 
-using namespace boost::multi_index::detail;  // for scope_guard
-
 /**
  * @file openvrml/scene.h
  *
@@ -180,8 +178,10 @@
     //
     // Ensure that scene_loaded gets called even if parsing throws.
     //
-    scope_guard scene_loaded_guard =
-        make_obj_guard(*this, &scene::scene_loaded);
+    scene & self = *this;
+    BOOST_SCOPE_EXIT((&self)) {
+        self.scene_loaded();
+    } BOOST_SCOPE_EXIT_END
 
     {
         using boost::unique_lock;

Index: src/libopenvrml/openvrml/script.cpp
===================================================================
--- src/libopenvrml/openvrml/script.cpp	(revision 4241)
+++ src/libopenvrml/openvrml/script.cpp	(revision 4242)
@@ -3,7 +3,8 @@
 // OpenVRML
 //
 // Copyright 1998  Chris Morley
-// Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007  Braden McDaniel
+// Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+//   Braden McDaniel
 //
 // This library is free software; you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
@@ -31,7 +32,7 @@
 # include <boost/functional.hpp>
 # include <boost/lexical_cast.hpp>
 # include <boost/mpl/for_each.hpp>
-# include <boost/multi_index/detail/scope_guard.hpp>
+# include <boost/scope_exit.hpp>
 # include <boost/utility.hpp>
 # include <algorithm>
 # include <functional>
@@ -40,9 +41,6 @@
 #   include <config.h>
 # endif
 
-
-using namespace boost::multi_index::detail;  // for scope_guard
-
  /**
  * @file openvrml/script.h
  *
@@ -415,7 +413,10 @@
 
     const dl::handle handle = dl::open(filename);
     if (!handle) { return 0; } // Ignore things we can't open.
-    scope_guard handle_guard = make_guard(dl::close, handle);
+    bool succeeded = false;
+    BOOST_SCOPE_EXIT((&succeeded)(handle)) {
+        if (!succeeded) { dl::close(handle); }
+    } BOOST_SCOPE_EXIT_END
 
     //
     // Make sure the module has what we're looking for.
@@ -423,9 +424,8 @@
     const void * sym = dl::sym(handle, "openvrml_script_LTX_register_factory");
     if (!sym) { return 0; } // handle_guard will close the module.
 
-    const bool succeeded = registry.module_handles_.insert(handle).second;
+    succeeded = registry.module_handles_.insert(handle).second;
     assert(succeeded);
-    handle_guard.dismiss();
     return 0;
 }
 
@@ -1954,8 +1954,10 @@
     // nodes.
     //
     this->add_ref();
-    scope_guard guard = make_obj_guard(*this, &script_node::remove_ref);
-    boost::ignore_unused_variable_warning(guard);
+    script_node & self = *this;
+    BOOST_SCOPE_EXIT((&self)) {
+        self.remove_ref();
+    } BOOST_SCOPE_EXIT_END
 
     for (node_interface_set::const_iterator interface_ = interfaces.begin();
          interface_ != interfaces.end();

Index: src/libopenvrml/openvrml/browser.cpp
===================================================================
--- src/libopenvrml/openvrml/browser.cpp	(revision 4241)
+++ src/libopenvrml/openvrml/browser.cpp	(revision 4242)
@@ -3,7 +3,8 @@
 // OpenVRML
 //
 // Copyright 1998  Chris Morley
-// Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007  Braden McDaniel
+// Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+//   Braden McDaniel
 //
 // This library is free software; you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
@@ -32,7 +33,7 @@
 # include <boost/function.hpp>
 # include <boost/functional.hpp>
 # include <boost/lexical_cast.hpp>
-# include <boost/multi_index/detail/scope_guard.hpp>
+# include <boost/scope_exit.hpp>
 # include <algorithm>
 # include <functional>
 # include <cerrno>
@@ -48,8 +49,6 @@
 #   include <config.h>
 # endif
 
-using namespace boost::multi_index::detail;  // for scope_guard
-
 /**
  * @file openvrml/browser.h
  *
@@ -1873,18 +1872,6 @@
     return this->scene_->url(); // Throws std::bad_alloc.
 }
 
-void openvrml::browser::send_initialized()
-{
-    using boost::shared_lock;
-    using boost::shared_mutex;
-
-    shared_lock<shared_mutex> listeners_lock(this->listeners_mutex_);
-    for_each(this->listeners_.begin(), this->listeners_.end(),
-             boost::bind2nd(
-                 boost::mem_fun(&browser_listener::browser_changed),
-                 browser_event(*this, browser_event::initialized)));
-}
-
 /**
  * @brief Set the world from a stream.
  *
@@ -1903,9 +1890,18 @@
     //
     // Ensure that the "initialized" event is sent even if parsing throws.
     //
-    scope_guard initialized_event_guard =
-        make_obj_guard(*this, &browser::send_initialized);
+    browser & self = *this;
+    shared_mutex & listeners_mutex = this->listeners_mutex_;
+    std::set<browser_listener *> & listeners = this->listeners_;
 
+    BOOST_SCOPE_EXIT((&self)(&listeners_mutex)(&listeners)) {
+        shared_lock<shared_mutex> listeners_lock(listeners_mutex);
+        for_each(listeners.begin(), listeners.end(),
+                 boost::bind2nd(
+                     boost::mem_fun(&browser_listener::browser_changed),
+                     browser_event(self, browser_event::initialized)));
+    } BOOST_SCOPE_EXIT_END
+
     {
         using std::string;
         using boost::upgrade_lock;
Index: src/local/libopenvrml-dl/openvrml/local/dl.cpp
===================================================================
--- src/local/libopenvrml-dl/openvrml/local/dl.cpp	(revision 4241)
+++ src/local/libopenvrml-dl/openvrml/local/dl.cpp	(revision 4242)
@@ -2,7 +2,7 @@
 //
 // OpenVRML
 //
-// Copyright 2008  Braden McDaniel
+// Copyright 2008, 2009, 2010  Braden McDaniel
 //
 // This library is free software; you can redistribute it and/or modify it
 // under the terms of the GNU Lesser General Public License as published by
@@ -21,12 +21,10 @@
 # include "dl.h"
 # include <boost/filesystem.hpp>
 # include <boost/ref.hpp>
+# include <boost/scope_exit.hpp>
 # include <boost/tokenizer.hpp>
-# include <boost/multi_index/detail/scope_guard.hpp>
 # include <sstream>
 
-using namespace boost::multi_index::detail;  // for scope_guard
-
 int openvrml::local::dl::init()
 {
 # ifdef _WIN32
@@ -130,7 +128,9 @@
 # ifdef _WIN32
     const DWORD err = GetLastError();
     char * buf = 0;
-    scope_guard buf_guard = make_guard(LocalFree, boost::ref(buf));
+    BOOST_SCOPE_EXIT((buf)) {
+        LocalFree(buf);
+    } BOOST_SCOPE_EXIT_END
     static const LPCVOID source = 0;
     static const DWORD buf_size = 0;
     static va_list * const args = 0;
Index: src/openvrml-player/filechooserdialog.cpp
===================================================================
--- src/openvrml-player/filechooserdialog.cpp	(revision 4241)
+++ src/openvrml-player/filechooserdialog.cpp	(revision 4242)
@@ -1,6 +1,6 @@
 // -*- Mode: C++; indent-tabs-mode: nil; c-basic-offset: 4; fill-column: 78 -*-
 //
-// Copyright 2007  Braden McDaniel
+// Copyright 2007, 2010  Braden McDaniel
 //
 // This program is free software; you can redistribute it and/or modify it
 // under the terms of the GNU General Public License as published by the Free
@@ -17,12 +17,8 @@
 //
 
 # include <gtk/gtk.h>
-# include <boost/concept_check.hpp>
-# include <boost/multi_index/detail/scope_guard.hpp>
 # include "filechooserdialog.h"
 
-using namespace boost::multi_index::detail; // for scope_guard
-
 G_DEFINE_TYPE(OpenvrmlPlayerFileChooserDialog,
               openvrml_player_file_chooser_dialog,
               GTK_TYPE_FILE_CHOOSER_DIALOG)
@@ -67,26 +63,19 @@
 
         GtkFileFilter * const world_filter = gtk_file_filter_new();
         g_return_val_if_fail(world_filter, 0);
-        scope_guard world_filter_guard = make_guard(g_object_unref,
-                                                    world_filter);
-        boost::ignore_unused_variable_warning(world_filter_guard);
         gtk_file_filter_set_name(world_filter, "VRML/X3D worlds");
         gtk_file_filter_add_mime_type(world_filter, "x-world/x-vrml");
         gtk_file_filter_add_mime_type(world_filter, "model/vrml");
         gtk_file_filter_add_mime_type(world_filter, "model/x3d-vrml");
 
         gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(obj), world_filter);
-        world_filter_guard.dismiss();
 
         GtkFileFilter * const all_filter = gtk_file_filter_new();
         g_return_val_if_fail(all_filter, 0);
-        scope_guard all_filter_guard = make_guard(g_object_unref, all_filter);
-        boost::ignore_unused_variable_warning(all_filter_guard);
         gtk_file_filter_set_name(all_filter, "All files");
         gtk_file_filter_add_pattern(all_filter, "*");
 
         gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(obj), all_filter);
-        all_filter_guard.dismiss();
 
         return obj;
     }
Index: src/openvrml-player/curlbrowserhost.cpp
===================================================================
--- src/openvrml-player/curlbrowserhost.cpp	(revision 4241)
+++ src/openvrml-player/curlbrowserhost.cpp	(revision 4242)
@@ -1,7 +1,7 @@
 // -*- Mode: C++; indent-tabs-mode: nil; c-basic-offset: 4; fill-column: 78 -*-
 //
 // OpenVRML Player
-// Copyright 2008  Braden McDaniel
+// Copyright 2008, 2010  Braden McDaniel
 //
 // This program is free software; you can redistribute it and/or modify it
 // under the terms of the GNU General Public License as published by the Free
@@ -25,15 +25,12 @@
 # include <browser-client-glue.h>
 # include <dbus/dbus-glib-bindings.h>
 # include <dbus/dbus-protocol.h>
-# include <boost/concept_check.hpp>
-# include <boost/multi_index/detail/scope_guard.hpp>
+# include <boost/scope_exit.hpp>
 # include <boost/ref.hpp>
 # include <list>
 # include <vector>
 # include <string.h>
 
-using namespace boost::multi_index::detail; // for scope_guard
-
 # define OPENVRML_PLAYER_CURL_BROWSER_HOST_ERROR \
     openvrml_player_curl_browser_host_error_quark()
 
@@ -153,7 +150,9 @@
                      G_TYPE_NONE, 0);
 
     GError * error = 0;
-    scope_guard error_guard = make_guard(g_error_free, boost::ref(error));
+    BOOST_SCOPE_EXIT((&error)) {
+        if (error) { g_error_free(error); }
+    } BOOST_SCOPE_EXIT_END
     klass->connection = dbus_g_bus_get(DBUS_BUS_SESSION, &error);
     if (!klass->connection) {
         g_critical("Failed to open connection to bus: %s", error->message);
@@ -168,8 +167,9 @@
                                   DBUS_SERVICE_DBUS,
                                   DBUS_PATH_DBUS,
                                   DBUS_INTERFACE_DBUS);
-    scope_guard driver_proxy_guard = make_guard(g_object_unref, driver_proxy);
-    boost::ignore_unused_variable_warning(driver_proxy_guard);
+    BOOST_SCOPE_EXIT((driver_proxy)) {
+        g_object_unref(G_OBJECT(driver_proxy));
+    } BOOST_SCOPE_EXIT_END
 
     guint request_ret;
     if (!org_freedesktop_DBus_request_name(driver_proxy,
@@ -196,7 +196,6 @@
     dbus_g_object_type_install_info(
         OPENVRML_PLAYER_TYPE_CURL_BROWSER_HOST,
         &dbus_glib_openvrml_player_curl_browser_host_object_info);
-    error_guard.dismiss();
 }
 
 void openvrml_player_curl_browser_host_get_property(GObject * const obj,
@@ -258,7 +257,9 @@
         OPENVRML_PLAYER_CURL_BROWSER_HOST_CLASS(klass);
 
     GError * error = 0;
-    scope_guard error_guard = make_guard(g_error_free, boost::ref(error));
+    BOOST_SCOPE_EXIT((&error)) {
+        if (error) { g_error_free(error); }
+    } BOOST_SCOPE_EXIT_END
 
     g_assert(browser_host->priv->path);
     browser_host->priv->browser = get_browser(browser_host_class->connection,
@@ -283,14 +284,24 @@
 
     browser_host->priv->multi_handle = curl_multi_init();
     g_return_if_fail(browser_host->priv->multi_handle);
-    scope_guard multi_handle_guard =
-        make_guard(curl_multi_cleanup, browser_host->priv->multi_handle);
+    bool succeeded = false;
+    BOOST_SCOPE_EXIT((&succeeded)(&browser_host)) {
+        if (!succeeded) {
+            curl_multi_cleanup(browser_host->priv->multi_handle);
+        }
+    } BOOST_SCOPE_EXIT_END
 
     try {
+        bool succeeded = false;
+
         browser_host->priv->curl_source =
             curl_source_new(browser_host->priv->multi_handle);
-        scope_guard curl_source_guard =
-            make_guard(g_source_unref, browser_host->priv->curl_source);
+        BOOST_SCOPE_EXIT((&succeeded)(&browser_host)) {
+            if (!succeeded && browser_host->priv->curl_source) {
+                g_source_unref(browser_host->priv->curl_source);
+                browser_host->priv->curl_source = 0;
+            }
+        } BOOST_SCOPE_EXIT_END
 
         g_source_set_callback(
             browser_host->priv->curl_source,
@@ -298,8 +309,9 @@
             browser_host,
             0);
         guint source_id = g_source_attach(browser_host->priv->curl_source, 0);
-        scope_guard source_attach_guard =
-            make_guard(g_source_remove, source_id);
+        BOOST_SCOPE_EXIT((&succeeded)(source_id)) {
+            if (!succeeded && source_id != 0) { g_source_remove(source_id); }
+        } BOOST_SCOPE_EXIT_END
 
         browser_host->priv->stream_data =
             g_hash_table_new_full(
@@ -309,14 +321,12 @@
                 openvrml_player_curl_browser_host_delete_curl_stream_data);
         g_return_if_fail(browser_host->priv->stream_data);
 
-        source_attach_guard.dismiss();
-        curl_source_guard.dismiss();
+        succeeded = true;
     } catch (std::bad_alloc & ex) {
         g_critical("%s", ex.what());
     }
 
-    multi_handle_guard.dismiss();
-    error_guard.dismiss();
+    succeeded = true;
 }
 
 void openvrml_player_curl_browser_host_unrealize(GtkWidget * const widget)
@@ -459,14 +469,20 @@
 {
     CURL * const handle = curl_easy_init();
     try {
-        curl_stream_data * const stream_data =
-            new curl_stream_data(handle, url, host->priv->browser);
-        scope_guard stream_data_guard =
-            make_guard(
-                openvrml_player_curl_browser_host_delete_curl_stream_data,
-                stream_data);
-        g_hash_table_insert(host->priv->stream_data, handle, stream_data);
-        stream_data_guard.dismiss();
+        curl_stream_data * stream_data = 0;
+        {
+            bool succeeded = false;
+            stream_data =
+                new curl_stream_data(handle, url, host->priv->browser);
+            BOOST_SCOPE_EXIT((&succeeded)(stream_data)) {
+                if (!succeeded) {
+                    openvrml_player_curl_browser_host_delete_curl_stream_data(
+                        stream_data);
+                }
+            } BOOST_SCOPE_EXIT_END
+            g_hash_table_insert(host->priv->stream_data, handle, stream_data);
+            succeeded = true;
+        }
 
         CURLcode setopt_result;
         setopt_result = curl_easy_setopt(handle,
@@ -860,35 +876,38 @@
         CURL_BROWSER_HOST_CURL_EASY_RETURN_VAL_IF_ERROR(getinfo_result, 0);
 
         GError * error = 0;
+        BOOST_SCOPE_EXIT((&error)) {
+            if (error) { g_error_free(error); }
+        } BOOST_SCOPE_EXIT_END
+
         GFile * file = 0;
-        scope_guard file_guard = make_guard(g_object_unref, ref(file));
         GFileInfo * info = 0;
-        scope_guard info_guard = make_guard(g_object_unref, ref(info));
-        if (!type) {
-            file = g_file_new_for_uri(stream_data.url());
-            static GCancellable * const cancellable = 0;
-            info = g_file_query_info(file,
-                                     G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE,
-                                     G_FILE_QUERY_INFO_NONE,
-                                     cancellable,
-                                     &error);
-            if (error) {
-                g_warning(error->message);
-                g_error_free(error);
-                error = 0;
+        BOOST_SCOPE_EXIT((&type)(&file)(&info)) {
+            if (type) {
+                if (file) { g_object_unref(file); }
+                if (info) { g_object_unref(info); }
             }
-            if (info) {
-                type =
-                    g_file_info_get_attribute_string(
-                        info,
-                        G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE);
-            }
-        } else {
-            info_guard.dismiss();
-            file_guard.dismiss();
+        } BOOST_SCOPE_EXIT_END
+
+        file = g_file_new_for_uri(stream_data.url());
+        static GCancellable * const cancellable = 0;
+        info = g_file_query_info(file,
+                                 G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE,
+                                 G_FILE_QUERY_INFO_NONE,
+                                 cancellable,
+                                 &error);
+        if (error) {
+            g_warning(error->message);
+            g_error_free(error);
+            error = 0;
         }
+        if (info) {
+            type =
+                g_file_info_get_attribute_string(
+                    info,
+                    G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE);
+        }
 
-        scope_guard error_guard = make_guard(g_error_free, boost::ref(error));
         gboolean new_stream_result =
             org_openvrml_Browser_new_stream(
                 stream_data.browser(),
@@ -903,8 +922,6 @@
         }
 
         stream_data.initialize();
-
-        error_guard.dismiss();
     }
 
     //
@@ -950,9 +967,9 @@
                                       "/org/openvrml/BrowserFactory",
                                       "org.openvrml.BrowserFactory");
         g_return_val_if_fail(browser_factory, 0);
-        scope_guard browser_factory_guard =
-            make_guard(g_object_unref, G_OBJECT(browser_factory));
-        boost::ignore_unused_variable_warning(browser_factory_guard);
+        BOOST_SCOPE_EXIT((browser_factory)) {
+            g_object_unref(G_OBJECT(browser_factory));
+        } BOOST_SCOPE_EXIT_END
 
         char * browser_path = 0;
         if (!org_openvrml_BrowserFactory_create_control(
Index: src/openvrml-player/player.cpp
===================================================================
--- src/openvrml-player/player.cpp	(revision 4241)
+++ src/openvrml-player/player.cpp	(revision 4242)
@@ -1,6 +1,6 @@
 // -*- Mode: C++; indent-tabs-mode: nil; c-basic-offset: 4; fill-column: 78 -*-
 //
-// Copyright 2006, 2007, 2008  Braden McDaniel
+// Copyright 2006, 2007, 2008, 2010  Braden McDaniel
 //
 // This program is free software; you can redistribute it and/or modify it
 // under the terms of the GNU General Public License as published by the Free
@@ -19,9 +19,8 @@
 # include <curl/curl.h>
 # include <string>
 # include <vector>
-# include <boost/concept_check.hpp>
 # include <boost/lexical_cast.hpp>
-# include <boost/multi_index/detail/scope_guard.hpp>
+# include <boost/scope_exit.hpp>
 # include <boost/ref.hpp>
 # include <dbus/dbus-glib.h>
 # include <libgnomeui/libgnomeui.h>
@@ -35,8 +34,6 @@
 #   include <config.h>
 # endif
 
-using namespace boost::multi_index::detail; // for scope_guard
-
 extern "C" {
     //
     // GTK+ signal handlers; GtkBuilder needs them to have external linkage in
@@ -87,8 +84,9 @@
         g_critical("libcurl initialization failed");
         return EXIT_FAILURE;
     }
-    scope_guard curl_global_guard = make_guard(curl_global_cleanup);
-    boost::ignore_unused_variable_warning(curl_global_guard);
+    BOOST_SCOPE_EXIT() {
+        curl_global_cleanup();
+    } BOOST_SCOPE_EXIT_END
 
     gchar ** remaining_args = 0;
     GOptionEntry option_entries[] = {
@@ -123,7 +121,9 @@
             GNOME_PARAM_NONE);
 
     GError * error = 0;
-    scope_guard error_guard = make_guard(g_error_free, ref(error));
+    BOOST_SCOPE_EXIT((&error)) {
+        if (error) { g_error_free(error); }
+    } BOOST_SCOPE_EXIT_END
     GtkBuilder * const builder = builder_new(*program, &error);
     if (!builder) {
         g_critical("Failed to create UI builder: %s", error->message);
@@ -167,8 +167,6 @@
     gtk_widget_show_all(app_window);
 
     gtk_main();
-
-    error_guard.dismiss();
 }
 
 namespace {
@@ -251,8 +249,9 @@
         gchar * uri =
             gtk_file_chooser_get_uri(GTK_FILE_CHOOSER(data->file_chooser));
         g_return_if_fail(uri);
-        scope_guard uri_guard = make_guard(g_free, uri);
-        boost::ignore_unused_variable_warning(uri_guard);
+        BOOST_SCOPE_EXIT((uri)) {
+            g_free(uri);
+        } BOOST_SCOPE_EXIT_END
         openvrml_player_curl_browser_host_load_url(data->browser_host, uri);
     }
 
@@ -277,8 +276,9 @@
         gchar * uri = 0;
         uri = gtk_file_chooser_get_uri(GTK_FILE_CHOOSER(dialog));
         g_return_if_fail(uri);
-        scope_guard uri_guard = make_guard(g_free, uri);
-        boost::ignore_unused_variable_warning(uri_guard);
+        BOOST_SCOPE_EXIT((uri)) {
+            g_free(uri);
+        } BOOST_SCOPE_EXIT_END
         gtk_entry_set_text(location_entry, uri);
     }
 }

Index: README
===================================================================
--- README	(revision 4241)
+++ README	(revision 4242)
@@ -136,7 +136,7 @@
 
    At a minimum, OpenVRML requires these libraries to build:
 
-     Boost (at least 1.37)      <http://boost.org>
+     Boost (at least 1.38)      <http://boost.org>
      libltdl (non-Windows only) <http://www.gnu.org/software/libtool/>
      libxml (non-Windows only)  <http://xmlsoft.org>
 
Index: tests/browser.cpp
===================================================================
--- tests/browser.cpp	(revision 4241)
+++ tests/browser.cpp	(revision 4242)
@@ -1,6 +1,6 @@
 // -*- mode: c++; indent-tabs-mode: nil; c-basic-offset: 4; fill-column: 78 -*-
 //
-// Copyright 2005, 2006, 2007  Braden McDaniel
+// Copyright 2005, 2006, 2007, 2010  Braden McDaniel
 //
 // This program is free software; you can redistribute it and/or modify it
 // under the terms of the GNU General Public License as published by the Free
@@ -23,15 +23,13 @@
 # include <iostream>
 # include <sstream>
 # include <boost/filesystem/operations.hpp>
-# include <boost/multi_index/detail/scope_guard.hpp>
+# include <boost/scope_exit.hpp>
 # include <boost/thread.hpp>
 # include <boost/test/unit_test.hpp>
 # include "test_resource_fetcher.h"
 
 using namespace std;
 using namespace openvrml;
-using namespace boost::filesystem;
-using namespace boost::multi_index::detail; // for scope_guard
 
 BOOST_AUTO_TEST_CASE(create_vrml_from_stream)
 {
@@ -56,10 +54,9 @@
         file << "#VRML V2.0 utf8" << endl
              << "PROTO Node [] { Group {} }" << endl;
     }
-    scope_guard test_file_guard =
-        make_guard(&boost::filesystem::remove<boost::filesystem::path>,
-                   boost::filesystem::path("test.wrl"));
-    boost::ignore_unused_variable_warning(test_file_guard);
+    BOOST_SCOPE_EXIT() {
+        remove(boost::filesystem::path("test.wrl"));
+    } BOOST_SCOPE_EXIT_END
 
     const char vrmlstring[] = "EXTERNPROTO Node [] [ \"test.wrl\" ] Node {}";
     stringstream vrmlstream(vrmlstring);
@@ -110,10 +107,9 @@
         file << "#VRML V2.0 utf8" << endl
 	     << "Shape {}" << endl;
     }
-    scope_guard test_file_guard =
-        make_guard(&boost::filesystem::remove<boost::filesystem::path>,
-                   boost::filesystem::path("test.wrl"));
-    boost::ignore_unused_variable_warning(test_file_guard);
+    BOOST_SCOPE_EXIT() {
+        remove(boost::filesystem::path("test.wrl"));
+    } BOOST_SCOPE_EXIT_END
 
     test_resource_fetcher fetcher;
     browser b(fetcher, std::cout, std::cerr);
