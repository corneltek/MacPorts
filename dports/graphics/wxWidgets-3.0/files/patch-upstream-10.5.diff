http://trac.wxwidgets.org/ticket/15580
http://trac.wxwidgets.org/changeset/75024
http://trac.wxwidgets.org/changeset/75025
http://trac.wxwidgets.org/changeset/75028
http://trac.wxwidgets.org/changeset/75050

--- include/wx/fontutil.h
+++ include/wx/fontutil.h
@@ -142,9 +142,7 @@ public:
         return *this;
     }
 
-#if wxOSX_USE_CORE_TEXT
     void Init(CTFontDescriptorRef descr);
-#endif
     void Init(const wxNativeFontInfo& info);
     void Init(int size,
                   wxFontFamily family,
--- include/wx/osx/carbon/chkconf.h
+++ include/wx/osx/carbon/chkconf.h
@@ -30,22 +30,7 @@
  * text rendering system
  */
 
-#if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5
-
-    #define wxOSX_USE_CORE_TEXT 1
-    // MLTE-TextControl uses ATSU
-    #define wxOSX_USE_ATSU_TEXT 1
-
-#else // platform < 10.5
-
-    #if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
-        #define wxOSX_USE_CORE_TEXT 1
-    #else
-        #define wxOSX_USE_CORE_TEXT 0
-    #endif
-    #define wxOSX_USE_ATSU_TEXT 1
-
-#endif
+#define wxOSX_USE_ATSU_TEXT 1
 
 /*
  * Audio System
--- include/wx/osx/carbon/dataview.h
+++ include/wx/osx/carbon/dataview.h
@@ -155,9 +155,7 @@ public:
 
   OSStatus EnableCellSizeModification(bool enableHeight=true, bool enableWidth=true); // enables or disables the column width and row height modification (default: false)
 
-#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_4
   OSStatus GetAttributes        (OptionBits* attributes);
-#endif
   OSStatus GetColumnWidth       (DataBrowserPropertyID column, UInt16 *width ) const; // returns the column width in pixels
   OSStatus GetDefaultColumnWidth(UInt16 *width ) const; // returns the default column width in pixels
   OSStatus GetDefaultRowHeight  (UInt16 * height ) const;
@@ -166,9 +164,7 @@ public:
   OSStatus GetRowHeight         (DataBrowserItemID item , UInt16 *height) const;
   OSStatus GetScrollPosition    (UInt32* top, UInt32 *left) const;
 
-#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_4
   OSStatus SetAttributes (OptionBits attributes);
-#endif
   OSStatus SetColumnWidth(DataBrowserPropertyID column, UInt16 width); // sets the column width in pixels
   OSStatus SetDefaultColumnWidth( UInt16 width );
   OSStatus SetDefaultRowHeight( UInt16 height );
--- include/wx/osx/carbon/drawer.h
+++ include/wx/osx/carbon/drawer.h
@@ -22,8 +22,6 @@
 // near future
 //
 
-#if ( MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_2 )
-
 class WXDLLIMPEXP_ADV wxDrawerWindow : public wxTopLevelWindow
 {
     DECLARE_DYNAMIC_CLASS(wxDrawerWindow)
@@ -64,7 +62,4 @@ public:
     wxDirection GetCurrentEdge() const; // not necessarily the preferred, due to screen constraints
 };
 
-#endif // defined( __WXMAC__ ) && TARGET_API_MAC_OSX && ( MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_2 )
-
-#endif
-    // _WX_DRAWERWINDOW_H_
+#endif // _WX_DRAWERWINDOW_H_
--- include/wx/osx/carbon/private.h
+++ include/wx/osx/carbon/private.h
@@ -13,11 +13,6 @@
 #ifndef _WX_PRIVATE_H_
 #define _WX_PRIVATE_H_
 
-#if MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_5
-typedef UInt32 URefCon;
-typedef SInt32 SRefCon;
-#endif
-
 #if wxUSE_GUI
 
 #include "wx/osx/uma.h"
@@ -29,10 +24,6 @@ typedef SInt32 SRefCon;
 
 // app.h
 
-#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
-bool wxMacConvertEventToRecord( EventRef event , EventRecord *rec);
-#endif
-
 #endif // wxUSE_GUI
 
 // filefn.h
@@ -269,12 +260,6 @@ ControlActionUPP GetwxMacLiveScrollbarActionProc();
 
 // additional optional event defines
 
-#if MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_5
-enum {
-    kEventControlFocusPartChanged = 164
-};
-#endif
-
 class WXDLLIMPEXP_CORE wxMacControl : public wxWidgetImpl
 {
 public :
--- include/wx/osx/cocoa/chkconf.h
+++ include/wx/osx/cocoa/chkconf.h
@@ -41,33 +41,14 @@
  * text rendering system
  */
 
-#if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5
-
-    #define wxOSX_USE_CORE_TEXT 1
-    #define wxOSX_USE_ATSU_TEXT 0
-
-#else // platform < 10.5
-
-    #if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
-        #define wxOSX_USE_CORE_TEXT 1
-    #else
-        #define wxOSX_USE_CORE_TEXT 0
-    #endif
-    #define wxOSX_USE_ATSU_TEXT 1
-
-#endif
+#define wxOSX_USE_ATSU_TEXT 0
 
 /*
  * Audio System
  */
 
-#if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5
-    #define wxOSX_USE_QUICKTIME 0
-    #define wxOSX_USE_AUDIOTOOLBOX 1
-#else // platform < 10.5
-    #define wxOSX_USE_QUICKTIME 1
-    #define wxOSX_USE_AUDIOTOOLBOX 0
-#endif
+#define wxOSX_USE_QUICKTIME 0
+#define wxOSX_USE_AUDIOTOOLBOX 1
 
 /*
  * turning off capabilities that don't work under cocoa yet
--- include/wx/osx/cocoa/private.h
+++ include/wx/osx/cocoa/private.h
@@ -19,12 +19,6 @@
     #import <Cocoa/Cocoa.h>
 #endif
 
-#if MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_5
-// available in 10.4 but not in the headers
-enum {
-    kEventMouseScroll             = 11
-};
-#endif
 //
 // shared between Cocoa and Carbon
 //
--- include/wx/osx/config_xcode.h
+++ include/wx/osx/config_xcode.h
@@ -45,11 +45,7 @@
 #define WX_GMTOFF_IN_TM 1
 #define HAVE_PW_GECOS 1
 #define HAVE_DLOPEN 1
-#if MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_5
-/* #undef HAVE_CXA_DEMANGLE */
-#else
 #define HAVE_CXA_DEMANGLE 1
-#endif
 #define HAVE_GETTIMEOFDAY 1
 #define HAVE_FSYNC 1
 #define HAVE_ROUND 1
@@ -108,11 +104,7 @@
 #define HAVE_WCHAR_H 1
 /* better to use the built-in CF conversions, also avoid iconv versioning problems */
 /* #undef HAVE_ICONV */
-#if MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_5
-#define ICONV_CONST const
-#else
 #define ICONV_CONST
-#endif
 #define HAVE_LANGINFO_H 1
 #define HAVE_WCSRTOMBS 1
 #define HAVE_FPUTWS 1
--- include/wx/osx/font.h
+++ include/wx/osx/font.h
@@ -152,9 +152,7 @@ public:
     CGFontRef OSXGetCGFont() const;
 #endif
 
-#if wxOSX_USE_CORE_TEXT
     CTFontRef OSXGetCTFont() const;
-#endif
 
 #if wxOSX_USE_ATSU_TEXT
     // Returns an ATSUStyle not ATSUStyle*
--- include/wx/osx/iphone/chkconf.h
+++ include/wx/osx/iphone/chkconf.h
@@ -19,7 +19,6 @@
  * under a certain platform
  */
 
-#define wxOSX_USE_CORE_TEXT 1
 #define wxOSX_USE_ATSU_TEXT 0
 #define wxHAS_OPENGL_ES
 
--- include/wx/wxcrtbase.h
+++ include/wx/wxcrtbase.h
@@ -565,24 +565,6 @@ WXDLLIMPEXP_BASE wchar_t * wxCRT_GetenvW(const wchar_t *name);
     /* wcstoi doesn't exist */
 #endif
 
-#ifdef __DARWIN__
-    #if !defined(__WXOSX_IPHONE__) && MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_2
-        #define wxNEED_WX_MBSTOWCS
-    #endif
-#endif
-
-#ifdef wxNEED_WX_MBSTOWCS
-    /* even though they are defined and "implemented", they are bad and just
-       stubs so we need our own - we need these even in ANSI builds!! */
-    WXDLLIMPEXP_BASE size_t wxMbstowcs(wchar_t *, const char *, size_t);
-    WXDLLIMPEXP_BASE size_t wxWcstombs(char *, const wchar_t *, size_t);
-#else
-    #define wxMbstowcs mbstowcs
-    #define wxWcstombs wcstombs
-#endif
-
-
-
 /* -------------------------------------------------------------------------
                                 time.h
    ------------------------------------------------------------------------- */
--- samples/dialogs/dialogs.h
+++ samples/dialogs/dialogs.h
@@ -52,7 +52,7 @@ of MSW, MAC and OS2
     #define USE_WXMAC 0
 #endif
 
-#if defined(__WXMAC_OSX__) && ( MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_2) && USE_NATIVE_FONT_DIALOG_FOR_MACOSX
+#if defined(__WXMAC_OSX__) && && USE_NATIVE_FONT_DIALOG_FOR_MACOSX
     #define USE_WXMACFONTDLG 1
 #else
     #define USE_WXMACFONTDLG 0
--- src/common/wxcrt.cpp
+++ src/common/wxcrt.cpp
@@ -89,7 +89,7 @@ WXDLLIMPEXP_BASE size_t wxMB2WC(wchar_t *buf, const char *psz, size_t n)
 #ifdef HAVE_WCSRTOMBS
     return mbsrtowcs(buf, &psz, n, &mbstate);
 #else
-    return wxMbstowcs(buf, psz, n);
+    return mbstowcs(buf, psz, n);
 #endif
   }
 
@@ -102,7 +102,7 @@ WXDLLIMPEXP_BASE size_t wxMB2WC(wchar_t *buf, const char *psz, size_t n)
 #ifdef HAVE_WCSRTOMBS
   return mbsrtowcs(NULL, &psz, 0, &mbstate);
 #else
-  return wxMbstowcs(NULL, psz, 0);
+  return mbstowcs(NULL, psz, 0);
 #endif
 }
 
@@ -122,14 +122,14 @@ WXDLLIMPEXP_BASE size_t wxWC2MB(char *buf, const wchar_t *pwz, size_t n)
 #ifdef HAVE_WCSRTOMBS
     return wcsrtombs(buf, &pwz, n, &mbstate);
 #else
-    return wxWcstombs(buf, pwz, n);
+    return wcstombs(buf, pwz, n);
 #endif
   }
 
 #ifdef HAVE_WCSRTOMBS
   return wcsrtombs(NULL, &pwz, 0, &mbstate);
 #else
-  return wxWcstombs(NULL, pwz, 0);
+  return wcstombs(NULL, pwz, 0);
 #endif
 }
 
@@ -737,54 +737,6 @@ int wxVsnprintf(wchar_t *str, size_t size, const wxString& format, va_list argpt
 // ctype.h stuff (currently unused)
 // ----------------------------------------------------------------------------
 
-#ifdef wxNEED_WX_MBSTOWCS
-
-WXDLLIMPEXP_BASE size_t wxMbstowcs (wchar_t * out, const char * in, size_t outlen)
-{
-    if (!out)
-    {
-        size_t outsize = 0;
-        while(*in++)
-            outsize++;
-        return outsize;
-    }
-
-    const char* origin = in;
-
-    while (outlen-- && *in)
-    {
-        *out++ = (wchar_t) *in++;
-    }
-
-    *out = '\0';
-
-    return in - origin;
-}
-
-WXDLLIMPEXP_BASE size_t wxWcstombs (char * out, const wchar_t * in, size_t outlen)
-{
-    if (!out)
-    {
-        size_t outsize = 0;
-        while(*in++)
-            outsize++;
-        return outsize;
-    }
-
-    const wchar_t* origin = in;
-
-    while (outlen-- && *in)
-    {
-        *out++ = (char) *in++;
-    }
-
-    *out = '\0';
-
-    return in - origin;
-}
-
-#endif // wxNEED_WX_MBSTOWCS
-
 #ifndef wxCRT_StrdupA
 WXDLLIMPEXP_BASE char *wxCRT_StrdupA(const char *s)
 {
--- src/html/htmlctrl/webkit/webkit.mm
+++ src/html/htmlctrl/webkit/webkit.mm
@@ -458,10 +458,7 @@ bool wxWebKitCtrl::Create(wxWindow *parent,
 
     m_webView = (WebView*) HIWebViewGetWebView( peer->GetControlRef() );
 
-#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_3
-    if ( UMAGetSystemVersion() >= 0x1030 )
-        HIViewChangeFeatures( peer->GetControlRef() , kHIViewIsOpaque , 0 ) ;
-#endif
+    HIViewChangeFeatures( peer->GetControlRef() , kHIViewIsOpaque , 0 ) ;
     InstallControlEventHandler( peer->GetControlRef() , GetwxWebKitCtrlEventHandlerUPP(),
         GetEventTypeCount(eventList), eventList, this,
         (EventHandlerRef *)&m_webKitCtrlEventHandler);
--- src/osx/carbon/dataview.cpp
+++ src/osx/carbon/dataview.cpp
@@ -155,9 +155,7 @@ static bool InitializeColumnDescription(DataBrowserListViewColumnDesc& columnDes
       (columnDescription.propertyDesc.propertyType == kDataBrowserIconAndTextType) ||
       (columnDescription.propertyDesc.propertyType == kDataBrowserTextType))
     columnDescription.propertyDesc.propertyFlags |= kDataBrowserListViewTypeSelectColumn; // enables generally the possibility to have user input for the mentioned types
-#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_4
   columnDescription.propertyDesc.propertyFlags |= kDataBrowserListViewNoGapForIconInHeaderButton;
-#endif
  // set header's properties:
   columnDescription.headerBtnDesc.version            = kDataBrowserListViewLatestHeaderDesc;
   columnDescription.headerBtnDesc.titleOffset        = 0;
--- src/osx/carbon/font.cpp
+++ src/osx/carbon/font.cpp
@@ -50,11 +50,9 @@ public:
 
     wxFontRefData(wxOSXSystemFont font, int size);
 
-#if wxOSX_USE_CORE_TEXT
     wxFontRefData( wxUint32 coreTextFontType );
     wxFontRefData( CTFontRef font );
     wxFontRefData( CTFontDescriptorRef fontdescriptor, int size );
-#endif
 
     virtual ~wxFontRefData();
 
@@ -146,9 +144,6 @@ public:
 protected:
     // common part of all ctors
     void Init();
-#if wxOSX_USE_CORE_TEXT
-    // void Init( CTFontRef font );
-#endif
 public:
     bool            m_fontValid;
 #if wxOSX_USE_CARBON && wxOSX_USE_ATSU_TEXT
@@ -156,9 +151,7 @@ public:
     // information here, as this speeds up and optimizes rendering
     ThemeFontID     m_macThemeFontID ;
 #endif
-#if wxOSX_USE_CORE_TEXT
     wxCFRef<CTFontRef> m_ctFont;
-#endif
 #if wxOSX_USE_ATSU_TEXT
     void CreateATSUFont();
 
@@ -184,9 +177,7 @@ wxFontRefData::wxFontRefData(const wxFontRefData& data) : wxGDIRefData()
 #if wxOSX_USE_CARBON && wxOSX_USE_ATSU_TEXT
     m_macThemeFontID = data.m_macThemeFontID;
 #endif
-#if wxOSX_USE_CORE_TEXT
     m_ctFont = data.m_ctFont;
-#endif
     m_cgFont = data.m_cgFont;
 #if wxOSX_USE_ATSU_TEXT
     if ( data.m_macATSUStyle != NULL )
@@ -236,9 +227,7 @@ wxFontRefData::~wxFontRefData()
 
 void wxFontRefData::Free()
 {
-#if wxOSX_USE_CORE_TEXT
     m_ctFont.reset();
-#endif
     m_cgFont.reset();
 #if wxOSX_USE_ATSU_TEXT
 #if wxOSX_USE_CARBON
@@ -272,7 +261,6 @@ wxFontRefData::wxFontRefData(wxOSXSystemFont font, int size)
     wxASSERT( font != wxOSX_SYSTEM_FONT_NONE );
     Init();
 
-#if wxOSX_USE_CORE_TEXT
     {
         CTFontUIFontType uifont = kCTFontSystemFontType;
         switch( font )
@@ -309,7 +297,6 @@ wxFontRefData::wxFontRefData(wxOSXSystemFont font, int size)
         descr.reset( CTFontCopyFontDescriptor( m_ctFont ) );
         m_info.Init(descr);
     }
-#endif
 #if wxOSX_USE_ATSU_TEXT
     {
 #if !wxOSX_USE_CARBON
@@ -464,7 +451,6 @@ void wxFontRefData::MacFindFont()
 
     m_info.EnsureValid();
 
-#if wxOSX_USE_CORE_TEXT
     {
          CTFontSymbolicTraits traits = 0;
 
@@ -527,8 +513,6 @@ void wxFontRefData::MacFindFont()
 
         m_cgFont.reset(CTFontCopyGraphicsFont(m_ctFont, NULL));
     }
-
-#endif
 #if wxOSX_USE_ATSU_TEXT
     CreateATSUFont();
 #endif
@@ -543,12 +527,8 @@ void wxFontRefData::MacFindFont()
 
 bool wxFontRefData::IsFixedWidth() const
 {
-#if wxOSX_USE_CORE_TEXT
     CTFontSymbolicTraits traits = CTFontGetSymbolicTraits(m_ctFont);
     return (traits & kCTFontMonoSpaceTrait) != 0;
-#else
-    return false;
-#endif
 }
 
 // ----------------------------------------------------------------------------
@@ -852,8 +832,6 @@ wxUint32 wxFont::MacGetATSUAdditionalQDStyles() const
 }
 #endif
 
-#if wxOSX_USE_CORE_TEXT
-
 CTFontRef wxFont::OSXGetCTFont() const
 {
     wxCHECK_MSG( M_FONTDATA != NULL , 0, wxT("invalid font") );
@@ -864,8 +842,6 @@ CTFontRef wxFont::OSXGetCTFont() const
     return (CTFontRef)(M_FONTDATA->m_ctFont);
 }
 
-#endif
-
 #if wxOSX_USE_COCOA_OR_CARBON
 
 CGFontRef wxFont::OSXGetCGFont() const
@@ -1005,7 +981,6 @@ void wxNativeFontInfo::Init()
     m_descriptorValid = false;
 }
 
-#if wxOSX_USE_CORE_TEXT
 void wxNativeFontInfo::Init(CTFontDescriptorRef descr)
 {
     Init();
@@ -1028,7 +1003,6 @@ void wxNativeFontInfo::Init(CTFontDescriptorRef descr)
     wxCFStringRef familyName( (CFStringRef) CTFontDescriptorCopyAttribute(descr, kCTFontFamilyNameAttribute));
     m_faceName = familyName.AsString();
 }
-#endif
 
 void wxNativeFontInfo::EnsureValid()
 {
--- src/osx/carbon/fontdlg.cpp
+++ src/osx/carbon/fontdlg.cpp
@@ -76,7 +76,6 @@ wxMacCarbonFontPanelHandler(EventHandlerCallRef WXUNUSED(nextHandler),
         case kEventFontSelection :
         {
             bool setup = false ;
-#if wxOSX_USE_CORE_TEXT
             if ( !setup )
             {
                 CTFontDescriptorRef descr;
@@ -90,7 +89,6 @@ wxMacCarbonFontPanelHandler(EventHandlerCallRef WXUNUSED(nextHandler),
                     setup = true;
                 }
             }
-#endif
 #if wxOSX_USE_ATSU_TEXT
             ATSUFontID fontId = 0 ;
             if ( !setup && (cEvent.GetParameter<ATSUFontID>(kEventParamATSUFontID, &fontId) == noErr) )
@@ -240,24 +238,10 @@ int wxFontDialog::ShowModal()
         font = m_fontData.m_initialFont ;
     }
 
-    bool setup = false;
-#if wxOSX_USE_CORE_TEXT
-    if ( !setup )
-    {
-        CTFontDescriptorRef descr = (CTFontDescriptorRef) CTFontCopyFontDescriptor( (CTFontRef) font.OSXGetCTFont() );
-        err = SetFontInfoForSelection (kFontSelectionCoreTextType,1, &descr , NULL);
-        CFRelease( descr );
-        setup = true;
-    }
-#endif
-#if wxOSX_USE_ATSU_TEXT
-    if ( !setup )
-    {
-        ATSUStyle style = (ATSUStyle)font.MacGetATSUStyle();
-        err = SetFontInfoForSelection (kFontSelectionATSUIType,1, &style , NULL);
-        setup = true;
-    }
-#endif
+    CTFontDescriptorRef descr = (CTFontDescriptorRef) CTFontCopyFontDescriptor( (CTFontRef) font.OSXGetCTFont() );
+    err = SetFontInfoForSelection (kFontSelectionCoreTextType,1, &descr , NULL);
+    CFRelease( descr );
+
     // just clicking on ENTER will not send us any font setting event, therefore we have to make sure
     // that field is already correct
     m_fontData.m_chosenFont = font ;
--- src/osx/carbon/glcanvas.cpp
+++ src/osx/carbon/glcanvas.cpp
@@ -262,24 +262,7 @@ bool wxGLContext::SetCurrent(const wxGLCanvas& win) const
 
     const_cast<wxGLCanvas&>(win).SetViewport();
 
-    
-#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
-    if ( UMAGetSystemVersion() >= 0x1050 )
-    {
-        aglSetWindowRef(m_glContext, win.MacGetTopLevelWindowRef());
-    }
-    else
-#endif
-    {
-        AGLDrawable drawable = (AGLDrawable)GetWindowPort(
-                                                      MAC_WXHWND(win.MacGetTopLevelWindowRef()));
-    
-        if ( !aglSetDrawable(m_glContext, drawable) )
-        {
-            wxLogAGLError("aglSetDrawable");
-            return false;
-        }
-    }
+    aglSetWindowRef(m_glContext, win.MacGetTopLevelWindowRef());
 
     return WXGLSetCurrentContext(m_glContext);
 }
@@ -354,17 +337,7 @@ bool wxGLCanvas::Create(wxWindow *parent,
     m_bufferName = gCurrentBufferName++;
     aglSetInteger (m_dummyContext, AGL_BUFFER_NAME, &m_bufferName);
 
-#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
-    if ( UMAGetSystemVersion() >= 0x1050 )
-    {
-        aglSetWindowRef(m_dummyContext, MacGetTopLevelWindowRef());
-    }
-    else
-#endif
-    {
-        AGLDrawable drawable = (AGLDrawable)GetWindowPort(MAC_WXHWND(MacGetTopLevelWindowRef()));
-        aglSetDrawable(m_dummyContext, drawable);
-    }
+    aglSetWindowRef(m_dummyContext, MacGetTopLevelWindowRef());
 
     m_macCanvasIsShown = true;
 
--- src/osx/carbon/graphics.cpp
+++ src/osx/carbon/graphics.cpp
@@ -66,8 +66,6 @@ int UMAGetSystemVersion()
 }
 
 
-#define wxOSX_USE_CORE_TEXT 1
-
 #endif
 
 #if wxOSX_USE_COCOA_OR_IPHONE
@@ -78,10 +76,6 @@ extern void wxOSXUnlockFocus( WXWidget view) ;
 #endif
 #endif
 
-#if 1 // MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
-
-// TODO test whether this private API also works under 10.3
-
 // copying values from NSCompositingModes (see also webkit and cairo sources)
 
 typedef enum CGCompositeOperation {
@@ -106,8 +100,6 @@ extern "C"
    CG_EXTERN void CGContextSetCompositeOperation (CGContextRef context, int operation);
 } ;
 
-#endif
-
 //-----------------------------------------------------------------------------
 // constants
 //-----------------------------------------------------------------------------
@@ -152,8 +144,6 @@ CGColorRef wxMacCreateCGColor( const wxColour& col )
     return retval;
 }
 
-#if wxOSX_USE_CORE_TEXT
-
 CTFontRef wxMacCreateCTFont( const wxFont& font )
 {
 #ifdef __WXMAC__
@@ -163,8 +153,6 @@ CTFontRef wxMacCreateCTFont( const wxFont& font )
 #endif
 }
 
-#endif
-
 // CGPattern wrapper class: always allocate on heap, never call destructor
 
 class wxMacCoreGraphicsPattern
@@ -866,9 +854,7 @@ public:
 #if wxOSX_USE_ATSU_TEXT
     virtual ATSUStyle GetATSUStyle() { return m_macATSUIStyle; }
 #endif
-#if wxOSX_USE_CORE_TEXT
     CTFontRef OSXGetCTFont() const { return m_ctFont ; }
-#endif
     wxColour GetColour() const { return m_colour ; }
 
     bool GetUnderlined() const { return m_underlined ; }
@@ -881,9 +867,7 @@ private :
 #if wxOSX_USE_ATSU_TEXT
     ATSUStyle m_macATSUIStyle;
 #endif
-#if wxOSX_USE_CORE_TEXT
     wxCFRef< CTFontRef > m_ctFont;
-#endif
 #if wxOSX_USE_IPHONE
     UIFont*  m_uiFont;
 #endif
@@ -894,9 +878,7 @@ wxMacCoreGraphicsFontData::wxMacCoreGraphicsFontData(wxGraphicsRenderer* rendere
     m_colour = col;
     m_underlined = font.GetUnderlined();
 
-#if wxOSX_USE_CORE_TEXT
     m_ctFont.reset( wxMacCreateCTFont( font ) );
-#endif
 #if wxOSX_USE_IPHONE
     m_uiFont = CreateUIFont(font);
     wxMacCocoaRetain( m_uiFont );
@@ -940,8 +922,6 @@ wxMacCoreGraphicsFontData::wxMacCoreGraphicsFontData(wxGraphicsRenderer* rendere
 
 wxMacCoreGraphicsFontData::~wxMacCoreGraphicsFontData()
 {
-#if wxOSX_USE_CORE_TEXT
-#endif
 #if wxOSX_USE_ATSU_TEXT
     if ( m_macATSUIStyle )
     {
@@ -2309,79 +2289,51 @@ void wxMacCoreGraphicsContext::DoDrawText( const wxString &str, wxDouble x, wxDo
     if (m_composition == wxCOMPOSITION_DEST)
         return;
 
-#if wxOSX_USE_CORE_TEXT
-    {
-        wxMacCoreGraphicsFontData* fref = (wxMacCoreGraphicsFontData*)m_font.GetRefData();
-        wxCFStringRef text(str, wxLocale::GetSystemEncoding() );
-        CTFontRef font = fref->OSXGetCTFont();
-        CGColorRef col = wxMacCreateCGColor( fref->GetColour() );
+    wxMacCoreGraphicsFontData* fref = (wxMacCoreGraphicsFontData*)m_font.GetRefData();
+    wxCFStringRef text(str, wxLocale::GetSystemEncoding() );
+    CTFontRef font = fref->OSXGetCTFont();
+    CGColorRef col = wxMacCreateCGColor( fref->GetColour() );
 #if 0
-        // right now there's no way to get continuous underlines, only words, so we emulate it
-        CTUnderlineStyle ustyle = fref->GetUnderlined() ? kCTUnderlineStyleSingle : kCTUnderlineStyleNone ;
-        wxCFRef<CFNumberRef> underlined( CFNumberCreate(NULL, kCFNumberSInt32Type, &ustyle) );
-         CFStringRef keys[] = { kCTFontAttributeName , kCTForegroundColorAttributeName, kCTUnderlineStyleAttributeName };
-        CFTypeRef values[] = { font, col, underlined };
+    // right now there's no way to get continuous underlines, only words, so we emulate it
+    CTUnderlineStyle ustyle = fref->GetUnderlined() ? kCTUnderlineStyleSingle : kCTUnderlineStyleNone ;
+    wxCFRef<CFNumberRef> underlined( CFNumberCreate(NULL, kCFNumberSInt32Type, &ustyle) );
+     CFStringRef keys[] = { kCTFontAttributeName , kCTForegroundColorAttributeName, kCTUnderlineStyleAttributeName };
+    CFTypeRef values[] = { font, col, underlined };
 #else
-        CFStringRef keys[] = { kCTFontAttributeName , kCTForegroundColorAttributeName };
-        CFTypeRef values[] = { font, col };
+    CFStringRef keys[] = { kCTFontAttributeName , kCTForegroundColorAttributeName };
+    CFTypeRef values[] = { font, col };
 #endif
-        wxCFRef<CFDictionaryRef> attributes( CFDictionaryCreate(kCFAllocatorDefault, (const void**) &keys, (const void**) &values,
-                                                        WXSIZEOF( keys ), &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks) );
-        wxCFRef<CFAttributedStringRef> attrtext( CFAttributedStringCreate(kCFAllocatorDefault, text, attributes) );
-        wxCFRef<CTLineRef> line( CTLineCreateWithAttributedString(attrtext) );
+    wxCFRef<CFDictionaryRef> attributes( CFDictionaryCreate(kCFAllocatorDefault, (const void**) &keys, (const void**) &values,
+                                                    WXSIZEOF( keys ), &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks) );
+    wxCFRef<CFAttributedStringRef> attrtext( CFAttributedStringCreate(kCFAllocatorDefault, text, attributes) );
+    wxCFRef<CTLineRef> line( CTLineCreateWithAttributedString(attrtext) );
 
-        y += CTFontGetAscent(font);
-
-        CGContextSaveGState(m_cgContext);
-        CGAffineTransform textMatrix = CGContextGetTextMatrix(m_cgContext);
-        
-        CGContextTranslateCTM(m_cgContext, (CGFloat) x, (CGFloat) y);
-        CGContextScaleCTM(m_cgContext, 1, -1);
-        CGContextSetTextMatrix(m_cgContext, CGAffineTransformIdentity);
-        
-        CTLineDraw( line, m_cgContext );
-        
-        if ( fref->GetUnderlined() ) {
-            //AKT: draw horizontal line 1 pixel thick and with 1 pixel gap under baseline
-            CGFloat width = CTLineGetTypographicBounds(line, NULL, NULL, NULL);
-
-            CGPoint points[] = { {0.0, -2.0},  {width, -2.0} };
-            
-            CGContextSetStrokeColorWithColor(m_cgContext, col);
-            CGContextSetShouldAntialias(m_cgContext, false);
-            CGContextSetLineWidth(m_cgContext, 1.0);
-            CGContextStrokeLineSegments(m_cgContext, points, 2);
-        }
-        
-        CGContextRestoreGState(m_cgContext);
-        CGContextSetTextMatrix(m_cgContext, textMatrix);
-        CGColorRelease( col );
-        CheckInvariants();
-        return;
-    }
-#endif
-#if wxOSX_USE_ATSU_TEXT
-    {
-        DrawText(str, x, y, 0.0);
-        return;
-    }
-#endif
-#if wxOSX_USE_IPHONE
-    wxMacCoreGraphicsFontData* fref = (wxMacCoreGraphicsFontData*)m_font.GetRefData();
+    y += CTFontGetAscent(font);
 
     CGContextSaveGState(m_cgContext);
+    CGAffineTransform textMatrix = CGContextGetTextMatrix(m_cgContext);
 
-    CGColorRef col = wxMacCreateCGColor( fref->GetColour() );
-    CGContextSetTextDrawingMode (m_cgContext, kCGTextFill);
-    CGContextSetFillColorWithColor( m_cgContext, col );
+    CGContextTranslateCTM(m_cgContext, (CGFloat) x, (CGFloat) y);
+    CGContextScaleCTM(m_cgContext, 1, -1);
+    CGContextSetTextMatrix(m_cgContext, CGAffineTransformIdentity);
 
-    wxCFStringRef text(str, wxLocale::GetSystemEncoding() );
-    DrawTextInContext( m_cgContext, CGPointMake( x, y ), fref->GetUIFont() , text.AsNSString() );
+    CTLineDraw( line, m_cgContext );
+
+    if ( fref->GetUnderlined() ) {
+        //AKT: draw horizontal line 1 pixel thick and with 1 pixel gap under baseline
+        CGFloat width = CTLineGetTypographicBounds(line, NULL, NULL, NULL);
+
+        CGPoint points[] = { {0.0, -2.0},  {width, -2.0} };
+        
+        CGContextSetStrokeColorWithColor(m_cgContext, col);
+        CGContextSetShouldAntialias(m_cgContext, false);
+        CGContextSetLineWidth(m_cgContext, 1.0);
+        CGContextStrokeLineSegments(m_cgContext, points, 2);
+    }
 
     CGContextRestoreGState(m_cgContext);
-    CFRelease( col );
-#endif
-    
+    CGContextSetTextMatrix(m_cgContext, textMatrix);
+    CGColorRelease( col );
     CheckInvariants();
 }
 
@@ -2397,103 +2349,9 @@ void wxMacCoreGraphicsContext::DoDrawRotatedText(const wxString &str,
     if (m_composition == wxCOMPOSITION_DEST)
         return;
 
-#if wxOSX_USE_CORE_TEXT
-    {
-        // default implementation takes care of rotation and calls non rotated DrawText afterwards
-        wxGraphicsContext::DoDrawRotatedText( str, x, y, angle );
-        return;
-    }
-#endif
-#if wxOSX_USE_ATSU_TEXT
-    {
-        OSStatus status = noErr;
-        ATSUTextLayout atsuLayout;
-        wxMacUniCharBuffer unibuf( str );
-        UniCharCount chars = unibuf.GetChars();
-
-        ATSUStyle style = (((wxMacCoreGraphicsFontData*)m_font.GetRefData())->GetATSUStyle());
-        status = ::ATSUCreateTextLayoutWithTextPtr( unibuf.GetBuffer() , 0 , chars , chars , 1 ,
-                                                   &chars , &style , &atsuLayout );
-
-        wxASSERT_MSG( status == noErr , wxT("couldn't create the layout of the rotated text") );
-
-        status = ::ATSUSetTransientFontMatching( atsuLayout , true );
-        wxASSERT_MSG( status == noErr , wxT("couldn't setup transient font matching") );
-
-        int iAngle = int( angle * RAD2DEG );
-        if ( abs(iAngle) > 0 )
-        {
-            Fixed atsuAngle = IntToFixed( iAngle );
-            ATSUAttributeTag atsuTags[] =
-            {
-                kATSULineRotationTag ,
-            };
-            ByteCount atsuSizes[WXSIZEOF(atsuTags)] =
-            {
-                sizeof( Fixed ) ,
-            };
-            ATSUAttributeValuePtr    atsuValues[WXSIZEOF(atsuTags)] =
-            {
-                &atsuAngle ,
-            };
-            status = ::ATSUSetLayoutControls(atsuLayout , WXSIZEOF(atsuTags),
-                                             atsuTags, atsuSizes, atsuValues );
-        }
-
-        {
-            ATSUAttributeTag atsuTags[] =
-            {
-                kATSUCGContextTag ,
-            };
-            ByteCount atsuSizes[WXSIZEOF(atsuTags)] =
-            {
-                sizeof( CGContextRef ) ,
-            };
-            ATSUAttributeValuePtr    atsuValues[WXSIZEOF(atsuTags)] =
-            {
-                &m_cgContext ,
-            };
-            status = ::ATSUSetLayoutControls(atsuLayout , WXSIZEOF(atsuTags),
-                                             atsuTags, atsuSizes, atsuValues );
-        }
-
-        ATSUTextMeasurement textBefore, textAfter;
-        ATSUTextMeasurement ascent, descent;
-
-        status = ::ATSUGetUnjustifiedBounds( atsuLayout, kATSUFromTextBeginning, kATSUToTextEnd,
-                                            &textBefore , &textAfter, &ascent , &descent );
-
-        wxASSERT_MSG( status == noErr , wxT("couldn't measure the rotated text") );
-
-        Rect rect;
-        x += (int)(sin(angle) * FixedToFloat(ascent));
-        y += (int)(cos(angle) * FixedToFloat(ascent));
-
-        status = ::ATSUMeasureTextImage( atsuLayout, kATSUFromTextBeginning, kATSUToTextEnd,
-                                        IntToFixed(x) , IntToFixed(y) , &rect );
-        wxASSERT_MSG( status == noErr , wxT("couldn't measure the rotated text") );
-
-        CGContextSaveGState(m_cgContext);
-        CGContextTranslateCTM(m_cgContext, (CGFloat) x, (CGFloat) y);
-        CGContextScaleCTM(m_cgContext, 1, -1);
-        status = ::ATSUDrawText( atsuLayout, kATSUFromTextBeginning, kATSUToTextEnd,
-                                IntToFixed(0) , IntToFixed(0) );
-
-        wxASSERT_MSG( status == noErr , wxT("couldn't draw the rotated text") );
-
-        CGContextRestoreGState(m_cgContext);
-
-        ::ATSUDisposeTextLayout(atsuLayout);
-        CheckInvariants();
-
-        return;
-    }
-#endif
-#if wxOSX_USE_IPHONE
     // default implementation takes care of rotation and calls non rotated DrawText afterwards
     wxGraphicsContext::DoDrawRotatedText( str, x, y, angle );
-#endif
-    
+
     CheckInvariants();
 }
 
@@ -2518,100 +2376,33 @@ void wxMacCoreGraphicsContext::GetTextExtent( const wxString &str, wxDouble *wid
     if (str.empty())
         strToMeasure = wxS(" ");
 
-#if wxOSX_USE_CORE_TEXT
-    {
-        wxMacCoreGraphicsFontData* fref = (wxMacCoreGraphicsFontData*)m_font.GetRefData();
-        CTFontRef font = fref->OSXGetCTFont();
-
-        wxCFStringRef text(strToMeasure, wxLocale::GetSystemEncoding() );
-        CFStringRef keys[] = { kCTFontAttributeName  };
-        CFTypeRef values[] = { font };
-        wxCFRef<CFDictionaryRef> attributes( CFDictionaryCreate(kCFAllocatorDefault, (const void**) &keys, (const void**) &values,
-                                                                WXSIZEOF( keys ), &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks) );
-        wxCFRef<CFAttributedStringRef> attrtext( CFAttributedStringCreate(kCFAllocatorDefault, text, attributes) );
-        wxCFRef<CTLineRef> line( CTLineCreateWithAttributedString(attrtext) );
-
-        CGFloat a, d, l, w;
-        w = CTLineGetTypographicBounds(line, &a, &d, &l);
-
-        if ( !str.empty() )
-        {
-            if ( width )
-                *width = w;
-            if ( height )
-                *height = a+d+l;
-        }
-
-        if ( descent )
-            *descent = d;
-        if ( externalLeading )
-            *externalLeading = l;
-        return;
-    }
-#endif
-#if wxOSX_USE_ATSU_TEXT
-    {
-        OSStatus status = noErr;
-
-        ATSUTextLayout atsuLayout;
-        wxMacUniCharBuffer unibuf( strToMeasure );
-        UniCharCount chars = unibuf.GetChars();
-
-        ATSUStyle style = (((wxMacCoreGraphicsFontData*)m_font.GetRefData())->GetATSUStyle());
-        status = ::ATSUCreateTextLayoutWithTextPtr( unibuf.GetBuffer() , 0 , chars , chars , 1 ,
-                                                   &chars , &style , &atsuLayout );
-
-        wxASSERT_MSG( status == noErr , wxT("couldn't create the layout of the text") );
-
-        status = ::ATSUSetTransientFontMatching( atsuLayout , true );
-        wxASSERT_MSG( status == noErr , wxT("couldn't setup transient font matching") );
-
-        ATSUTextMeasurement textBefore, textAfter;
-        ATSUTextMeasurement textAscent, textDescent;
-
-        status = ::ATSUGetUnjustifiedBounds( atsuLayout, kATSUFromTextBeginning, kATSUToTextEnd,
-                                            &textBefore , &textAfter, &textAscent , &textDescent );
-
-        if ( !str.empty() )
-        {
-            if ( width )
-                *width = FixedToFloat(textAfter - textBefore);
-            if ( height )
-                *height = FixedToFloat(textAscent + textDescent);
-        }
-
-        if ( descent )
-            *descent = FixedToFloat(textDescent);
-        if ( externalLeading )
-            *externalLeading = 0;
-
-        ::ATSUDisposeTextLayout(atsuLayout);
-
-        return;
-    }
-#endif
-#if wxOSX_USE_IPHONE
     wxMacCoreGraphicsFontData* fref = (wxMacCoreGraphicsFontData*)m_font.GetRefData();
+    CTFontRef font = fref->OSXGetCTFont();
 
     wxCFStringRef text(strToMeasure, wxLocale::GetSystemEncoding() );
-    CGSize sz = MeasureTextInContext( fref->GetUIFont() , text.AsNSString() );
+    CFStringRef keys[] = { kCTFontAttributeName  };
+    CFTypeRef values[] = { font };
+    wxCFRef<CFDictionaryRef> attributes( CFDictionaryCreate(kCFAllocatorDefault, (const void**) &keys, (const void**) &values,
+                                                            WXSIZEOF( keys ), &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks) );
+    wxCFRef<CFAttributedStringRef> attrtext( CFAttributedStringCreate(kCFAllocatorDefault, text, attributes) );
+    wxCFRef<CTLineRef> line( CTLineCreateWithAttributedString(attrtext) );
+
+    CGFloat a, d, l, w;
+    w = CTLineGetTypographicBounds(line, &a, &d, &l);
 
     if ( !str.empty() )
     {
         if ( width )
-            *width = sz.width;
+            *width = w;
         if ( height )
-            *height = sz.height;
+            *height = a+d+l;
     }
 
-        /*
     if ( descent )
-        *descent = FixedToFloat(textDescent);
+        *descent = d;
     if ( externalLeading )
-        *externalLeading = 0;
-        */
-#endif
-    
+        *externalLeading = l;
+
     CheckInvariants();    
 }
 
@@ -2625,93 +2416,23 @@ void wxMacCoreGraphicsContext::GetPartialTextExtents(const wxString& text, wxArr
     if (text.empty())
         return;
 
-#if wxOSX_USE_CORE_TEXT
-    {
-        wxMacCoreGraphicsFontData* fref = (wxMacCoreGraphicsFontData*)m_font.GetRefData();
-        CTFontRef font = fref->OSXGetCTFont();
-
-        wxCFStringRef t(text, wxLocale::GetSystemEncoding() );
-        CFStringRef keys[] = { kCTFontAttributeName  };
-        CFTypeRef values[] = { font };
-        wxCFRef<CFDictionaryRef> attributes( CFDictionaryCreate(kCFAllocatorDefault, (const void**) &keys, (const void**) &values,
-                                                                WXSIZEOF( keys ), &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks) );
-        wxCFRef<CFAttributedStringRef> attrtext( CFAttributedStringCreate(kCFAllocatorDefault, t, attributes) );
-        wxCFRef<CTLineRef> line( CTLineCreateWithAttributedString(attrtext) );
+    wxMacCoreGraphicsFontData* fref = (wxMacCoreGraphicsFontData*)m_font.GetRefData();
+    CTFontRef font = fref->OSXGetCTFont();
 
-        int chars = text.length();
-        for ( int pos = 0; pos < (int)chars; pos ++ )
-        {
-            widths[pos] = CTLineGetOffsetForStringIndex( line, pos+1 , NULL );
-        }
+    wxCFStringRef t(text, wxLocale::GetSystemEncoding() );
+    CFStringRef keys[] = { kCTFontAttributeName  };
+    CFTypeRef values[] = { font };
+    wxCFRef<CFDictionaryRef> attributes( CFDictionaryCreate(kCFAllocatorDefault, (const void**) &keys, (const void**) &values,
+                                                            WXSIZEOF( keys ), &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks) );
+    wxCFRef<CFAttributedStringRef> attrtext( CFAttributedStringCreate(kCFAllocatorDefault, t, attributes) );
+    wxCFRef<CTLineRef> line( CTLineCreateWithAttributedString(attrtext) );
 
-        return;
-    }
-#endif
-#if wxOSX_USE_ATSU_TEXT
+    int chars = text.length();
+    for ( int pos = 0; pos < (int)chars; pos ++ )
     {
-        OSStatus status = noErr;
-        ATSUTextLayout atsuLayout;
-        wxMacUniCharBuffer unibuf( text );
-        UniCharCount chars = unibuf.GetChars();
-
-        ATSUStyle style = (((wxMacCoreGraphicsFontData*)m_font.GetRefData())->GetATSUStyle());
-        status = ::ATSUCreateTextLayoutWithTextPtr( unibuf.GetBuffer() , 0 , chars , chars , 1 ,
-                                          &chars , &style , &atsuLayout );
-
-        wxASSERT_MSG( status == noErr , wxT("couldn't create the layout of the text") );
-
-        status = ::ATSUSetTransientFontMatching( atsuLayout , true );
-        wxASSERT_MSG( status == noErr , wxT("couldn't setup transient font matching") );
-
-// new implementation from JS, keep old one just in case
-#if 0
-        for ( int pos = 0; pos < (int)chars; pos ++ )
-        {
-            unsigned long actualNumberOfBounds = 0;
-            ATSTrapezoid glyphBounds;
-
-            // We get a single bound, since the text should only require one. If it requires more, there is an issue
-            OSStatus result;
-            result = ATSUGetGlyphBounds( atsuLayout, 0, 0, kATSUFromTextBeginning, pos + 1,
-                                        kATSUseDeviceOrigins, 1, &glyphBounds, &actualNumberOfBounds );
-            if (result != noErr || actualNumberOfBounds != 1 )
-                return;
-
-            widths[pos] = FixedToFloat( glyphBounds.upperRight.x - glyphBounds.upperLeft.x );
-            //unsigned char uch = s[i];
-        }
-#else
-        ATSLayoutRecord *layoutRecords = NULL;
-        ItemCount glyphCount = 0;
-
-        // Get the glyph extents
-        OSStatus err = ::ATSUDirectGetLayoutDataArrayPtrFromTextLayout(atsuLayout,
-                                                                       0,
-                                                                       kATSUDirectDataLayoutRecordATSLayoutRecordCurrent,
-                                                                       (void **)
-                                                                       &layoutRecords,
-                                                                       &glyphCount);
-        wxASSERT(glyphCount == (text.length()+1));
-
-        if ( err == noErr && glyphCount == (text.length()+1))
-        {
-            for ( int pos = 1; pos < (int)glyphCount ; pos ++ )
-            {
-                widths[pos-1] = FixedToFloat( layoutRecords[pos].realPos );
-            }
-        }
-
-        ::ATSUDirectReleaseLayoutDataArrayPtr(NULL,
-                                              kATSUDirectDataLayoutRecordATSLayoutRecordCurrent,
-                                              (void **) &layoutRecords);
-#endif
-        ::ATSUDisposeTextLayout(atsuLayout);
+        widths[pos] = CTLineGetOffsetForStringIndex( line, pos+1 , NULL );
     }
-#endif
-#if wxOSX_USE_IPHONE
-    // TODO core graphics text implementation here
-#endif
-    
+
     CheckInvariants();
 }
 
--- src/osx/carbon/listctrl_mac.cpp
+++ src/osx/carbon/listctrl_mac.cpp
@@ -2853,35 +2853,14 @@ void wxMacDataBrowserListCtrlControl::DrawItem(
 
     HIThemeTextHorizontalFlush hFlush = kHIThemeTextHorizontalFlushLeft;
     HIThemeTextInfo info;
-    bool setup = false;
-#if wxOSX_USE_CORE_TEXT
-    if ( UMAGetSystemVersion() >= 0x1050 )
-    {
-        info.version = kHIThemeTextInfoVersionOne;
-        info.fontID = kThemeViewsFont;
-        if (font.IsOk())
-        {
-            info.fontID = kThemeSpecifiedFont;
-            info.font = (CTFontRef) font.OSXGetCTFont();
-            setup = true;
-        }
-    }
-#endif
-#if wxOSX_USE_ATSU_TEXT
-    if ( !setup )
-    {
-        info.version = kHIThemeTextInfoVersionZero;
-        info.fontID = kThemeViewsFont;
 
-        if (font.IsOk())
-        {
-            info.fontID = font.MacGetThemeFontID();
-
-            ::TextSize( (short)(font.GetPointSize()) ) ;
-            ::TextFace( font.MacGetFontStyle() ) ;
-        }
+    info.version = kHIThemeTextInfoVersionOne;
+    info.fontID = kThemeViewsFont;
+    if (font.IsOk())
+    {
+        info.fontID = kThemeSpecifiedFont;
+        info.font = (CTFontRef) font.OSXGetCTFont();
     }
-#endif
 
     wxListItem item;
     list->GetColumn(listColumn, item);
--- src/osx/carbon/nonownedwnd.cpp
+++ src/osx/carbon/nonownedwnd.cpp
@@ -1522,18 +1522,11 @@ void wxNonOwnedWindowCarbonImpl::Maximize(bool maximize)
     Point idealSize = { 0 , 0 } ;
     if ( maximize )
     {
-#if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5
         HIRect bounds ;
         HIWindowGetAvailablePositioningBounds(kCGNullDirectDisplay,kHICoordSpace72DPIGlobal,
             &bounds);
         idealSize.h = bounds.size.width;
         idealSize.v = bounds.size.height;
-#else
-        Rect rect ;
-        GetAvailableWindowPositioningBounds(GetMainDevice(),&rect) ;
-        idealSize.h = rect.right - rect.left ;
-        idealSize.v = rect.bottom - rect.top ;
-#endif
     }
     ZoomWindowIdeal( (WindowRef)GetWXWindow() , maximize ? inZoomOut : inZoomIn , &idealSize ) ;
 }
--- src/osx/carbon/textctrl.cpp
+++ src/osx/carbon/textctrl.cpp
@@ -369,41 +369,7 @@ wxWidgetImplType* wxWidgetImpl::CreateTextControl( wxTextCtrl* wxpeer,
                                     long style,
                                     long WXUNUSED(extraStyle))
 {
-    bool forceMLTE = false ;
-
-#if wxUSE_SYSTEM_OPTIONS
-    if (wxSystemOptions::HasOption( wxMAC_TEXTCONTROL_USE_MLTE ) && (wxSystemOptions::GetOptionInt( wxMAC_TEXTCONTROL_USE_MLTE ) == 1))
-    {
-        forceMLTE = true ;
-    }
-#endif
-
-    if ( UMAGetSystemVersion() >= 0x1050 )
-        forceMLTE = false;
-
-    wxMacControl*  peer = NULL;
-
-    if ( !forceMLTE )
-    {
-        if ( style & wxTE_MULTILINE || ( UMAGetSystemVersion() >= 0x1050 ) )
-            peer = new wxMacMLTEHIViewControl( wxpeer , str , pos , size , style ) ;
-    }
-
-    if ( !peer )
-    {
-        if ( !(style & wxTE_MULTILINE) && !forceMLTE )
-        {
-            peer = new wxMacUnicodeTextControl( wxpeer , str , pos , size , style ) ;
-        }
-    }
-
-    // the horizontal single line scrolling bug that made us keep the classic implementation
-    // is fixed in 10.5
-#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
-    if ( !peer )
-        peer = new wxMacMLTEClassicControl( wxpeer , str , pos , size , style ) ;
-#endif
-    return peer;
+    return new wxMacMLTEHIViewControl( wxpeer , str , pos , size , style ) ;
 }
 
 // ----------------------------------------------------------------------------
@@ -1467,674 +1433,6 @@ int wxMacMLTEControl::GetLineLength(long lineNo) const
     return theLength ;
 }
 
-#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
-
-// ----------------------------------------------------------------------------
-// MLTE control implementation (classic part)
-// ----------------------------------------------------------------------------
-
-// OS X Notes : We still don't have a full replacement for MLTE, so this implementation
-// has to live on. We have different problems coming from outdated implementations on the
-// various OS X versions. Most deal with the scrollbars: they are not correctly embedded
-// while this can be solved on 10.3 by reassigning them the correct place, on 10.2 there is
-// no way out, therefore we are using our own implementation and our own scrollbars ....
-
-TXNScrollInfoUPP gTXNScrollInfoProc = NULL ;
-ControlActionUPP gTXNScrollActionProc = NULL ;
-
-pascal void wxMacMLTEClassicControl::TXNScrollInfoProc(
-    SInt32 iValue, SInt32 iMaximumValue,
-    TXNScrollBarOrientation iScrollBarOrientation, SInt32 iRefCon )
-{
-    wxMacMLTEClassicControl* mlte = (wxMacMLTEClassicControl*) iRefCon ;
-    SInt32 value =  wxMax( iValue , 0 ) ;
-    SInt32 maximum = wxMax( iMaximumValue , 0 ) ;
-
-    if ( iScrollBarOrientation == kTXNHorizontal )
-    {
-        if ( mlte->m_sbHorizontal )
-        {
-            SetControl32BitValue( mlte->m_sbHorizontal , value ) ;
-            SetControl32BitMaximum( mlte->m_sbHorizontal , maximum ) ;
-            mlte->m_lastHorizontalValue = value ;
-        }
-    }
-    else if ( iScrollBarOrientation == kTXNVertical )
-    {
-        if ( mlte->m_sbVertical )
-        {
-            SetControl32BitValue( mlte->m_sbVertical , value ) ;
-            SetControl32BitMaximum( mlte->m_sbVertical , maximum ) ;
-            mlte->m_lastVerticalValue = value ;
-        }
-    }
-}
-
-pascal void wxMacMLTEClassicControl::TXNScrollActionProc( ControlRef controlRef , ControlPartCode partCode )
-{
-    wxMacMLTEClassicControl* mlte = (wxMacMLTEClassicControl*) GetControlReference( controlRef ) ;
-    if ( mlte == NULL )
-        return ;
-
-    if ( controlRef != mlte->m_sbVertical && controlRef != mlte->m_sbHorizontal )
-        return ;
-
-    OSStatus err ;
-    bool isHorizontal = ( controlRef == mlte->m_sbHorizontal ) ;
-
-    SInt32 minimum = 0 ;
-    SInt32 maximum = GetControl32BitMaximum( controlRef ) ;
-    SInt32 value = GetControl32BitValue( controlRef ) ;
-    SInt32 delta = 0;
-
-    switch ( partCode )
-    {
-        case kControlDownButtonPart :
-            delta = 10 ;
-            break ;
-
-        case kControlUpButtonPart :
-            delta = -10 ;
-            break ;
-
-        case kControlPageDownPart :
-            delta = GetControlViewSize( controlRef ) ;
-            break ;
-
-        case kControlPageUpPart :
-            delta = -GetControlViewSize( controlRef ) ;
-            break ;
-
-        case kControlIndicatorPart :
-            delta = value - (isHorizontal ? mlte->m_lastHorizontalValue : mlte->m_lastVerticalValue) ;
-            break ;
-
-        default :
-            break ;
-    }
-
-    if ( delta != 0 )
-    {
-        SInt32 newValue = value ;
-
-        if ( partCode != kControlIndicatorPart )
-        {
-            if ( value + delta < minimum )
-                delta = minimum - value ;
-            if ( value + delta > maximum )
-                delta = maximum - value ;
-
-            SetControl32BitValue( controlRef , value + delta ) ;
-            newValue = value + delta ;
-        }
-
-        SInt32 verticalDelta = isHorizontal ? 0 : delta ;
-        SInt32 horizontalDelta = isHorizontal ? delta : 0 ;
-
-        err = TXNScroll(
-            mlte->m_txn, kTXNScrollUnitsInPixels, kTXNScrollUnitsInPixels,
-            &verticalDelta, &horizontalDelta );
-        verify_noerr( err );
-
-        if ( isHorizontal )
-            mlte->m_lastHorizontalValue = newValue ;
-        else
-            mlte->m_lastVerticalValue = newValue ;
-    }
-}
-
-// make correct activations
-void wxMacMLTEClassicControl::MacActivatePaneText(bool setActive)
-{
-    wxTextCtrl* textctrl = (wxTextCtrl*) GetControlReference(m_controlRef);
-
-    wxMacWindowClipper clipper( textctrl ) ;
-    TXNActivate( m_txn, m_txnFrameID, setActive );
-
-    ControlRef controlFocus = 0 ;
-    GetKeyboardFocus( m_txnWindow , &controlFocus ) ;
-    if ( controlFocus == m_controlRef )
-        TXNFocus( m_txn, setActive );
-}
-
-void wxMacMLTEClassicControl::MacFocusPaneText(bool setFocus)
-{
-    TXNFocus( m_txn, setFocus );
-}
-
-// guards against inappropriate redraw (hidden objects drawing onto window)
-
-void wxMacMLTEClassicControl::MacSetObjectVisibility(bool vis)
-{
-    ControlRef controlFocus = 0 ;
-    GetKeyboardFocus( m_txnWindow , &controlFocus ) ;
-
-    if ( !vis && (controlFocus == m_controlRef ) )
-        SetKeyboardFocus( m_txnWindow , m_controlRef , kControlFocusNoPart ) ;
-
-    TXNControlTag iControlTags[1] = { kTXNVisibilityTag };
-    TXNControlData iControlData[1] = { { (UInt32)false } };
-
-    verify_noerr( TXNGetTXNObjectControls( m_txn , 1, iControlTags, iControlData ) ) ;
-
-    if ( iControlData[0].uValue != vis )
-    {
-        iControlData[0].uValue = vis ;
-        verify_noerr( TXNSetTXNObjectControls( m_txn, false , 1, iControlTags, iControlData ) ) ;
-    }
-
-    // currently, we always clip as partial visibility (overlapped) visibility is also a problem,
-    // if we run into further problems we might set the FrameBounds to an empty rect here
-}
-
-// make sure that the TXNObject is at the right position
-
-void wxMacMLTEClassicControl::MacUpdatePosition()
-{
-    wxTextCtrl* textctrl = (wxTextCtrl*)GetControlReference( m_controlRef );
-    if ( textctrl == NULL )
-        return ;
-
-    Rect bounds ;
-    GetRectInWindowCoords( &bounds );
-
-    wxRect visRect = textctrl->MacGetClippedClientRect() ;
-    Rect visBounds = { visRect.y , visRect.x , visRect.y + visRect.height , visRect.x + visRect.width } ;
-    int x , y ;
-    x = y = 0 ;
-    textctrl->MacWindowToRootWindow( &x , &y ) ;
-    OffsetRect( &visBounds , x , y ) ;
-
-    if ( !EqualRect( &bounds, &m_txnControlBounds ) || !EqualRect( &visBounds, &m_txnVisBounds ) )
-    {
-        m_txnControlBounds = bounds ;
-        m_txnVisBounds = visBounds ;
-        wxMacWindowClipper cl( textctrl ) ;
-
-        if ( m_sbHorizontal || m_sbVertical )
-        {
-            int w = bounds.right - bounds.left ;
-            int h = bounds.bottom - bounds.top ;
-
-            if ( m_sbHorizontal )
-            {
-                Rect sbBounds ;
-
-                sbBounds.left = -1 ;
-                sbBounds.top = h - 14 ;
-                sbBounds.right = w + 1 ;
-                sbBounds.bottom = h + 1 ;
-
-                SetControlBounds( m_sbHorizontal , &sbBounds ) ;
-                SetControlViewSize( m_sbHorizontal , w ) ;
-            }
-
-            if ( m_sbVertical )
-            {
-                Rect sbBounds ;
-
-                sbBounds.left = w - 14 ;
-                sbBounds.top = -1 ;
-                sbBounds.right = w + 1 ;
-                sbBounds.bottom = m_sbHorizontal ? h - 14 : h + 1 ;
-
-                SetControlBounds( m_sbVertical , &sbBounds ) ;
-                SetControlViewSize( m_sbVertical , h ) ;
-            }
-        }
-
-        Rect oldviewRect ;
-        TXNLongRect olddestRect ;
-        TXNGetRectBounds( m_txn , &oldviewRect , &olddestRect , NULL ) ;
-
-        Rect viewRect = { m_txnControlBounds.top, m_txnControlBounds.left,
-            m_txnControlBounds.bottom - ( m_sbHorizontal ? 14 : 0 ) ,
-            m_txnControlBounds.right - ( m_sbVertical ? 14 : 0 ) } ;
-        TXNLongRect destRect = { m_txnControlBounds.top, m_txnControlBounds.left,
-            m_txnControlBounds.bottom - ( m_sbHorizontal ? 14 : 0 ) ,
-            m_txnControlBounds.right - ( m_sbVertical ? 14 : 0 ) } ;
-
-        if ( olddestRect.right >= 10000 )
-            destRect.right = destRect.left + 32000 ;
-
-        if ( olddestRect.bottom >= 0x20000000 )
-            destRect.bottom = destRect.top + 0x40000000 ;
-
-        SectRect( &viewRect , &visBounds , &viewRect ) ;
-        TXNSetRectBounds( m_txn , &viewRect , &destRect , true ) ;
-
-#if 0
-        TXNSetFrameBounds(
-            m_txn,
-            m_txnControlBounds.top,
-            m_txnControlBounds.left,
-            m_txnControlBounds.bottom - (m_sbHorizontal ? 14 : 0),
-            m_txnControlBounds.right - (m_sbVertical ? 14 : 0),
-            m_txnFrameID );
-#endif
-
-        // the SetFrameBounds method under Classic sometimes does not correctly scroll a selection into sight after a
-        // movement, therefore we have to force it
-
-        // this problem has been reported in OSX as well, so we use this here once again
-
-        TXNLongRect textRect ;
-        TXNGetRectBounds( m_txn , NULL , NULL , &textRect ) ;
-        if ( textRect.left < m_txnControlBounds.left )
-            TXNShowSelection( m_txn , kTXNShowStart ) ;
-    }
-}
-
-void wxMacMLTEClassicControl::Move(int x, int y, int width, int height)
-{
-    wxMacControl::Move(x,y,width,height) ;
-    MacUpdatePosition() ;
-}
-
-void wxMacMLTEClassicControl::MacControlUserPaneDrawProc(wxInt16 WXUNUSED(thePart))
-{
-    wxTextCtrl* textctrl = (wxTextCtrl*)GetControlReference( m_controlRef );
-    if ( textctrl == NULL )
-        return ;
-
-    if ( textctrl->IsShownOnScreen() )
-    {
-        wxMacWindowClipper clipper( textctrl ) ;
-        TXNDraw( m_txn , NULL ) ;
-    }
-}
-
-wxInt16 wxMacMLTEClassicControl::MacControlUserPaneHitTestProc(wxInt16 x, wxInt16 y)
-{
-    Point where = { y , x } ;
-    ControlPartCode result = kControlNoPart;
-
-    wxTextCtrl* textctrl = (wxTextCtrl*) GetControlReference( m_controlRef );
-    if ( (textctrl != NULL) && textctrl->IsShownOnScreen() )
-    {
-        if (PtInRect( where, &m_txnControlBounds ))
-        {
-            result = kControlEditTextPart ;
-        }
-        else
-        {
-            // sometimes we get the coords also in control local coordinates, therefore test again
-            int x = 0 , y = 0 ;
-            textctrl->MacClientToRootWindow( &x , &y ) ;
-            where.h += x ;
-            where.v += y ;
-
-            if (PtInRect( where, &m_txnControlBounds ))
-                result = kControlEditTextPart ;
-        }
-    }
-
-    return result;
-}
-
-wxInt16 wxMacMLTEClassicControl::MacControlUserPaneTrackingProc( wxInt16 x, wxInt16 y, void* WXUNUSED(actionProc) )
-{
-    ControlPartCode result = kControlNoPart;
-
-    wxTextCtrl* textctrl = (wxTextCtrl*) GetControlReference( m_controlRef );
-    if ( (textctrl != NULL) && textctrl->IsShownOnScreen() )
-    {
-        Point startPt = { y , x } ;
-
-        // for compositing, we must convert these into toplevel window coordinates, because hittesting expects them
-        int x = 0 , y = 0 ;
-        textctrl->MacClientToRootWindow( &x , &y ) ;
-        startPt.h += x ;
-        startPt.v += y ;
-
-        switch (MacControlUserPaneHitTestProc( startPt.h , startPt.v ))
-        {
-            case kControlEditTextPart :
-            {
-                wxMacWindowClipper clipper( textctrl ) ;
-                EventRecord rec ;
-
-                ConvertEventRefToEventRecord( (EventRef) wxTheApp->MacGetCurrentEvent() , &rec ) ;
-                TXNClick( m_txn, &rec );
-            }
-                break;
-
-            default :
-                break;
-        }
-    }
-
-    return result;
-}
-
-void wxMacMLTEClassicControl::MacControlUserPaneIdleProc()
-{
-    wxTextCtrl* textctrl = (wxTextCtrl*)GetControlReference( m_controlRef );
-    if ( textctrl == NULL )
-        return ;
-
-    if (textctrl->IsShownOnScreen())
-    {
-        if (IsControlActive(m_controlRef))
-        {
-            Point mousep;
-
-            wxMacWindowClipper clipper( textctrl ) ;
-            GetMouse(&mousep);
-
-            TXNIdle(m_txn);
-
-            if (PtInRect(mousep, &m_txnControlBounds))
-            {
-                RgnHandle theRgn = NewRgn();
-                RectRgn(theRgn, &m_txnControlBounds);
-                TXNAdjustCursor(m_txn, theRgn);
-                DisposeRgn(theRgn);
-            }
-        }
-    }
-}
-
-wxInt16 wxMacMLTEClassicControl::MacControlUserPaneKeyDownProc (wxInt16 keyCode, wxInt16 charCode, wxInt16 modifiers)
-{
-    wxTextCtrl* textctrl = (wxTextCtrl*)GetControlReference( m_controlRef );
-    if ( textctrl == NULL )
-        return kControlNoPart;
-
-    wxMacWindowClipper clipper( textctrl ) ;
-
-    EventRecord ev ;
-    memset( &ev , 0 , sizeof( ev ) ) ;
-    ev.what = keyDown ;
-    ev.modifiers = modifiers ;
-    ev.message = ((keyCode << 8) & keyCodeMask) | (charCode & charCodeMask);
-    TXNKeyDown( m_txn , &ev );
-
-    return kControlEntireControl;
-}
-
-void wxMacMLTEClassicControl::MacControlUserPaneActivateProc(bool activating)
-{
-    MacActivatePaneText( activating );
-}
-
-wxInt16 wxMacMLTEClassicControl::MacControlUserPaneFocusProc(wxInt16 action)
-{
-    ControlPartCode focusResult = kControlFocusNoPart;
-
-    wxTextCtrl* textctrl = (wxTextCtrl*)GetControlReference( m_controlRef );
-    if ( textctrl == NULL )
-        return focusResult;
-
-    wxMacWindowClipper clipper( textctrl ) ;
-
-    ControlRef controlFocus = NULL ;
-    GetKeyboardFocus( m_txnWindow , &controlFocus ) ;
-    bool wasFocused = ( controlFocus == m_controlRef ) ;
-
-    switch (action)
-    {
-        case kControlFocusPrevPart:
-        case kControlFocusNextPart:
-            MacFocusPaneText( !wasFocused );
-            focusResult = (!wasFocused ? (ControlPartCode) kControlEditTextPart : (ControlPartCode) kControlFocusNoPart);
-            break;
-
-        case kControlFocusNoPart:
-        default:
-            MacFocusPaneText( false );
-            focusResult = kControlFocusNoPart;
-            break;
-    }
-
-    return focusResult;
-}
-
-void wxMacMLTEClassicControl::MacControlUserPaneBackgroundProc( void *WXUNUSED(info) )
-{
-}
-
-wxMacMLTEClassicControl::wxMacMLTEClassicControl( wxTextCtrl *wxPeer,
-    const wxString& str,
-    const wxPoint& pos,
-    const wxSize& size, long style )
-    : wxMacMLTEControl( wxPeer )
-{
-    m_font = wxPeer->GetFont() ;
-    m_windowStyle = style ;
-    Rect bounds = wxMacGetBoundsForControl( wxPeer , pos , size ) ;
-
-    short featureSet =
-        kControlSupportsEmbedding | kControlSupportsFocus | kControlWantsIdle
-        | kControlWantsActivate  | kControlHandlesTracking
-//    | kControlHasSpecialBackground
-        | kControlGetsFocusOnClick | kControlSupportsLiveFeedback;
-
-   OSStatus err = ::CreateUserPaneControl(
-        MAC_WXHWND(wxPeer->GetParent()->MacGetTopLevelWindowRef()),
-        &bounds, featureSet, &m_controlRef );
-    verify_noerr( err );
-    SetControlReference( m_controlRef , (URefCon) wxPeer );
-
-    DoCreate();
-
-    AdjustCreationAttributes( *wxWHITE , true ) ;
-
-    MacSetObjectVisibility( wxPeer->IsShownOnScreen() ) ;
-
-    {
-        wxString st = str ;
-        wxMacConvertNewlines10To13( &st ) ;
-        wxMacWindowClipper clipper( GetWXPeer() ) ;
-        SetTXNData( st , kTXNStartOffset, kTXNEndOffset ) ;
-        TXNSetSelection( m_txn, 0, 0 ) ;
-    }
-}
-
-wxMacMLTEClassicControl::~wxMacMLTEClassicControl()
-{
-    TXNDeleteObject( m_txn );
-    m_txn = NULL ;
-}
-
-void wxMacMLTEClassicControl::VisibilityChanged(bool shown)
-{
-    MacSetObjectVisibility( shown ) ;
-    wxMacControl::VisibilityChanged( shown ) ;
-}
-
-void wxMacMLTEClassicControl::SuperChangedPosition()
-{
-    MacUpdatePosition() ;
-    wxMacControl::SuperChangedPosition() ;
-}
-
-ControlUserPaneDrawUPP gTPDrawProc = NULL;
-ControlUserPaneHitTestUPP gTPHitProc = NULL;
-ControlUserPaneTrackingUPP gTPTrackProc = NULL;
-ControlUserPaneIdleUPP gTPIdleProc = NULL;
-ControlUserPaneKeyDownUPP gTPKeyProc = NULL;
-ControlUserPaneActivateUPP gTPActivateProc = NULL;
-ControlUserPaneFocusUPP gTPFocusProc = NULL;
-
-static pascal void wxMacControlUserPaneDrawProc(ControlRef control, SInt16 part)
-{
-    wxTextCtrl *textCtrl =  wxDynamicCast( wxFindWindowFromWXWidget( (WXWidget) control) , wxTextCtrl ) ;
-    wxMacMLTEClassicControl * win = textCtrl ? (wxMacMLTEClassicControl*)(textCtrl->GetPeer()) : NULL ;
-    if ( win )
-        win->MacControlUserPaneDrawProc( part ) ;
-}
-
-static pascal ControlPartCode wxMacControlUserPaneHitTestProc(ControlRef control, Point where)
-{
-    wxTextCtrl *textCtrl =  wxDynamicCast( wxFindWindowFromWXWidget( (WXWidget) control) , wxTextCtrl ) ;
-    wxMacMLTEClassicControl * win = textCtrl ? (wxMacMLTEClassicControl*)(textCtrl->GetPeer()) : NULL ;
-    if ( win )
-        return win->MacControlUserPaneHitTestProc( where.h , where.v ) ;
-    else
-        return kControlNoPart ;
-}
-
-static pascal ControlPartCode wxMacControlUserPaneTrackingProc(ControlRef control, Point startPt, ControlActionUPP actionProc)
-{
-    wxTextCtrl *textCtrl =  wxDynamicCast( wxFindWindowFromWXWidget( (WXWidget) control) , wxTextCtrl ) ;
-    wxMacMLTEClassicControl * win = textCtrl ? (wxMacMLTEClassicControl*)(textCtrl->GetPeer()) : NULL ;
-    if ( win )
-        return win->MacControlUserPaneTrackingProc( startPt.h , startPt.v , (void*) actionProc ) ;
-    else
-        return kControlNoPart ;
-}
-
-static pascal void wxMacControlUserPaneIdleProc(ControlRef control)
-{
-    wxTextCtrl *textCtrl =  wxDynamicCast( wxFindWindowFromWXWidget((WXWidget) control) , wxTextCtrl ) ;
-    wxMacMLTEClassicControl * win = textCtrl ? (wxMacMLTEClassicControl*)(textCtrl->GetPeer()) : NULL ;
-    if ( win )
-        win->MacControlUserPaneIdleProc() ;
-}
-
-static pascal ControlPartCode wxMacControlUserPaneKeyDownProc(ControlRef control, SInt16 keyCode, SInt16 charCode, SInt16 modifiers)
-{
-    wxTextCtrl *textCtrl =  wxDynamicCast( wxFindWindowFromWXWidget((WXWidget) control) , wxTextCtrl ) ;
-    wxMacMLTEClassicControl * win = textCtrl ? (wxMacMLTEClassicControl*)(textCtrl->GetPeer()) : NULL ;
-    if ( win )
-        return win->MacControlUserPaneKeyDownProc( keyCode, charCode, modifiers ) ;
-    else
-        return kControlNoPart ;
-}
-
-static pascal void wxMacControlUserPaneActivateProc(ControlRef control, Boolean activating)
-{
-    wxTextCtrl *textCtrl =  wxDynamicCast( wxFindWindowFromWXWidget( (WXWidget)control) , wxTextCtrl ) ;
-    wxMacMLTEClassicControl * win = textCtrl ? (wxMacMLTEClassicControl*)(textCtrl->GetPeer()) : NULL ;
-    if ( win )
-        win->MacControlUserPaneActivateProc( activating ) ;
-}
-
-static pascal ControlPartCode wxMacControlUserPaneFocusProc(ControlRef control, ControlFocusPart action)
-{
-    wxTextCtrl *textCtrl =  wxDynamicCast( wxFindWindowFromWXWidget((WXWidget) control) , wxTextCtrl ) ;
-    wxMacMLTEClassicControl * win = textCtrl ? (wxMacMLTEClassicControl*)(textCtrl->GetPeer()) : NULL ;
-    if ( win )
-        return win->MacControlUserPaneFocusProc( action ) ;
-    else
-        return kControlNoPart ;
-}
-
-#if 0
-static pascal void wxMacControlUserPaneBackgroundProc(ControlRef control, ControlBackgroundPtr info)
-{
-    wxTextCtrl *textCtrl =  wxDynamicCast( wxFindWindowFromWXWidget(control) , wxTextCtrl ) ;
-    wxMacMLTEClassicControl * win = textCtrl ? (wxMacMLTEClassicControl*)(textCtrl->GetPeer()) : NULL ;
-    if ( win )
-        win->MacControlUserPaneBackgroundProc(info) ;
-}
-#endif
-
-// TXNRegisterScrollInfoProc
-
-OSStatus wxMacMLTEClassicControl::DoCreate()
-{
-    Rect bounds;
-    OSStatus err = noErr ;
-
-    // set up our globals
-    if (gTPDrawProc == NULL) gTPDrawProc = NewControlUserPaneDrawUPP(wxMacControlUserPaneDrawProc);
-    if (gTPHitProc == NULL) gTPHitProc = NewControlUserPaneHitTestUPP(wxMacControlUserPaneHitTestProc);
-    if (gTPTrackProc == NULL) gTPTrackProc = NewControlUserPaneTrackingUPP(wxMacControlUserPaneTrackingProc);
-    if (gTPIdleProc == NULL) gTPIdleProc = NewControlUserPaneIdleUPP(wxMacControlUserPaneIdleProc);
-    if (gTPKeyProc == NULL) gTPKeyProc = NewControlUserPaneKeyDownUPP(wxMacControlUserPaneKeyDownProc);
-    if (gTPActivateProc == NULL) gTPActivateProc = NewControlUserPaneActivateUPP(wxMacControlUserPaneActivateProc);
-    if (gTPFocusProc == NULL) gTPFocusProc = NewControlUserPaneFocusUPP(wxMacControlUserPaneFocusProc);
-
-    if (gTXNScrollInfoProc == NULL ) gTXNScrollInfoProc = NewTXNScrollInfoUPP(TXNScrollInfoProc) ;
-    if (gTXNScrollActionProc == NULL ) gTXNScrollActionProc = NewControlActionUPP(TXNScrollActionProc) ;
-
-    // set the initial settings for our private data
-
-    m_txnWindow = GetControlOwner(m_controlRef);
-    m_txnPort = (GrafPtr) GetWindowPort(m_txnWindow);
-
-    // set up the user pane procedures
-    SetControlData(m_controlRef, kControlEntireControl, kControlUserPaneDrawProcTag, sizeof(gTPDrawProc), &gTPDrawProc);
-    SetControlData(m_controlRef, kControlEntireControl, kControlUserPaneHitTestProcTag, sizeof(gTPHitProc), &gTPHitProc);
-    SetControlData(m_controlRef, kControlEntireControl, kControlUserPaneTrackingProcTag, sizeof(gTPTrackProc), &gTPTrackProc);
-    SetControlData(m_controlRef, kControlEntireControl, kControlUserPaneIdleProcTag, sizeof(gTPIdleProc), &gTPIdleProc);
-    SetControlData(m_controlRef, kControlEntireControl, kControlUserPaneKeyDownProcTag, sizeof(gTPKeyProc), &gTPKeyProc);
-    SetControlData(m_controlRef, kControlEntireControl, kControlUserPaneActivateProcTag, sizeof(gTPActivateProc), &gTPActivateProc);
-    SetControlData(m_controlRef, kControlEntireControl, kControlUserPaneFocusProcTag, sizeof(gTPFocusProc), &gTPFocusProc);
-
-    // calculate the rectangles used by the control
-    GetRectInWindowCoords( &bounds );
-
-    m_txnControlBounds = bounds ;
-    m_txnVisBounds = bounds ;
-
-    CGrafPtr origPort ;
-    GDHandle origDev ;
-
-    GetGWorld( &origPort, &origDev ) ;
-    SetPort( m_txnPort );
-
-    // create the new edit field
-    TXNFrameOptions frameOptions = FrameOptionsFromWXStyle( m_windowStyle );
-
-    // the scrollbars are not correctly embedded but are inserted at the root:
-    // this gives us problems as we have erratic redraws even over the structure area
-
-    m_sbHorizontal = 0 ;
-    m_sbVertical = 0 ;
-    m_lastHorizontalValue = 0 ;
-    m_lastVerticalValue = 0 ;
-
-    Rect sb = { 0 , 0 , 0 , 0 } ;
-    if ( frameOptions & kTXNWantVScrollBarMask )
-    {
-        CreateScrollBarControl( m_txnWindow, &sb, 0, 0, 100, 1, true, gTXNScrollActionProc, &m_sbVertical );
-        SetControlReference( m_sbVertical, (SInt32)this );
-        SetControlAction( m_sbVertical, gTXNScrollActionProc );
-        ShowControl( m_sbVertical );
-        EmbedControl( m_sbVertical , m_controlRef );
-        frameOptions &= ~kTXNWantVScrollBarMask;
-    }
-
-    if ( frameOptions & kTXNWantHScrollBarMask )
-    {
-        CreateScrollBarControl( m_txnWindow, &sb, 0, 0, 100, 1, true, gTXNScrollActionProc, &m_sbHorizontal );
-        SetControlReference( m_sbHorizontal, (SInt32)this );
-        SetControlAction( m_sbHorizontal, gTXNScrollActionProc );
-        ShowControl( m_sbHorizontal );
-        EmbedControl( m_sbHorizontal, m_controlRef );
-        frameOptions &= ~(kTXNWantHScrollBarMask | kTXNDrawGrowIconMask);
-    }
-
-    err = TXNNewObject(
-        NULL, m_txnWindow, &bounds, frameOptions,
-        kTXNTextEditStyleFrameType, kTXNTextensionFile, kTXNSystemDefaultEncoding,
-        &m_txn, &m_txnFrameID, NULL );
-    verify_noerr( err );
-
-#if 0
-    TXNControlTag iControlTags[] = { kTXNUseCarbonEvents };
-    TXNControlData iControlData[] = { { (UInt32)&cInfo } };
-    int toptag = WXSIZEOF( iControlTags ) ;
-    TXNCarbonEventInfo cInfo ;
-    cInfo.useCarbonEvents = false ;
-    cInfo.filler = 0 ;
-    cInfo.flags = 0 ;
-    cInfo.fDictionary = NULL ;
-
-    verify_noerr( TXNSetTXNObjectControls( m_txn, false, toptag, iControlTags, iControlData ) );
-#endif
-
-    TXNRegisterScrollInfoProc( m_txn, gTXNScrollInfoProc, (SInt32)this );
-
-    SetGWorld( origPort , origDev ) ;
-
-    return err;
-}
-#endif
-
 // ----------------------------------------------------------------------------
 // MLTE control implementation (OSX part)
 // ----------------------------------------------------------------------------
--- src/osx/carbon/toolbar.cpp
+++ src/osx/carbon/toolbar.cpp
@@ -113,14 +113,6 @@ public:
         if ( m_toolbarItemRef )
         {
             CFIndex count = CFGetRetainCount( m_toolbarItemRef ) ;
-            // different behaviour under Leopard
-            if ( UMAGetSystemVersion() < 0x1050 )
-            {
-                if ( count != 1 )
-                {
-                    wxFAIL_MSG("Reference count of native tool was not 1 in wxToolBarTool destructor");
-                }
-            }
             wxTheApp->MacAddToAutorelease(m_toolbarItemRef);
             CFRelease(m_toolbarItemRef);
             m_toolbarItemRef = NULL;
@@ -941,14 +933,6 @@ wxToolBar::~wxToolBar()
     }
 
     CFIndex count = CFGetRetainCount( m_macToolbar ) ;
-    // Leopard seems to have one refcount more, so we cannot check reliably at the moment
-    if ( UMAGetSystemVersion() < 0x1050 )
-    {
-        if ( count != 1 )
-        {
-            wxFAIL_MSG("Reference count of native control was not 1 in wxToolBar destructor");
-        }
-    }
     CFRelease( (HIToolbarRef)m_macToolbar );
     m_macToolbar = NULL;
 #endif // wxOSX_USE_NATIVE_TOOLBAR
@@ -1619,23 +1603,11 @@ bool wxToolBar::DoInsertTool(size_t WXUNUSED(pos), wxToolBarToolBase *toolBase)
                 ControlButtonContentInfo info;
                 wxMacCreateBitmapButton( &info, tool->GetNormalBitmap() );
 
-                if ( UMAGetSystemVersion() >= 0x1000)
-                {
-                    // contrary to the docs this control only works with iconrefs
-                    ControlButtonContentInfo info;
-                    wxMacCreateBitmapButton( &info, tool->GetNormalBitmap(), kControlContentIconRef );
-                    CreateIconControl( window, &toolrect, &info, false, &controlHandle );
-                    wxMacReleaseBitmapButton( &info );
-                }
-                else
-                {
-                    SInt16 behaviour = kControlBehaviorOffsetContents;
-                    if ( tool->CanBeToggled() )
-                        behaviour |= kControlBehaviorToggles;
-                    err = CreateBevelButtonControl( window,
-                        &toolrect, CFSTR(""), kControlBevelButtonNormalBevel,
-                        behaviour, &info, 0, 0, 0, &controlHandle );
-                }
+                // contrary to the docs this control only works with iconrefs
+                ControlButtonContentInfo info;
+                wxMacCreateBitmapButton( &info, tool->GetNormalBitmap(), kControlContentIconRef );
+                CreateIconControl( window, &toolrect, &info, false, &controlHandle );
+                wxMacReleaseBitmapButton( &info );
 
 #if wxOSX_USE_NATIVE_TOOLBAR
                 if (m_macToolbar != NULL)
--- src/osx/carbon/utils.cpp
+++ src/osx/carbon/utils.cpp
@@ -33,9 +33,7 @@
 
 // #include "MoreFilesX.h"
 
-#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
-    #include <AudioToolbox/AudioServices.h>
-#endif
+#include <AudioToolbox/AudioServices.h>
 
 #include "wx/osx/private.h"
 #if wxUSE_GUI
@@ -49,17 +47,8 @@
 // Emit a beeeeeep
 void wxBell()
 {
-#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
     if ( AudioServicesPlayAlertSound != NULL )
         AudioServicesPlayAlertSound(kUserPreferredAlert);
-    else
-#endif
-#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
-        AlertSoundPlay();
-#else
-    {
-    }
-#endif
 }
 
 wxTimerImpl* wxGUIAppTraits::CreateTimerImpl(wxTimer *timer)
@@ -156,7 +145,6 @@ void wxGetMousePosition( int* x, int* y )
 
 void wxClientDisplayRect(int *x, int *y, int *width, int *height)
 {
-#if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5
     HIRect bounds ;
     HIWindowGetAvailablePositioningBounds(kCGNullDirectDisplay,kHICoordSpace72DPIGlobal,
             &bounds);
@@ -168,18 +156,6 @@ void wxClientDisplayRect(int *x, int *y, int *width, int *height)
         *width = bounds.size.width;
     if ( height )
         *height = bounds.size.height;
-#else
-    Rect r;
-    GetAvailableWindowPositioningBounds( GetMainDevice() , &r );
-    if ( x )
-        *x = r.left;
-    if ( y )
-        *y = r.top;
-    if ( width )
-        *width = r.right - r.left;
-    if ( height )
-        *height = r.bottom - r.top;
-#endif
 }
 
 #endif // wxUSE_GUI
--- src/osx/carbon/window.cpp
+++ src/osx/carbon/window.cpp
@@ -299,11 +299,6 @@ static pascal OSStatus wxMacWindowControlEventHandler( EventHandlerCallRef handl
         case kEventControlFocusPartChanged :
             // the event is emulated by wxmac for systems lower than 10.5
             {
-                if ( UMAGetSystemVersion() < 0x1050 )
-                {
-                    // as it is synthesized here, we have to manually avoid propagation
-                    result = noErr;
-                }
                 ControlPartCode previousControlPart = cEvent.GetParameter<ControlPartCode>(kEventParamControlPreviousPart , typeControlPartCode );
                 ControlPartCode currentControlPart = cEvent.GetParameter<ControlPartCode>(kEventParamControlCurrentPart , typeControlPartCode );
 
@@ -387,76 +382,6 @@ static pascal OSStatus wxMacWindowControlEventHandler( EventHandlerCallRef handl
                 }
                 else
                     result = CallNextEventHandler(handler, event);
-
-                if ( UMAGetSystemVersion() < 0x1050 )
-                {
-// set back to 0 if problems arise
-#if 1
-                    if ( result == noErr )
-                    {
-                        ControlPartCode currentControlPart = cEvent.GetParameter<ControlPartCode>(kEventParamControlPart , typeControlPartCode );
-                        // synthesize the event focus changed event
-                        EventRef evRef = NULL ;
-
-                        OSStatus err = MacCreateEvent(
-                                             NULL , kEventClassControl , kEventControlFocusPartChanged , TicksToEventTime( TickCount() ) ,
-                                             kEventAttributeUserEvent , &evRef );
-                        verify_noerr( err );
-
-                        wxMacCarbonEvent iEvent( evRef ) ;
-                        iEvent.SetParameter<ControlRef>( kEventParamDirectObject , controlRef );
-                        iEvent.SetParameter<EventTargetRef>( kEventParamPostTarget, typeEventTargetRef, GetControlEventTarget( controlRef ) );
-                        iEvent.SetParameter<ControlPartCode>( kEventParamControlPreviousPart, typeControlPartCode, previousControlPart );
-                        iEvent.SetParameter<ControlPartCode>( kEventParamControlCurrentPart, typeControlPartCode, currentControlPart );
-
-#if 1
-                        // TODO test this first, avoid double posts etc...
-                        PostEventToQueue( GetMainEventQueue(), evRef , kEventPriorityHigh );
-#else
-                        wxMacWindowControlEventHandler( NULL , evRef , data ) ;
-#endif
-                        ReleaseEvent( evRef ) ;
-                    }
-#else
-                    // old implementation, to be removed if the new one works
-                    if ( controlPart == kControlFocusNoPart )
-                    {
-#if wxUSE_CARET
-                        if ( thisWindow->GetCaret() )
-                            thisWindow->GetCaret()->OnKillFocus();
-#endif
-
-                        wxLogTrace(wxT("Focus"), wxT("focus lost(%p)"), static_cast<void*>(thisWindow));
-
-                        static bool inKillFocusEvent = false ;
-
-                        if ( !inKillFocusEvent )
-                        {
-                            inKillFocusEvent = true ;
-                            wxFocusEvent event( wxEVT_KILL_FOCUS, thisWindow->GetId());
-                            event.SetEventObject(thisWindow);
-                            thisWindow->HandleWindowEvent(event) ;
-                            inKillFocusEvent = false ;
-                        }
-                    }
-                    else
-                    {
-                        // panel wants to track the window which was the last to have focus in it
-                        wxLogTrace(wxT("Focus"), wxT("focus set(%p)"), static_cast<void*>(thisWindow));
-                        wxChildFocusEvent eventFocus((wxWindow*)thisWindow);
-                        thisWindow->HandleWindowEvent(eventFocus);
-
-    #if wxUSE_CARET
-                        if ( thisWindow->GetCaret() )
-                            thisWindow->GetCaret()->OnSetFocus();
-    #endif
-
-                        wxFocusEvent event(wxEVT_SET_FOCUS, thisWindow->GetId());
-                        event.SetEventObject(thisWindow);
-                        thisWindow->HandleWindowEvent(event) ;
-                    }
-#endif
-                }
             }
             break ;
 
@@ -1136,19 +1061,10 @@ void wxMacControl::SetCursor(const wxCursor& cursor)
         ControlPartCode part ;
         ControlRef control ;
         Point pt ;
-#if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5
         HIPoint hiPoint ;
         HIGetMousePosition(kHICoordSpaceWindow, window, &hiPoint);
         pt.h = hiPoint.x;
         pt.v = hiPoint.y;
-#else
-        GetGlobalMouse( &pt );
-        int x = pt.h;
-        int y = pt.v;
-        tlwwx->ScreenToClient(&x, &y);
-        pt.h = x;
-        pt.v = y;
-#endif
         control = FindControlUnderMouse( pt , window , &part ) ;
         if ( control )
             mouseWin = wxFindWindowFromWXWidget( (WXWidget) control ) ;
@@ -1262,27 +1178,22 @@ void wxMacControl::SuperChangedPosition()
 void wxMacControl::SetFont( const wxFont & font , const wxColour& foreground , long windowStyle, bool ignoreBlack )
 {
     m_font = font;
-#if wxOSX_USE_CORE_TEXT
-    if ( UMAGetSystemVersion() >= 0x1050 )
+    HIViewPartCode part = 0;
+    HIThemeTextHorizontalFlush flush = kHIThemeTextHorizontalFlushDefault;
+    if ( ( windowStyle & wxALIGN_MASK ) & wxALIGN_CENTER_HORIZONTAL )
+        flush = kHIThemeTextHorizontalFlushCenter;
+    else if ( ( windowStyle & wxALIGN_MASK ) & wxALIGN_RIGHT )
+        flush = kHIThemeTextHorizontalFlushRight;
+    HIViewSetTextFont( m_controlRef , part , (CTFontRef) font.OSXGetCTFont() );
+    HIViewSetTextHorizontalFlush( m_controlRef, part, flush );
+
+    if ( foreground != *wxBLACK || ignoreBlack == false )
     {
-        HIViewPartCode part = 0;
-        HIThemeTextHorizontalFlush flush = kHIThemeTextHorizontalFlushDefault;
-        if ( ( windowStyle & wxALIGN_MASK ) & wxALIGN_CENTER_HORIZONTAL )
-            flush = kHIThemeTextHorizontalFlushCenter;
-        else if ( ( windowStyle & wxALIGN_MASK ) & wxALIGN_RIGHT )
-            flush = kHIThemeTextHorizontalFlushRight;
-        HIViewSetTextFont( m_controlRef , part , (CTFontRef) font.OSXGetCTFont() );
-        HIViewSetTextHorizontalFlush( m_controlRef, part, flush );
-
-        if ( foreground != *wxBLACK || ignoreBlack == false )
-        {
-            ControlFontStyleRec fontStyle;
-            foreground.GetRGBColor( &fontStyle.foreColor );
-            fontStyle.flags = kControlUseForeColorMask;
-            ::SetControlFontStyle( m_controlRef , &fontStyle );
-        }
+        ControlFontStyleRec fontStyle;
+        foreground.GetRGBColor( &fontStyle.foreColor );
+        fontStyle.flags = kControlUseForeColorMask;
+        ::SetControlFontStyle( m_controlRef , &fontStyle );
     }
-#endif
 #if wxOSX_USE_ATSU_TEXT
     ControlFontStyleRec fontStyle;
     if ( font.MacGetThemeFontID() != kThemeCurrentPortFont )
--- src/osx/cocoa/dataview.mm
+++ src/osx/cocoa/dataview.mm
@@ -367,10 +367,8 @@ NSTableColumn* CreateNativeColumn(const wxDataViewColumn *column)
     }
     [nativeColumn setResizingMask:resizingMask];
 
-#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
     // setting the visibility:
     [nativeColumn setHidden:static_cast<BOOL>(column->IsHidden())];
-#endif
 
     wxDataViewRendererNativeData * const renderData = renderer->GetNativeData();
 
@@ -1486,7 +1484,6 @@ outlineView:(NSOutlineView*)outlineView
     [super editWithFrame:textFrame inView:controlView editor:textObj delegate:anObject event:theEvent];
 }
 
-#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
 -(NSUInteger) hitTestForEvent:(NSEvent*)event inRect:(NSRect)cellFrame ofView:(NSView*)controlView
 {
     NSPoint point = [controlView convertPoint:[event locationInWindow] fromView:nil];
@@ -1528,7 +1525,6 @@ outlineView:(NSOutlineView*)outlineView
 
     return [super hitTestForEvent:event inRect:textFrame ofView:controlView];
 }
-#endif
 
 -(NSRect) imageRectForBounds:(NSRect)cellFrame
 {
@@ -2060,7 +2056,6 @@ bool wxCocoaDataViewControl::InsertColumn(unsigned int pos, wxDataViewColumn* co
 
 void wxCocoaDataViewControl::FitColumnWidthToContent(unsigned int pos)
 {
-#if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5
     const int count = GetCount();
     NSTableColumn *column = GetColumn(pos)->GetNativeData()->GetNativeColumnPtr();
 
@@ -2173,7 +2168,6 @@ void wxCocoaDataViewControl::FitColumnWidthToContent(unsigned int pos)
     }
 
     [column setWidth:calculator.GetMaxWidth()];
-#endif // MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5
 }
 
 //
@@ -3295,15 +3289,13 @@ void wxDataViewColumn::SetWidth(int width)
     switch ( width )
     {
         case wxCOL_WIDTH_AUTOSIZE:
-#if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5
             if ( GetOwner() )
             {
                 wxCocoaDataViewControl *peer = static_cast<wxCocoaDataViewControl*>(GetOwner()->GetPeer());
                 peer->FitColumnWidthToContent(GetOwner()->GetColumnPosition(this));
                 break;
             }
-#endif
-            // fall through if unsupported (OSX < 10.5) or not yet settable
+            // fall through if not yet settable
 
         case wxCOL_WIDTH_DEFAULT:
             width = wxDVC_DEFAULT_WIDTH;
--- src/osx/cocoa/evtloop.mm
+++ src/osx/cocoa/evtloop.mm
@@ -66,10 +66,8 @@ static NSUInteger CalculateNSEventMaskFromEventCategory(wxEventCategory cat)
             NSMouseEnteredMask |
             NSMouseExitedMask |
             NSScrollWheelMask |
-#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_4
             NSTabletPointMask |
             NSTabletProximityMask |
-#endif
             NSOtherMouseDownMask |
             NSOtherMouseUpMask |
             NSOtherMouseDraggedMask |
@@ -77,14 +75,12 @@ static NSUInteger CalculateNSEventMaskFromEventCategory(wxEventCategory cat)
             NSKeyDownMask |
             NSKeyUpMask |
             NSFlagsChangedMask |
-#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
             NSEventMaskGesture |
             NSEventMaskMagnify |
             NSEventMaskSwipe |
             NSEventMaskRotate |
             NSEventMaskBeginGesture |
             NSEventMaskEndGesture |
-#endif
             0;
     }
     
--- src/osx/cocoa/scrolbar.mm
+++ src/osx/cocoa/scrolbar.mm
@@ -57,12 +57,8 @@ public :
     {
         double v = ((double) value)/m_maximum;
         double t = ((double) thumbSize)/(m_maximum+thumbSize);
-#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
-        [(wxNSScroller*) m_osxView setFloatValue:v knobProportion:t];
-#else
         [(wxNSScroller*) m_osxView setDoubleValue:v];
         [(wxNSScroller*) m_osxView setKnobProportion:t];
-#endif
     }
 
     virtual wxInt32 GetValue() const
--- src/osx/core/fontenum.cpp
+++ src/osx/core/fontenum.cpp
@@ -40,8 +40,7 @@ bool wxFontEnumerator::EnumerateFacenames(wxFontEncoding encoding,
      wxArrayString fontFamilies ;
 
     wxUint32 macEncoding = wxMacGetSystemEncFromFontEnc(encoding) ;
-    
-#if wxOSX_USE_CORE_TEXT
+
     {
         CFArrayRef cfFontFamilies = nil;
 
@@ -127,7 +126,6 @@ bool wxFontEnumerator::EnumerateFacenames(wxFontEncoding encoding,
         
         CFRelease(cfFontFamilies);
     }
-#endif
     for ( size_t i = 0 ; i < fontFamilies.Count() ; ++i )
     {
         if ( OnFacename( fontFamilies[i] ) == false )
--- src/osx/iphone/evtloop.mm
+++ src/osx/iphone/evtloop.mm
@@ -54,10 +54,8 @@ static int CalculateUIEventMaskFromEventCategory(wxEventCategory cat)
 	NSMouseEnteredMask		= 1 << NSMouseEntered,
 	NSMouseExitedMask		= 1 << NSMouseExited,
         NSScrollWheelMask		= 1 << NSScrollWheel,
-#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_4
 	NSTabletPointMask		= 1 << NSTabletPoint,
 	NSTabletProximityMask		= 1 << NSTabletProximity,
-#endif
 	NSOtherMouseDownMask		= 1 << NSOtherMouseDown,
 	NSOtherMouseUpMask		= 1 << NSOtherMouseUp,
 	NSOtherMouseDraggedMask		= 1 << NSOtherMouseDragged,
--- src/osx/webview_webkit.mm
+++ src/osx/webview_webkit.mm
@@ -351,10 +351,7 @@ bool wxWebViewWebKit::Create(wxWindow *parent,
 
     m_webView = (WebView*) HIWebViewGetWebView( peer->GetControlRef() );
 
-#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_3
-    if ( UMAGetSystemVersion() >= 0x1030 )
-        HIViewChangeFeatures( peer->GetControlRef() , kHIViewIsOpaque , 0 ) ;
-#endif
+    HIViewChangeFeatures( peer->GetControlRef() , kHIViewIsOpaque , 0 ) ;
     InstallControlEventHandler(peer->GetControlRef(),
                                GetwxWebViewWebKitEventHandlerUPP(),
                                GetEventTypeCount(eventList), eventList, this,
@@ -1074,9 +1071,7 @@ wxString nsErrorToWxHtmlError(NSError* error, wxWebViewNavigationError* out)
 
             case NSURLErrorResourceUnavailable:
             case NSURLErrorHTTPTooManyRedirects:
-#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
             case NSURLErrorDataLengthExceedsMaximum:
-#endif
             case NSURLErrorBadURL:
             case NSURLErrorFileIsDirectory:
                 *out = wxWEBVIEW_NAV_ERR_REQUEST;
@@ -1098,20 +1093,16 @@ wxString nsErrorToWxHtmlError(NSError* error, wxWebViewNavigationError* out)
                 *out = wxWEBVIEW_NAV_ERR_USER_CANCELLED;
                 break;
 
-#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
             case NSURLErrorCannotDecodeRawData:
             case NSURLErrorCannotDecodeContentData:
             case NSURLErrorCannotParseResponse:
-#endif
             case NSURLErrorBadServerResponse:
                 *out = wxWEBVIEW_NAV_ERR_REQUEST;
                 break;
 
             case NSURLErrorUserAuthenticationRequired:
             case NSURLErrorSecureConnectionFailed:
-#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6
             case NSURLErrorClientCertificateRequired:
-#endif
                 *out = wxWEBVIEW_NAV_ERR_AUTH;
                 break;
 
--- src/unix/dlunix.cpp
+++ src/unix/dlunix.cpp
@@ -64,171 +64,6 @@
 // constants
 // ----------------------------------------------------------------------------
 
-// ============================================================================
-// wxDynamicLibrary implementation
-// ============================================================================
-
-// ----------------------------------------------------------------------------
-// dlxxx() emulation for Darwin
-// Only useful if the OS X version could be < 10.3 at runtime
-// ----------------------------------------------------------------------------
-
-#if defined(__DARWIN__) && (MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3)
-// ---------------------------------------------------------------------------
-// For Darwin/Mac OS X
-//   supply the sun style dlopen functions in terms of Darwin NS*
-// ---------------------------------------------------------------------------
-
-/* Porting notes:
- *   The dlopen port is a port from dl_next.xs by Anno Siegel.
- *   dl_next.xs is itself a port from dl_dlopen.xs by Paul Marquess.
- *   The method used here is just to supply the sun style dlopen etc.
- *   functions in terms of Darwin NS*.
- */
-
-#include <stdio.h>
-#include <mach-o/dyld.h>
-
-static char dl_last_error[1024];
-
-static const char *wx_darwin_dlerror()
-{
-    return dl_last_error;
-}
-
-static void *wx_darwin_dlopen(const char *path, int WXUNUSED(mode) /* mode is ignored */)
-{
-    NSObjectFileImage ofile;
-    NSModule handle = NULL;
-
-    unsigned dyld_result = NSCreateObjectFileImageFromFile(path, &ofile);
-    if ( dyld_result != NSObjectFileImageSuccess )
-    {
-        handle = NULL;
-
-        static const char *const errorStrings[] =
-        {
-            "%d: Object Image Load Failure",
-            "%d: Object Image Load Success",
-            "%d: Not an recognisable object file",
-            "%d: No valid architecture",
-            "%d: Object image has an invalid format",
-            "%d: Invalid access (permissions?)",
-            "%d: Unknown error code from NSCreateObjectFileImageFromFile"
-        };
-
-        const int index = dyld_result < WXSIZEOF(errorStrings)
-                            ? dyld_result
-                            : WXSIZEOF(errorStrings) - 1;
-
-        // this call to sprintf() is safe as strings above are fixed at
-        // compile-time and are shorter than WXSIZEOF(dl_last_error)
-        sprintf(dl_last_error, errorStrings[index], dyld_result);
-    }
-    else
-    {
-        handle = NSLinkModule
-                 (
-                    ofile,
-                    path,
-                    NSLINKMODULE_OPTION_BINDNOW |
-                    NSLINKMODULE_OPTION_RETURN_ON_ERROR
-                 );
-
-        if ( !handle )
-        {
-            NSLinkEditErrors err;
-            int code;
-            const char *filename;
-            const char *errmsg;
-
-            NSLinkEditError(&err, &code, &filename, &errmsg);
-            strncpy(dl_last_error, errmsg, WXSIZEOF(dl_last_error)-1);
-            dl_last_error[WXSIZEOF(dl_last_error)-1] = '\0';
-        }
-    }
-
-
-    return handle;
-}
-
-static int wx_darwin_dlclose(void *handle)
-{
-    NSUnLinkModule((NSModule)handle, NSUNLINKMODULE_OPTION_NONE);
-    return 0;
-}
-
-static void *wx_darwin_dlsym(void *handle, const char *symbol)
-{
-    // as on many other systems, C symbols have prepended underscores under
-    // Darwin but unlike the normal dlopen(), NSLookupSymbolInModule() is not
-    // aware of this
-    wxCharBuffer buf(strlen(symbol) + 1);
-    char *p = buf.data();
-    p[0] = '_';
-    strcpy(p + 1, symbol);
-
-    NSSymbol nsSymbol = NSLookupSymbolInModule((NSModule)handle, p );
-    return nsSymbol ? NSAddressOfSymbol(nsSymbol) : NULL;
-}
-
-// Add the weak linking attribute to dlopen's declaration
-extern void * dlopen(const char * __path, int __mode) AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;
-
-// For all of these methods we test dlopen since all of the dl functions we use were added
-// to OS X at the same time.  This also ensures we don't dlopen with the real function then
-// dlclose with the internal implementation.
-
-static inline void *wx_dlopen(const char *__path, int __mode)
-{
-#ifdef HAVE_DLOPEN
-    if(&dlopen != NULL)
-        return dlopen(__path, __mode);
-    else
-#endif
-        return wx_darwin_dlopen(__path, __mode);
-}
-
-static inline int wx_dlclose(void *__handle)
-{
-#ifdef HAVE_DLOPEN
-    if(&dlopen != NULL)
-        return dlclose(__handle);
-    else
-#endif
-        return wx_darwin_dlclose(__handle);
-}
-
-static inline const char *wx_dlerror()
-{
-#ifdef HAVE_DLOPEN
-    if(&dlopen != NULL)
-        return dlerror();
-    else
-#endif
-        return wx_darwin_dlerror();
-}
-
-static inline void *wx_dlsym(void *__handle, const char *__symbol)
-{
-#ifdef HAVE_DLOPEN
-    if(&dlopen != NULL)
-        return dlsym(__handle, __symbol);
-    else
-#endif
-        return wx_darwin_dlsym(__handle, __symbol);
-}
-
-#else // __DARWIN__/!__DARWIN__
-
-// Use preprocessor definitions for non-Darwin or OS X >= 10.3
-#define wx_dlopen(__path,__mode) dlopen(__path,__mode)
-#define wx_dlclose(__handle) dlclose(__handle)
-#define wx_dlerror() dlerror()
-#define wx_dlsym(__handle,__symbol) dlsym(__handle,__symbol)
-
-#endif // defined(__DARWIN__)
-
 // ----------------------------------------------------------------------------
 // loading/unloading DLLs
 // ----------------------------------------------------------------------------
@@ -236,7 +71,7 @@ static inline void *wx_dlsym(void *__handle, const char *__symbol)
 wxDllType wxDynamicLibrary::GetProgramHandle()
 {
 #ifdef USE_POSIX_DL_FUNCS
-   return wx_dlopen(0, RTLD_LAZY);
+   return dlopen(0, RTLD_LAZY);
 #else
    return PROG_HANDLE;
 #endif
@@ -257,7 +92,7 @@ wxDllType wxDynamicLibrary::RawLoad(const wxString& libname, int flags)
     if ( flags & wxDL_GLOBAL )
         rtldFlags |= RTLD_GLOBAL;
 
-    return wx_dlopen(libname.fn_str(), rtldFlags);
+    return dlopen(libname.fn_str(), rtldFlags);
 #else // !USE_POSIX_DL_FUNCS
     int shlFlags = 0;
 
@@ -282,7 +117,7 @@ void wxDynamicLibrary::Unload(wxDllType handle)
 #endif
 
 #ifdef USE_POSIX_DL_FUNCS
-    wx_dlclose(handle);
+    dlclose(handle);
 #else // !USE_POSIX_DL_FUNCS
     shl_unload(handle);
 #endif // USE_POSIX_DL_FUNCS/!USE_POSIX_DL_FUNCS
@@ -299,7 +134,7 @@ void *wxDynamicLibrary::RawGetSymbol(wxDllType handle, const wxString& name)
     void *symbol;
 
 #ifdef USE_POSIX_DL_FUNCS
-    symbol = wx_dlsym(handle, name.fn_str());
+    symbol = dlsym(handle, name.fn_str());
 #else // !USE_POSIX_DL_FUNCS
     // note that shl_findsym modifies the handle argument to indicate where the
     // symbol was found, but it's ok to modify the local handle copy here
@@ -319,7 +154,7 @@ void *wxDynamicLibrary::RawGetSymbol(wxDllType handle, const wxString& name)
 /* static */
 void wxDynamicLibrary::Error()
 {
-    wxString err(wx_dlerror());
+    wxString err(dlerror());
 
     if ( err.empty() )
         err = _("Unknown dynamic library error");
